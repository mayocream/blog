<!doctype html><html lang=ja><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Kong ingress controller æºç é˜…è¯» - Mayo's Blog</title>
<meta name=description content="è¯¥ç¨‹åºå¯åŠ¨åæœ‰ä»¥ä¸‹ä¸»è¦æ­¥éª¤ï¼š ä»å‘½ä»¤è¡Œå’Œç¯å¢ƒå˜é‡è§£æå…¥å‚ (# flags.go) å°è¯•ä¸ Kubernetes API Server å»ºç«‹è¿æ¥ (# func createApiserverClient) ä¸ Kong Admin API é€šä¿¡ (# func kong.NewClient) åˆ›å»ºç›‘å¬èµ„æºå˜åŒ–çš„ Informer åˆ›å»ºèµ„æºé”ç«äº‰é€‰ä¸¾">
<meta name=author content>
<link rel=preconnect href=https://cdn.jsdelivr.net>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Press+Start+2P" rel=stylesheet>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400&family=Noto+Sans+JP:wght@300;400&family=Noto+Sans+SC:wght@300;400&family=Noto+Serif:wght@300;400&family=Noto+Serif+JP:wght@300;400&family=Noto+Serif+SC:wght@300;400&family=Source+Code+Pro:wght@300;400" rel=stylesheet>
<link rel=stylesheet href="/bundle.css?v=1717977410" media=all>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.css>
<link rel=icon href=https://github.com/mayocream.png><meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://mayo.rocks/2021/11/kong-ingress-controller-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/><meta property="og:title" content="Kong ingress controller æºç é˜…è¯»">
<meta property="og:description" content="è¯¥ç¨‹åºå¯åŠ¨åæœ‰ä»¥ä¸‹ä¸»è¦æ­¥éª¤ï¼š ä»å‘½ä»¤è¡Œå’Œç¯å¢ƒå˜é‡è§£æå…¥å‚ (# flags.go) å°è¯•ä¸ Kubernetes API Server å»ºç«‹è¿æ¥ (# func createApiserverClient) ä¸ Kong Admin API é€šä¿¡ (# func kong.NewClient) åˆ›å»ºç›‘å¬èµ„æºå˜åŒ–çš„ Informer åˆ›å»ºèµ„æºé”ç«äº‰é€‰ä¸¾">
<meta property="og:type" content="article">
<meta property="og:url" content="https://mayo.rocks/2021/11/kong-ingress-controller-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-06T13:30:00+08:00">
<meta property="article:modified_time" content="2021-11-06T13:30:00+08:00"><meta property="og:site_name" content="Mayo's Blog">
</head>
</html>
<body><script src=https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>const opts={bottom:'32px',right:'unset',left:'32px',time:'0.3s',mixColor:'#fff',backgroundColor:'#fff',buttonColorDark:'#100f2c',buttonColorLight:'#fff',saveInCookies:!0,label:'ğŸŒ“',autoMatchOsTheme:!0};let darkmode;window.matchMedia('only screen and (min-width: 680px)').matches?(darkmode=new Darkmode(opts),darkmode.showWidget()):(localStorage.removeItem('darkmode'),darkmode=new Darkmode(opts)),window.darkmode=darkmode,document.addEventListener('DOMContentLoaded',function(){document.body.style.opacity=1})</script>
<main class=page-content aria-label=Content>
<div class=wrapper><nav class=site-nav>
<a class=page-link href=/posts/>Posts</a>
<a class=page-link href=/about/>About</a>
</nav><header class=post-header>
<a class=site-title href=https://mayo.rocks>Mayo's Blog</a>
<h1 class="post-title baseline-fix typeface-sans" lang=ja itemprop="name headline">Kong ingress controller æºç é˜…è¯»</h1>
</header>
<div class=post-cover aria-label=Cover>
<div class=post-cover-wrapper>
<img src alt>
</div>
<div class=cover-meta></div>
</div>
<div class=post-layout>
<article class="post typeface-sans" lang=ja itemscope itemtype=http://schema.org/BlogPosting>
<div class=post-content itemprop=articleBody>
<p>
<figure class=image>
<img src=/2021/11/kong-ingress-controller-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/images/flow.png alt loading=lazy>
</figure></p>
<p>è¯¥ç¨‹åºå¯åŠ¨åæœ‰ä»¥ä¸‹ä¸»è¦æ­¥éª¤ï¼š</p>
<ol>
<li>ä»å‘½ä»¤è¡Œå’Œç¯å¢ƒå˜é‡è§£æå…¥å‚ (# flags.go)</li>
<li>å°è¯•ä¸ Kubernetes API Server å»ºç«‹è¿æ¥ (# func createApiserverClient)</li>
<li>ä¸ Kong Admin API é€šä¿¡ (# func kong.NewClient)</li>
<li>åˆ›å»ºç›‘å¬èµ„æºå˜åŒ–çš„ Informer</li>
<li>åˆ›å»ºèµ„æºé”ç«äº‰é€‰ä¸¾ Leader (# election.go)</li>
<li>é˜Ÿåˆ—å®šæ—¶æ‰§è¡ŒåŒæ­¥å‡½æ•°</li>
</ol>
<p>ä¸‹é¢ä¼šå¯¹å…¶ä¸­å…³é”®æ­¥éª¤è¿›è¡Œè§£æã€‚</p>
<h3 id=1-ç›®å½•ç»“æ„>1. ç›®å½•ç»“æ„</h3>
<pre><code>â”œâ”€â”€â”€cli
â”‚   â””â”€â”€â”€ingress-controller
â”‚           flags.go                 // å‚æ•°è§£æ
â”‚           main.go
â”‚           util.go
â”‚           version.go
â”œâ”€â”€â”€internal
â”‚   â”œâ”€â”€â”€admission                   // Validation Admission Webhook ç›¸å…³
â”‚   â”‚
â”‚   â””â”€â”€â”€ingress
â”‚       â”œâ”€â”€â”€annotations
â”‚       â”‚       annotations.go      // è§£ææ³¨è§£
â”‚       â”‚       annotations_test.go
â”‚       â”‚
â”‚       â”œâ”€â”€â”€controller
â”‚       â”‚   â”‚   controller.go
â”‚       â”‚   â”‚   event_handler.go    // ResourceEventHandler
â”‚       â”‚   â”‚   kong.go             // Kong ç›¸å…³å‡½æ•°
â”‚       â”‚   â”‚
â”‚       â”‚   â””â”€â”€â”€parser
â”‚       â”‚           parser.go       // Store è½¬æ¢ä¸º Kong Store å‡½æ•°
â”‚       â”‚
â”‚       â”œâ”€â”€â”€election
â”‚       â”‚       election.go         // é€‰ä¸¾
â”‚       â”‚
â”‚       â”œâ”€â”€â”€store
â”‚       â”‚       store.go            // å°è£… Store
â”‚       â”‚
â”‚       â”œâ”€â”€â”€task
â”‚       â”‚       queue.go            // å°è£…é˜Ÿåˆ—
â”‚       â”‚
â”‚       â””â”€â”€â”€utils               // å·¥å…·ç±»
â”‚               k8s.go
â”‚               reports.go      // åŒ¿åä¸ŠæŠ¥
â”‚               types.go
â”‚
â””â”€â”€â”€pkg
    â”œâ”€â”€â”€apis
    â”‚   â””â”€â”€â”€configuration // åºåˆ—åŒ– JSON ç»“æ„å®šä¹‰
    â”‚
    â””â”€â”€â”€client
        â””â”€â”€â”€configuration // CRD Model å®šä¹‰

</code></pre>
<h3 id=2-æ ¸å¿ƒä»£ç å—>2. æ ¸å¿ƒä»£ç å—</h3>
<h4 id=21-åˆ›å»º-informer>2.1 åˆ›å»º Informer</h4>
<ul>
<li>k8s åŸç”Ÿèµ„æºé€šè¿‡ client-go åŒ…æä¾›çš„ Informer ç›‘å¬å˜åŒ–ï¼›</li>
<li>CRD èµ„æºé€šè¿‡å°è£…åœ¨ pkg ç›®å½•ä¸‹å°è£…çš„ Informer ç›‘å¬å˜åŒ–ã€‚</li>
</ul>
<pre><code class=language-go>    // k8s åŸç”Ÿèµ„æº Informer
    coreInformerFactory := informers.NewSharedInformerFactoryWithOptions(
        kubeClient,
        cliConfig.SyncPeriod, //æ—¶é—´é—´éš”
        informers.WithNamespace(cliConfig.WatchNamespace),
    )
    // CRD è‡ªå®šä¹‰èµ„æº Informer
    kongInformerFactory := configinformer.NewSharedInformerFactoryWithOptions(
        confClient,
        cliConfig.SyncPeriod,
        configinformer.WithNamespace(cliConfig.WatchNamespace),
    )
    ...
    // Informer è¢«æ·»åŠ å›è°ƒå‡½æ•°å¤„ç† Event 
    ingInformer.AddEventHandler(reh)

	stopCh := make(chan struct{})
	for _, informer := range informers {
        // åç¨‹æ‰§è¡Œ Informer
		go informer.Run(stopCh)
		synced = append(synced, informer.HasSynced)
	}
</code></pre>
<p><code>SyncPeriod</code> æœ€å°é™åˆ¶ä¸º 10 ç§’ï¼Œé»˜è®¤ç›‘å¬æ‰€æœ‰ Namespaceã€‚</p>
<p>ä¸‹é¢æ¥çœ‹ Informer è¿”å›çš„ Event å¤„ç†éƒ¨åˆ†ï¼š</p>
<pre><code class=language-go>	// åˆ›å»ºæ¥æ”¶ Event çš„é€šé“
	updateChannel := channels.NewRingChannel(1024)
    // Informer å›è°ƒ Handler
	reh := controller.ResourceEventHandler{
		UpdateCh:           updateChannel,
		IsValidIngresClass: annotations.IngressClassValidatorFunc(cliConfig.IngressClass),
        // æ ¹æ® ingress-class æ³¨è§£è¿‡æ»¤èµ„æºå¯¹è±¡
	}

...
    // ä¸»è¿›ç¨‹ä¸­æ¥æ”¶é€šé“ä¿¡å·ï¼Œå¹¶å‹å…¥é˜Ÿåˆ—å®šæ—¶å¤„ç†
	for {
		select {
		case event := &lt;-n.updateCh.Out():
			if v := atomic.LoadUint32(&amp;n.isShuttingDown); v != 0 {
				return
			}
			if evt, ok := event.(Event); ok {
				glog.V(3).Infof(&quot;Event %v received - object %v&quot;, evt.Type, evt.Obj)
                // åŠ å…¥å®šæ—¶æ‰§è¡ŒåŒæ­¥å‡½æ•°çš„é˜Ÿåˆ—
				n.syncQueue.Enqueue(evt.Obj)
				// TODO retry for ephermal error conditions
				// This function is called outside the task queue because event
				// information is currently shielded from the sync function.
				// Sync function syncs everything, no matter what the event is
				err := n.handleBasicAuthUpdates(evt)
				if err != nil {
					glog.Errorf(&quot;error handling basic-auth update: %v&quot;, err)
				}
			} else {
				glog.Warningf(&quot;unexpected event type received: %T&quot;, event)
			}
		case &lt;-n.stopCh:
			return
		}
	}
</code></pre>
<h4 id=22-åˆ›å»ºèµ„æºé”ç«äº‰é€‰ä¸¾>2.2 åˆ›å»ºèµ„æºé”ç«äº‰é€‰ä¸¾</h4>
<p>Controller å¯ä»¥éƒ¨ç½²åˆ†å¸ƒå¼å¤šå®ä¾‹ï¼Œä¸ºäº†é¿å…é‡å¤å¯¹ Admin API è¿›è¡Œæ“ä½œï¼Œå¯¼è‡´æ··ä¹±ï¼Œç¨‹åºåœ¨å¯åŠ¨é˜¶æ®µé€šè¿‡ k8s ConfigMap èµ„æºé”è¿›è¡Œé€‰ä¸¾ Leaderã€‚</p>
<p>é€‰ä¸¾æœ‰ä»¥ä¸‹æ­¥éª¤ï¼š</p>
<ul>
<li>åˆ›å»º ConfigMapLockï¼ŒåŸºäº etcd å¹‚ç­‰æ€§åªæœ‰ä¸€ä¸ªç¨‹åºè·å¾—èµ„æº</li>
<li>æŠ¢åˆ°é”çš„å®ä¾‹å®šæ—¶ renew ç»­æœŸ</li>
<li>å…¶ä»–å®ä¾‹æ ¹æ®æœ€åç»­æœŸæ—¶é—´åˆ¤æ–­é”æ˜¯å¦æœ‰æ•ˆï¼Œå¦åˆ™ç«äº‰åˆ›å»ºé”</li>
</ul>
<pre><code class=language-go>// NewElector returns an instance of Elector based on config.
func NewElector(config Config) Elector {
	pod, err := utils.GetPodDetails(config.Client)
	if err != nil {
		glog.Fatalf(&quot;unexpected error obtaining pod information: %v&quot;, err)
	}

	es := elector{
		Config: config,
	}

	broadcaster := record.NewBroadcaster()
	hostname, _ := os.Hostname()

	recorder := broadcaster.NewRecorder(scheme.Scheme, apiv1.EventSource{
		Component: &quot;ingress-leader-elector&quot;,
		Host:      hostname,
	})

    // å®šä¹‰ ConfigMapLock èµ„æºé”ç»“æ„
	lock := resourcelock.ConfigMapLock{
		ConfigMapMeta: metav1.ObjectMeta{Namespace: pod.Namespace,
			Name: config.ElectionID},
		Client: config.Client.CoreV1(),
		LockConfig: resourcelock.ResourceLockConfig{
			Identity:      pod.Name,
			EventRecorder: recorder,
		},
	}

	ttl := 30 * time.Second
    
    // è°ƒç”¨ client-go leaderelection åŒ…è¿›è¡Œé€‰ä¸¾
	le, err := leaderelection.NewLeaderElector(
		leaderelection.LeaderElectionConfig{
			Lock:            &amp;lock,
			LeaseDuration:   ttl,      // é”æœ‰æ•ˆæ—¶é—´
			RenewDeadline:   ttl / 2,  // ç»­æœŸé—´éš”
			RetryPeriod:     ttl / 4,
			Callbacks:       config.Callbacks,
			ReleaseOnCancel: true,
		})

	if err != nil {
		glog.Fatalf(&quot;unexpected error starting leader election: %v&quot;, err)
	}

    // å‚¨å­˜é€‰ä¸¾ä¿¡æ¯
	es.elector = le
	return es
}

...

    // åœ¨æ‰§è¡ŒåŒæ­¥å‡½æ•°å¼€å§‹æ—¶åˆ¤æ–­ï¼Œé Leader ç›´æ¥é€€å‡º
	// If in-memory mode, each Kong instance runs with its own controller
	if !n.cfg.Kong.InMemory &amp;&amp;
		!n.elector.IsLeader() {
		glog.V(2).Infof(&quot;skipping synchronization of configuration because I am not the leader.&quot;)
		return nil
	}
</code></pre>
<h4 id=23-é˜Ÿåˆ—æ‰§è¡ŒåŒæ­¥å‡½æ•°>2.3 é˜Ÿåˆ—æ‰§è¡ŒåŒæ­¥å‡½æ•°</h4>
<h5 id=231-åˆ›å»ºé˜Ÿåˆ—>2.3.1 åˆ›å»ºé˜Ÿåˆ—</h5>
<p>queue.go æ–‡ä»¶é‡Œå®šä¹‰äº†é˜Ÿåˆ—ç»“æ„ä½“å’Œè¿è¡Œå‡½æ•°ï¼Œå†…éƒ¨ä½¿ç”¨ client-go workqueue åŒ…ï¼Œé˜Ÿåˆ—é…ç½®æœ‰ RateLimitï¼Œé¿å…é¢‘ç¹å¯¹ Admin API è¿›è¡Œæ“ä½œã€‚</p>
<p>æ¥çœ‹ä¸€ä¸‹ Queue ç»“æ„ä½“å®šä¹‰ã€‚</p>
<pre><code class=language-go>type Queue struct {
    // k8s.io/client-go/util/workqueue åº“
	// queue is the work queue the worker polls
	queue workqueue.RateLimitingInterface
	// sync is called for each item in the queue
	sync func(interface{}) error
	// workerDone is closed when the worker exits
	workerDone chan bool

    // queue å…ƒç´  Key ç”Ÿæˆå‡½æ•°
	fn func(obj interface{}) (interface{}, error)

	lastSync int64
}

// queue ä¸­åŒ…å«çš„ç»“æ„ä½“
// Element represents one item of the queue
type Element struct {
	Key       interface{}
	Timestamp int64
}
</code></pre>
<p><code>fn()</code> ä½¿ç”¨ <code>DeletionHandlingMetaNamespaceKeyFunc</code> å‡½æ•°ç”Ÿæˆ API èµ„æºçš„ Keyï¼Œè¯¥å‡½æ•°ä¼šè¿”å›åˆ é™¤èµ„æºçš„ Key æˆ– namespace/name æ ¼å¼çš„ Keyã€‚</p>
<p>å…³æ³¨é˜Ÿåˆ—æ¶ˆè´¹çš„æ–¹æ³•ï¼š</p>
<pre><code class=language-go>// worker processes work in the queue through sync.
func (t *Queue) worker() {
   for {
      key, quit := t.queue.Get()
      if quit {
         if !isClosed(t.workerDone) {
            close(t.workerDone)
         }
         return
      }
      ts := time.Now().UnixNano()

      // åˆ¤æ–­é˜Ÿåˆ—å†…äº‹ä»¶æ˜¯å¦æœ‰æ•ˆ
      item := key.(Element)
      if t.lastSync &gt; item.Timestamp {
         glog.V(3).Infof(&quot;skipping %v sync (%v &gt; %v)&quot;, item.Key, t.lastSync, item.Timestamp)
         t.queue.Forget(key)
         t.queue.Done(key)
         continue
      }

      glog.V(3).Infof(&quot;syncing %v&quot;, item.Key)
      // å¯¹æ¯ä¸ªé˜Ÿåˆ—å†…å…ƒç´ æ‰§è¡Œ sync å‡½æ•°
      if err := t.sync(key); err != nil {
         glog.Warningf(&quot;requeuing %v, err %v&quot;, item.Key, err)
         // æ‰§è¡Œé”™è¯¯ï¼Œé™é€Ÿ
         t.queue.AddRateLimited(Element{
            Key:       item.Key,
            Timestamp: time.Now().UnixNano(),
         })
      } else {
         // æ‰§è¡ŒæˆåŠŸ
         t.queue.Forget(key)
         t.lastSync = ts
      }

      t.queue.Done(key)
   }
}
</code></pre>
<h5 id=232-è§£æèµ„æº>2.3.2 è§£æèµ„æº</h5>
<p><code>parser.go</code> ä¸­ <code>Build()</code> æ–¹æ³•è§£æ k8s å†…èµ„æºåˆ°è‡ªå®šä¹‰èµ„æºæ ¼å¼ï¼Œä¸»è¦èŒè´£ä¸ºæ ¼å¼è½¬æ¢å’Œå°†å¤šä¸ªæ•°æ®æºçš„æ•°æ®è¿›è¡Œç»„åˆï¼Œç”ŸæˆæœŸæœ›çš„æ•°æ®æ ¼å¼ã€‚</p>
<pre><code class=language-go>// Build creates a Kong configuration from Ingress and Custom resources
// defined in Kuberentes.
// It throws an error if there is an error returned from client-go.
func (p *Parser) Build() (*KongState, error) {
	var state KongState
	ings := p.store.ListIngresses()
	tcpIngresses, err := p.store.ListTCPIngresses()
	if err != nil {
		glog.Errorf(&quot;error listing TCPIngresses: %v&quot;, err)
	}
	// è§£æã€åˆå¹¶ Ingressã€å’Œè‡ªå®šä¹‰ TCPIngress èµ„æº
    // ç”Ÿæˆ Service å’Œ Route
	parsedInfo := p.parseIngressRules(ings, tcpIngresses)

    // å…³è” k8s Service èµ„æº
    // populate Kubernetes Service
	for key, service := range parsedInfo.ServiceNameToServices {
        // é€šè¿‡ client-go Storer è·å– Service
		k8sSvc, err := p.store.GetService(service.Namespace, service.Backend.Name)
		if err != nil {
			glog.Errorf(&quot;getting service: %v&quot;, err)
		}
		if k8sSvc != nil {
            // è·å–åˆ° Service åˆ™å…³è”
			service.K8sService = *k8sSvc
		}
		parsedInfo.ServiceNameToServices[key] = service
	}
    
	// add the routes and services to the state
	for _, service := range parsedInfo.ServiceNameToServices {
		state.Services = append(state.Services, service)
	}

	// ç”Ÿæˆ Upstream å’Œ Target
	state.Upstreams = p.getUpstreams(parsedInfo.ServiceNameToServices)

    // ç”Ÿæˆå…¶ä»–èµ„æº
	// generate consumers and credentials
	p.fillConsumersAndCredentials(&amp;state)

	// process annotation plugins
	state.Plugins = p.fillPlugins(state)

	// generate Certificates and SNIs
	state.Certificates = p.getCerts(parsedInfo.SecretNameToSNIs)

	// populate CA certificates in Kong
	state.CACertificates, err = p.getCACerts()
	if err != nil {
		return nil, err
	}

	return &amp;state, nil
}
</code></pre>
<h6 id=2321-èµ„æºç»“æ„å®šä¹‰>2.3.2.1 èµ„æºç»“æ„å®šä¹‰</h6>
<p>Controller å®šä¹‰äº†ä¸€äº›ç»“æ„ä½“å‚¨å­˜ k8s èµ„æºå’Œ Kong å¯¹åº”çš„èµ„æºã€‚</p>
<pre><code class=language-go>// KongState holds the configuration that should be applied to Kong.
type KongState struct {
   Services       []Service
   Upstreams      []Upstream
   Certificates   []Certificate
   CACertificates []kong.CACertificate
   Plugins        []Plugin
   Consumers      []Consumer
}

// Service represents a service in Kong and holds routes associated with the
// service and other k8s metadata.
type Service struct {
	kong.Service
	Backend    backend
	Namespace  string
	Routes     []Route
	Plugins    []kong.Plugin
	K8sService corev1.Service
}

// Route represents a Kong Route and holds a reference to the Ingress
// rule.
type Route struct {
	kong.Route

	// Ingress object associated with this route
	Ingress networking.Ingress
	// TCPIngress object associated with this route
	TCPIngress configurationv1beta1.TCPIngress
	// Is this route coming from TCPIngress or networking.Ingress?
	IsTCP   bool
	Plugins []kong.Plugin
}
...
</code></pre>
<p>ç»“æ„ä½“åŒ…å«äº† k8s è‡ªèº«èµ„æºçš„ä¿¡æ¯ï¼Œå’Œè§£æåˆ° Kong èµ„æºæ ¼å¼çš„å¯¹åº”ä¿¡æ¯ã€‚</p>
<h6 id=2322-è§£æ-ingress>2.3.2.2 è§£æ Ingress</h6>
<p>è¯¥æ–¹æ³•çš„èŒèƒ½ä¸ºæ’åºå»é‡ Ingress è§„åˆ™ï¼Œåˆå¹¶ TCPIngress è§„åˆ™ï¼Œåˆ›å»º</p>
<pre><code class=language-go>func (p *Parser) parseIngressRules(
   // k8s Ingress èµ„æº
   ingressList []*networking.Ingress,
   // è‡ªå®šä¹‰ TCPIngress èµ„æº
   tcpIngressList []*configurationv1beta1.TCPIngress) *parsedIngressRules {

   // æŒ‰ç…§æ—¶é—´æ’åº
   sort.SliceStable(ingressList, func(i, j int) bool {
      return ingressList[i].CreationTimestamp.Before(
         &amp;ingressList[j].CreationTimestamp)
   })

   sort.SliceStable(tcpIngressList, func(i, j int) bool {
      return tcpIngressList[i].CreationTimestamp.Before(
         &amp;tcpIngressList[j].CreationTimestamp)
   })

   // generate the following:
   // Services and Routes
   var allDefaultBackends []networking.Ingress
   secretNameToSNIs := make(map[string][]string)
   serviceNameToServices := make(map[string]Service)

   for i := 0; i &lt; len(ingressList); i++ {
      ingress := *ingressList[i]
      ingressSpec := ingress.Spec

      if ingressSpec.Backend != nil {
         allDefaultBackends = append(allDefaultBackends, ingress)

      }

      processTLSSections(ingressSpec.TLS, ingress.Namespace, secretNameToSNIs)

      for i, rule := range ingressSpec.Rules {
         host := rule.Host
         if rule.HTTP == nil {
            continue
         }
         for j, rule := range rule.HTTP.Paths {
            path := rule.Path

            if strings.Contains(path, &quot;//&quot;) {
               glog.Errorf(&quot;ingress rule skipped in Ingress'%v/%v', &quot;+
                  &quot;'%v' is an invalid path&quot;, ingress.Namespace,
                  ingress.Name, path)
               continue
            }
            if path == &quot;&quot; {
               path = &quot;/&quot;
            }
            
            // åˆ›å»º Route ç»“æ„ä½“
            r := Route{
               Ingress: ingress,
               Route: kong.Route{
                  // TODO Figure out a way to name the routes
                  // This is not a stable scheme
                  // 1. If a user adds a route in the middle,
                  // due to a shift, all the following routes will
                  // be PATCHED
                  // 2. Is it guaranteed that the order is stable?
                  // Meaning, the routes will always appear in the same
                  // order?
                  Name:          kong.String(ingress.Namespace + &quot;.&quot; + ingress.Name + &quot;.&quot; + strconv.Itoa(i) + strconv.Itoa(j)),
                  Paths:         kong.StringSlice(path),
                  StripPath:     kong.Bool(false),
                  PreserveHost:  kong.Bool(true),
                  Protocols:     kong.StringSlice(&quot;http&quot;, &quot;https&quot;),
                  RegexPriority: kong.Int(0),
               },
            }
            if host != &quot;&quot; {
               // Route åŸŸååœ°å€
               r.Hosts = kong.StringSlice(host)
            }

            // åˆ›å»º Service ç»“æ„ä½“
            serviceName := ingress.Namespace + &quot;.&quot; +
               rule.Backend.ServiceName + &quot;.&quot; +
               rule.Backend.ServicePort.String()
            service, ok := serviceNameToServices[serviceName]
            if !ok {
               service = Service{
                  // Kong çš„ Service å¯¹è±¡
                  Service: kong.Service{
                     Name: kong.String(serviceName),
                     // Upstream åœ°å€ï¼Œåç»­åˆ›å»º Upstream ä½¿ç”¨ç›¸åŒåœ°å€
                     Host: kong.String(rule.Backend.ServiceName +
                        &quot;.&quot; + ingress.Namespace + &quot;.&quot; +
                        rule.Backend.ServicePort.String() + &quot;.svc&quot;),
                     Port:           kong.Int(80),
                     Protocol:       kong.String(&quot;http&quot;),
                     Path:           kong.String(&quot;/&quot;),
                     ConnectTimeout: kong.Int(60000),
                     ReadTimeout:    kong.Int(60000),
                     WriteTimeout:   kong.Int(60000),
                     Retries:        kong.Int(5),
                  },
                  Namespace: ingress.Namespace,
                  Backend: backend{
                     Name: rule.Backend.ServiceName,
                     Port: rule.Backend.ServicePort,
                  },
               }
            }
            // å…³è” Service ä¸ Route
            service.Routes = append(service.Routes, r)
            serviceNameToServices[serviceName] = service
         }
      }
   }

   return &amp;parsedIngressRules{
      SecretNameToSNIs:      secretNameToSNIs,
      ServiceNameToServices: serviceNameToServices,
   }
}
</code></pre>
<h6 id=2323-è§£æ-endpoints>2.3.2.3 <strong>è§£æ Endpoints</strong></h6>
<p>ç”Ÿæˆ Upstream ç»“æ„ä½“ï¼š</p>
<pre><code class=language-go>func (p *Parser) getUpstreams(serviceMap map[string]Service) []Upstream {
	var upstreams []Upstream
	for _, service := range serviceMap {
        // è¿™é‡Œçš„ Upstream åç§°ä¸ Service é‡Œçš„ Host åœ°å€ä¸€è‡´
		upstreamName := service.Backend.Name + &quot;.&quot; + service.Namespace + &quot;.&quot; + service.Backend.Port.String() + &quot;.svc&quot;
		upstream := Upstream{
			Upstream: kong.Upstream{
				Name: kong.String(upstreamName),
			},
			Service: service,
		}
        // è·å– Targets
		targets := p.getServiceEndpoints(service.K8sService,
			service.Backend.Port.String())
		upstream.Targets = targets
		upstreams = append(upstreams, upstream)
	}
	return upstreams
}
</code></pre>
<p>è·å– Endpoint ç”Ÿæˆ Target ç»“æ„ä½“ï¼š</p>
<pre><code class=language-go>// æ¥æ”¶ k8s Service å’Œ Ingress.Backend.ServicePort å‚æ•°
func (p *Parser) getServiceEndpoints(svc corev1.Service,
   backendPort string) []Target {
   var targets []Target
   var endpoints []utils.Endpoint
   var servicePort corev1.ServicePort
   svcKey := svc.Namespace + &quot;/&quot; + svc.Name

   for _, port := range svc.Spec.Ports {
      // æŸ¥æ‰¾ Ingress.Backend.ServicePort å’Œ Service.Port å¯¹åº”çš„éƒ¨åˆ†
      // è·å– Port èµ„æºå¯¹è±¡
      // targetPort could be a string, use the name or the port (int)
      if strconv.Itoa(int(port.Port)) == backendPort ||
         port.TargetPort.String() == backendPort ||
         port.Name == backendPort {
         servicePort = port
         break
      }
   }

   // Ingress with an ExternalName service and no port defined in the service.
   if len(svc.Spec.Ports) == 0 &amp;&amp;
      svc.Spec.Type == corev1.ServiceTypeExternalName {
      // nolint: gosec
      externalPort, err := strconv.Atoi(backendPort)
      if err != nil {
         glog.Warningf(&quot;only numeric ports are allowed in&quot;+
            &quot; ExternalName services: %v is not valid as a TCP/UDP port&quot;,
            backendPort)
         return targets
      }

      servicePort = corev1.ServicePort{
         Protocol:   &quot;TCP&quot;,
         Port:       int32(externalPort),
         TargetPort: intstr.FromString(backendPort),
      }
   }

   // è·å– Endpoint
   endpoints = getEndpoints(&amp;svc, &amp;servicePort,
      corev1.ProtocolTCP, p.store.GetEndpointsForService)
   if len(endpoints) == 0 {
      glog.Warningf(&quot;service %v does not have any active endpoints&quot;,
         svcKey)
   }
   for _, endpoint := range endpoints {
      target := Target{
         Target: kong.Target{
            Target: kong.String(endpoint.Address + &quot;:&quot; + endpoint.Port),
         },
      }
      targets = append(targets, target)
   }
   return targets
}
</code></pre>
<p><code>p.store.GetEndpointsForService()</code> æ–¹æ³•æ˜¯ Storer è·å– Endpoint çš„æ–¹æ³•ï¼ŒEndpoints ç»“æ„ä½“ï¼š</p>
<pre><code class=language-go>// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Endpoints is a collection of endpoints that implement the actual service. Example:
//   Name: &quot;mysvc&quot;,
//   Subsets: [
//     {
//       Addresses: [{&quot;ip&quot;: &quot;10.10.1.1&quot;}, {&quot;ip&quot;: &quot;10.10.2.2&quot;}],
//       Ports: [{&quot;name&quot;: &quot;a&quot;, &quot;port&quot;: 8675}, {&quot;name&quot;: &quot;b&quot;, &quot;port&quot;: 309}]
//     },
//     {
//       Addresses: [{&quot;ip&quot;: &quot;10.10.3.3&quot;}],
//       Ports: [{&quot;name&quot;: &quot;a&quot;, &quot;port&quot;: 93}, {&quot;name&quot;: &quot;b&quot;, &quot;port&quot;: 76}]
//     },
//  ]
type Endpoints struct {
   metav1.TypeMeta `json:&quot;,inline&quot;`
   // Standard object's metadata.
   // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   // +optional
   metav1.ObjectMeta `json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`

   // The set of all endpoints is the union of all subsets. Addresses are placed into
   // subsets according to the IPs they share. A single address with multiple ports,
   // some of which are ready and some of which are not (because they come from
   // different containers) will result in the address being displayed in different
   // subsets for the different ports. No address will appear in both Addresses and
   // NotReadyAddresses in the same subset.
   // Sets of addresses and ports that comprise a service.
   // +optional
   Subsets []EndpointSubset `json:&quot;subsets,omitempty&quot; protobuf:&quot;bytes,2,rep,name=subsets&quot;`
}
</code></pre>
<p>ç»§ç»­çœ‹è·å– Endpoint çš„æ–¹æ³•ï¼š</p>
<pre><code class=language-go>// getEndpoints returns a list of &lt;endpoint ip&gt;:&lt;port&gt; for a given service/target port combination.
func getEndpoints(
   s *corev1.Service,
   port *corev1.ServicePort,
   proto corev1.Protocol,
   getEndpoints func(string, string) (*corev1.Endpoints, error),
) []utils.Endpoint {

   upsServers := []utils.Endpoint{}

   if s == nil || port == nil {
      return upsServers
   }

   // avoid duplicated upstream servers when the service
   // contains multiple port definitions sharing the same
   // targetport.
   adus := make(map[string]bool)

   // å¤–éƒ¨æœåŠ¡
   // ExternalName services
   if s.Spec.Type == corev1.ServiceTypeExternalName {
      glog.V(3).Infof(&quot;Ingress using a service %v of type=ExternalName&quot;, s.Name)

      targetPort := port.TargetPort.IntValue()
      // check for invalid port value
      if targetPort &lt;= 0 {
         glog.Errorf(&quot;ExternalName service with an invalid port: %v&quot;, targetPort)
         return upsServers
      }

      return append(upsServers, utils.Endpoint{
         Address: s.Spec.ExternalName,
         Port:    fmt.Sprintf(&quot;%v&quot;, targetPort),
      })
   }
    
   // è§£æ Service çš„ ingress.kubernetes.io/service-upstream æ³¨è§£
   // ä¸º &quot;true&quot; åˆ™äº¤ç»™ Kube-proxy æ‰§è¡Œåç»­è´Ÿè½½å‡è¡¡æ“ä½œ
   if annotations.HasServiceUpstreamAnnotation(s.Annotations) {
      return append(upsServers, utils.Endpoint{
         Address: s.Name + &quot;.&quot; + s.Namespace + &quot;.svc&quot;,
         Port:    fmt.Sprintf(&quot;%v&quot;, port.Port),
      })

   }

   glog.V(3).Infof(&quot;getting endpoints for service %v/%v and port %v&quot;, s.Namespace, s.Name, port.String())
   // è°ƒç”¨ client-go Storer è·å– Service çš„ Endpoints
   ep, err := getEndpoints(s.Namespace, s.Name)
   if err != nil {
      glog.Warningf(&quot;unexpected error obtaining service endpoints: %v&quot;, err)
      return upsServers
   }

   for _, ss := range ep.Subsets {
      for _, epPort := range ss.Ports {

         // ä¸æ˜¯ TCP åè®®çš„ pass
         if !reflect.DeepEqual(epPort.Protocol, proto) {
            continue
         }

         var targetPort int32

         if port.Name == &quot;&quot; {
            // port.Name is optional if there is only one port
            targetPort = epPort.Port
         } else if port.Name == epPort.Name {
            targetPort = epPort.Port
         }

         // check for invalid port value
         if targetPort &lt;= 0 {
            continue
         }

         for _, epAddress := range ss.Addresses {
            ep := fmt.Sprintf(&quot;%v:%v&quot;, epAddress.IP, targetPort)
            // å¦‚æœæœ‰å¤šä¸ª Port å¯¹åº”åŒä¸€ä¸ª targetPort,
            // åˆ™è·³è¿‡ï¼Œä¸é‡å¤åˆ›å»º
            if _, exists := adus[ep]; exists {
               continue
            }
            ups := utils.Endpoint{
               Address: epAddress.IP,
               Port:    fmt.Sprintf(&quot;%v&quot;, targetPort),
            }
            upsServers = append(upsServers, ups)
            adus[ep] = true
         }
      }
   }

   glog.V(3).Infof(&quot;endpoints found: %v&quot;, upsServers)
   return upsServers
}
</code></pre>
<h5 id=233-åŒæ­¥èµ„æº>2.3.3 åŒæ­¥èµ„æº</h5>
<p><code>syncIngress()</code> æ–¹æ³•ä¸­åœ¨è§£æå®Œèµ„æºï¼Œç”Ÿæˆ Kong éœ€è¦çš„æ•°æ®ç»“æ„åï¼Œè°ƒç”¨ <code>n.OnUpdate(state)</code> æ–¹æ³• Diffã€Sync åˆ° Kongã€‚</p>
<pre><code class=language-go>// æ¥æ”¶ç”Ÿæˆå¥½çš„ Kong æ•°æ®åº“ç»“æ„ä½“ï¼Œä½œä¸ºå‚æ•°
// OnUpdate is called periodically by syncQueue to keep the configuration in sync.
// returning nil implies the synchronization finished correctly.
// Returning an error means requeue the update.
func (n *KongController) OnUpdate(state *parser.KongState) error {
	// è°ƒç”¨ decK åº“è¿›è¡Œå¤„ç†
    targetContent := n.toDeckContent(state)

	var customEntities []byte
	var err error

	var shaSum []byte
	// disable optimization if reverse sync is enabled
	if !n.cfg.EnableReverseSync {
        // ç”Ÿæˆ Hash åˆ¤æ–­æœ¬æ¬¡æ•°æ®ç»“æ„ä½“å’Œä¸Šæ¬¡æ‰§è¡Œæ˜¯å¦ä¸€è‡´,
        // ä¸€è‡´åˆ™ä¸è¿›è¡Œæ›´æ–°
		shaSum, err = generateSHA(targetContent, customEntities)
		if err != nil {
			return err
		}
		if reflect.DeepEqual(n.runningConfigHash, shaSum) {
			glog.Info(&quot;no configuration change, skipping sync to Kong&quot;)
			return nil
		}
	}
    
    // è°ƒç”¨ DB æ›´æ–°å‡½æ•°
	err = n.onUpdateDBMode(targetContent)
	if err != nil {
		return err
	}
    // è®°å½•æœ¬æ¬¡æ“ä½œçš„æ•°æ®ç»“æ„ä½“ Hash
	n.runningConfigHash = shaSum
	glog.Info(&quot;successfully synced configuration to Kong&quot;)
	return nil
}
</code></pre>
<p>è¿™é‡Œå¼•å…¥äº† <a href=Kong/decK>Kong/decK</a> åº“å¤„ç† Kong é…ç½®çš„åŒæ­¥ï¼Œè¯¥åº“ä½¿ç”¨ Go ç¼–å†™ï¼Œæä¾›äº†é’ˆå¯¹ Kong é…ç½®çš„ç®¡ç†èƒ½åŠ›ï¼Œèƒ½å¤Ÿå¯¼å‡º Kong æ•°æ®åº“é…ç½®åˆ°æ–‡ä»¶ï¼Œä¹Ÿèƒ½ä»æ–‡ä»¶å¯¼å…¥åˆ° Kongï¼Œæä¾› Diff å’Œ Sync ç­‰æ–¹æ³•ï¼Œå†…éƒ¨ä½¿ç”¨å¤šåç¨‹ï¼Œç®—æ³•ä¼˜åŒ–æå‡æ‰§è¡Œé€Ÿåº¦ã€‚èƒ½å¤Ÿå•ç‹¬é€šè¿‡ CLI ä½¿ç”¨ï¼Œè¿™é‡Œè°ƒç”¨è¯¥åº“çš„ Diff å’Œ Sync æ–¹æ³•åŒæ­¥é…ç½®åˆ° Kongã€‚</p>
<p><code>n.toDeckContent(state)</code> æ–¹æ³•å°† KongState ç»“æ„è½¬æ¢ä¸º decK åº“ä½¿ç”¨çš„æ•°æ®ç»“æ„ï¼ˆä¸€ä¸ªæ–‡ä»¶åºåˆ—åŒ–ç»“æ„ä½“ï¼‰ã€‚</p>
<pre><code class=language-go>// Content represents a serialized Kong state.
type Content struct {
   FormatVersion string `json:&quot;_format_version,omitempty&quot; yaml:&quot;_format_version,omitempty&quot;`
   Info          *Info  `json:&quot;_info,omitempty&quot; yaml:&quot;_info,omitempty&quot;`
   Workspace     string `json:&quot;_workspace,omitempty&quot; yaml:&quot;_workspace,omitempty&quot;`

   Services       []FService       `json:&quot;services,omitempty&quot; yaml:&quot;,omitempty&quot;`
   Routes         []FRoute         `json:&quot;routes,omitempty&quot; yaml:&quot;,omitempty&quot;`
   Consumers      []FConsumer      `json:&quot;consumers,omitempty&quot; yaml:&quot;,omitempty&quot;`
   Plugins        []FPlugin        `json:&quot;plugins,omitempty&quot; yaml:&quot;,omitempty&quot;`
   Upstreams      []FUpstream      `json:&quot;upstreams,omitempty&quot; yaml:&quot;,omitempty&quot;`
   Certificates   []FCertificate   `json:&quot;certificates,omitempty&quot; yaml:&quot;,omitempty&quot;`
   CACertificates []FCACertificate `json:&quot;ca_certificates,omitempty&quot; yaml:&quot;ca_certificates,omitempty&quot;`

   PluginConfigs map[string]kong.Configuration `json:&quot;_plugin_configs,omitempty&quot; yaml:&quot;_plugin_configs,omitempty&quot;`
}
</code></pre>
<p>ç»§ç»­å…³æ³¨è°ƒç”¨ Diffã€Sync çš„æ–¹æ³•ï¼š</p>
<pre><code class=language-go>func (n *KongController) onUpdateDBMode(targetContent *file.Content) error {
	client := n.cfg.Kong.Client

    // è°ƒç”¨ Admin API ç­›é€‰ managed-by-conroller tag ä¸‹çš„
    // æ‰€æœ‰èµ„æºï¼Œåˆ° State
	// Get queries all the entities using client and returns
	// all the entities in KongRawState.
	rawState, err := dump.Get(client, dump.Config{
		SelectorTags: n.getIngressControllerTags(),
	})
	if err != nil {
		return errors.Wrap(err, &quot;loading configuration from kong&quot;)
	}
    // Get builds a KongState from a raw representation of Kong.
	currentState, err := state.Get(rawState)
	if err != nil {
		return err
	}

	// Get process the fileContent and renders a RawState.
	// IDs of entities are matches based on currentState.
	rawState, err = file.Get(targetContent, file.RenderConfig{
		CurrentState: currentState,
		KongVersion:  n.cfg.Kong.Version,
	})
	if err != nil {
		return err
	}
    // Get builds a KongState from a raw representation of Kong.
	targetState, err := state.Get(rawState)
	if err != nil {
		return err
	}

    // Diff, Sync
	syncer, err := diff.NewSyncer(currentState, targetState)
	if err != nil {
		return errors.Wrap(err, &quot;creating a new syncer&quot;)
	}
	syncer.SilenceWarnings = true
	//client.SetDebugMode(true)
	_, errs := solver.Solve(nil, syncer, client, n.cfg.Kong.Concurrency, false)
	if errs != nil {
		return deckutils.ErrArray{Errors: errs}
	}
	return nil
}
</code></pre>
<p><code>dump.Get()</code> æ–¹æ³•è°ƒç”¨ Admin API è·å– <code>managed-by-controller</code> tag ä¸‹æ‰€æœ‰çš„èµ„æºï¼ŒåŠ è½½åˆ°å†…å­˜ã€‚</p>
<p>è¯¥æ–¹æ³•è°ƒç”¨ decK ç”Ÿæˆäº† k8s ç¯å¢ƒä¸‹çš„èµ„æºçŠ¶æ€ï¼Œå’Œé€šè¿‡ Admin API æŸ¥è¯¢åˆ°çš„ Kong DB é‡Œçš„èµ„æºçŠ¶æ€ï¼Œæ¥ä¸‹æ¥ä¼šè°ƒç”¨ decK åº“è¿›è¡Œ diff å’Œ syncï¼Œå°†åˆ›å»º Kong DB é‡Œæ²¡æœ‰çš„èµ„æºï¼Œåˆ é™¤ k8s ç¯å¢ƒä¸‹æ²¡æœ‰çš„èµ„æºï¼ŒåŒæ­¥æ›´æ–° Kong çš„èµ„æºã€‚</p>
<h3 id=25-ingress-nginx-åˆ†æ>2.5 ingress-nginx åˆ†æ</h3>
<p><code>ingress-nginx</code> æ˜¯ Kubernetes çš„å®˜æ–¹ Ingress Controller é¡¹ç›®ï¼Œå…¶ Controller éƒ¨ç½²çš„å¯åŠ¨é€»è¾‘ä¸ä¸Šæ–‡æ‰€è¿° Kong çš„ Ingress Controller åŸºæœ¬ä¸€è‡´ï¼Œç”šè‡³åè€…éƒ¨åˆ†ä»£ç æ˜¯ç›´æ¥ä» <code>ingress-nginx</code> Copy è¿‡æ¥çš„ï¼Œä»£ç é‡Œè¿˜æ®‹ç•™ç€ <code>NGINX</code> å­—æ ·ã€‚</p>
<h4 id=251-ssl-proxy-åˆ†æ>2.5.1 SSL Proxy åˆ†æ</h4>
<p><code>ingress-nginx</code> æä¾›äº† SSL Passthrough åŠŸèƒ½ï¼Œä½¿å¾—åŠ å¯†æµé‡ç›´æ¥é€šè¿‡ 443 ç«¯å£ä¼ åˆ°åç«¯æœåŠ¡å™¨ï¼Œè¿™é‡Œå¼•ç”¨ä¸€ç¯‡æ–‡ç« æ¸…æ™°æ˜äº†çš„è§£é‡Šã€‚</p>
<p>
<figure class=image>
<img src=/2021/11/kong-ingress-controller-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/images/kubernetes-ingress-controller-and-ingresses-https.png alt=img{512x368} loading=lazy>
<figcaption>img{512x368}</figcaption>
</figure></p>
<blockquote>
<p>svc7: æ˜¯å¯¹ä¼ ç»Ÿé€šä¿¡æ¨¡å‹çš„â€œå¤ç°â€ï¼Œå³ Client ä¸ Nginx é—´é‡‡ç”¨ HTTPS åŠ å¯†é€šä¿¡ï¼Œä½† Nginx ä¸ svc7 é—´åˆ™æ˜¯æ˜æ–‡çš„ HTTP é€šä¿¡ï¼›</p>
<p>svc8: æ˜¯ ssl-termination çš„å®‰å…¨é…ç½®æ¨¡å‹ï¼Œå³ Client ä¸ svc8 çš„ HTTPS é€šä¿¡åˆ†ä¸ºâ€œä¸¤æ®µâ€ï¼ŒClient ä¸ Nginx å»ºç«‹ HTTPS è¿æ¥åï¼ŒNginx å°† Client æäº¤çš„åŠ å¯†è¯·æ±‚è§£å¯†åï¼Œå†å‘ svc8 å‘èµ· HTTPS è¯·æ±‚ï¼Œå¹¶é‡æ–°åŠ å¯†è¯·æ±‚æ•°æ®ã€‚è¿™ç§ Client ç«¯ SSL çš„è¿‡ç¨‹åœ¨åå‘ä»£ç†æˆ–è´Ÿè½½å‡è¡¡å™¨ç»ˆç»“çš„ HTTPS é€šä¿¡æ–¹å¼è¢«ç§°ä¸ºâ€œssl-terminationâ€ã€‚</p>
<p>svc9: æ˜¯ ssl-passthrough çš„å®‰å…¨é…ç½®æ¨¡å‹ï¼Œå³ Nginx ä¸ä¼šå¯¹ Client çš„ HTTPS Request è¿›è¡Œè§£å¯†ï¼Œè€Œæ˜¯ç›´æ¥è½¬å‘ç»™ backend çš„ svc9 æœåŠ¡ï¼ŒClient ç«¯çš„ SSL è¿‡ç¨‹ä¸ä¼šç»ˆç»“äº Nginxï¼Œè€Œæ˜¯åœ¨ svc9 å¯¹åº”çš„ Pod ä¸­ç»ˆç»“ã€‚è¿™ç§ HTTPS é€šä¿¡æ–¹å¼è¢«ç§°ä¸ºâ€ssl-passthroughâ€ã€‚è¿™ç§é…ç½®æ¨¡å‹å°¤å…¶é€‚åˆ backend service å¯¹ Client ç«¯è¿›è¡Œ client certificate éªŒè¯çš„æƒ…å†µï¼ŒåŒæ—¶ä¹Ÿé™ä½äº† Nginx åŠ è§£å¯†çš„æ€§èƒ½è´Ÿæ‹…ã€‚</p>
</blockquote>
<p>Ingress Controller å¯åŠ¨æ—¶å¦‚æœæœ‰ <code>--enable-ssl-passthrough</code> å‚æ•°åˆ™å†…éƒ¨ Go ç¨‹åºå ç”¨ 443 ç«¯å£æä¾›ä»£ç†åŠŸèƒ½ã€‚</p>
<pre><code class=language-go>	// Controller ä¸­åˆ¤æ–­æ˜¯å¦å¯ç”¨ ssl é€ä¼ 
	if n.cfg.EnableSSLPassthrough {
		n.setupSSLProxy()
	}

func (n *NGINXController) setupSSLProxy() {
	cfg := n.store.GetBackendConfiguration()
	sslPort := n.cfg.ListenPorts.HTTPS
	proxyPort := n.cfg.ListenPorts.SSLProxy

	klog.InfoS(&quot;Starting TLS proxy for SSL Passthrough&quot;)
	n.Proxy = &amp;TCPProxy{
		Default: &amp;TCPServer{
			Hostname:      &quot;localhost&quot;,
			IP:            &quot;127.0.0.1&quot;,
			Port:          proxyPort,
			ProxyProtocol: true,
		},
	}

    // sslPort ä¸º 443 ç«¯å£
	listener, err := net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;:%v&quot;, sslPort))
	if err != nil {
		klog.Fatalf(&quot;%v&quot;, err)
	}

	// accept TCP connections on the configured HTTPS port
	go func() {
		for {
			var conn net.Conn
			var err error

			conn, err = listener.Accept()
			if err != nil {
				klog.Warningf(&quot;Error accepting TCP connection: %v&quot;, err)
				continue
			}

			klog.V(3).InfoS(&quot;Handling TCP connection&quot;, &quot;remote&quot;, conn.RemoteAddr(), &quot;local&quot;, conn.LocalAddr())
			go n.Proxy.Handle(conn)
		}
	}()
}
</code></pre>
<p>Nginx åœ¨è¢« Go ç¨‹åºå ç”¨ 443 ç«¯å£åï¼Œä¼šåœ¨ <code>proxyPort</code> ç«¯å£ï¼ˆé»˜è®¤ 442ï¼‰ä¸Šç›‘å¬ HTTPS è¯·æ±‚ã€‚</p>
<p>ç”Ÿæˆ http å—ä¸‹ server listen çš„éƒ¨åˆ†æ˜¯è¿™æ ·çš„ï¼š</p>
<pre><code class=language-go>func httpsListener(addresses []string, co string, tc config.TemplateConfig) []string {
	out := make([]string, 0)
	for _, address := range addresses {
		lo := []string{&quot;listen&quot;}

		if tc.IsSSLPassthroughEnabled {
			if address == &quot;&quot; {
				lo = append(lo, fmt.Sprintf(&quot;%v&quot;, tc.ListenPorts.SSLProxy))
			} else {
				lo = append(lo, fmt.Sprintf(&quot;%v:%v&quot;, address, tc.ListenPorts.SSLProxy))
			}

			if !strings.Contains(co, &quot;proxy_protocol&quot;) {
				lo = append(lo, &quot;proxy_protocol&quot;)
			}
		} else {
			if address == &quot;&quot; {
				lo = append(lo, fmt.Sprintf(&quot;%v&quot;, tc.ListenPorts.HTTPS))
			} else {
				lo = append(lo, fmt.Sprintf(&quot;%v:%v&quot;, address, tc.ListenPorts.HTTPS))
			}
		}

		lo = append(lo, co)
		lo = append(lo, &quot;ssl&quot;)

		if tc.Cfg.UseHTTP2 {
			lo = append(lo, &quot;http2&quot;)
		}

		lo = append(lo, &quot;;&quot;)
		out = append(out, strings.Join(lo, &quot; &quot;))
	}

	return out
}
</code></pre>
<p>é€šè¿‡ä¼ å‚æ¸²æŸ“ Go æ¨¡æ¿ï¼Œæœ€ç»ˆç”Ÿæˆçš„ http å—ä¸­å…¶ä¸­ä¸€ä¸ª server çš„ç¤ºä¾‹ã€‚</p>
<p>å¯ç”¨ <code>ssl passthrough</code> åŠŸèƒ½åï¼Œæ‰€æœ‰ 443 æµé‡ç»è¿‡ Go ç¨‹åºå¤„ç†ï¼ŒNginx ä¸Šåªç›‘å¬ 442 ç«¯å£ã€‚</p>
<pre><code class=language-tmpl>http {
   ## start server svc.test.com
	server {
		server_name svc.test.com;
		listen 80;
		listen 442 proxy_protocol ssl http2;
		
		location / {
			proxy_pass http://default-svc;
		}
	}
	## end server
}
</code></pre>
<p>å†…éƒ¨çš„è¯·æ±‚åˆ†å‘åœ¨ <code>balancer_by_lua_block</code> å—ä¸­è°ƒç”¨ Lua è„šæœ¬å¤„ç†ï¼Œè¿™é‡Œä¸åšè¯¦ç»†æè¿°ã€‚</p>
<p>Go ç¨‹åºé€šè¿‡è¯»å–è¯·æ±‚å‰ 4k å­—èŠ‚ï¼Œè§£æå‡º SNI åŸŸåï¼ŒæŸ¥æ‰¾åç«¯æœåŠ¡å™¨ã€‚</p>
<pre><code class=language-go>/* This function is basically all most folks want to invoke out of this
 * jumble of bits. This will take an incoming TLS Client Hello (including
 * all the fuzzy bits at the beginning of it - fresh out of the socket) and
 * go ahead and give us the SNI Name they want. */
func GetHostname(data []byte) (string, error) {
	if len(data) == 0 || data[0] != 0x16 {
		return &quot;&quot;, fmt.Errorf(&quot;Doesn't look like a TLS Client Hello&quot;)
	}

	extensions, err := GetExtensionBlock(data)
	if err != nil {
		return &quot;&quot;, err
	}
	sn, err := GetSNBlock(extensions)
	if err != nil {
		return &quot;&quot;, err
	}
	sni, err := GetSNIBlock(sn)
	if err != nil {
		return &quot;&quot;, err
	}
	return string(sni), nil
}
</code></pre>
<p>å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„åç«¯æœåŠ¡å™¨ï¼ˆæ²¡æœ‰å¼€å¯ SSL é€ä¼ åŠŸèƒ½ï¼‰ï¼Œåˆ™ä¼ é€’åˆ°é»˜è®¤çš„ Nginx 442 ç«¯å£ï¼Œäº¤ç»™ Nginx å»å¤„ç† HTTPS è¯·æ±‚ã€‚</p>
<pre><code class=language-go>// Get returns the TCPServer to use for a given host.
func (p *TCPProxy) Get(host string) *TCPServer {
	if p.ServerList == nil {
		return p.Default
	}

	for _, s := range p.ServerList {
		if s.Hostname == host {
			return s
		}
	}

	return p.Default
}
</code></pre>
<p>å¤„ç†æ•°æ®æµï¼š</p>
<pre><code class=language-go>// Handle reads enough information from the connection to extract the hostname
// and open a connection to the passthrough server.
func (p *TCPProxy) Handle(conn net.Conn) {
	defer conn.Close()
	data := make([]byte, 4096)

	length, err := conn.Read(data)
	if err != nil {
		klog.V(4).ErrorS(err, &quot;Error reading the first 4k of the connection&quot;)
		return
	}

	proxy := p.Default
	hostname, err := parser.GetHostname(data[:])
	if err == nil {
		klog.V(4).InfoS(&quot;TLS Client Hello&quot;, &quot;host&quot;, hostname)
		proxy = p.Get(hostname)
	}

	if proxy == nil {
		klog.V(4).InfoS(&quot;There is no configured proxy for SSL connections.&quot;)
		return
	}

	hostPort := net.JoinHostPort(proxy.IP, fmt.Sprintf(&quot;%v&quot;, proxy.Port))
	clientConn, err := net.Dial(&quot;tcp&quot;, hostPort)
	if err != nil {
		return
	}
	defer clientConn.Close()

	if err != nil {
		klog.ErrorS(err, &quot;Error writing Proxy Protocol header&quot;)
		clientConn.Close()
	} else {
		_, err = clientConn.Write(data[:length])
		if err != nil {
			klog.Errorf(&quot;Error writing the first 4k of proxy data: %v&quot;, err)
			clientConn.Close()
		}
	}

	pipe(clientConn, conn)
}

func pipe(client, server net.Conn) {
	doCopy := func(s, c net.Conn, cancel chan&lt;- bool) {
		io.Copy(s, c)
		cancel &lt;- true
	}

	cancel := make(chan bool, 2)

	go doCopy(server, client, cancel)
	go doCopy(client, server, cancel)

	select {
	case &lt;-cancel:
		return
	}
}
</code></pre>
<p>å®˜æ–¹æ–‡æ¡£ä¸­æè¿°è¯¥åŠŸèƒ½ä¼šé€ æˆ<strong>ä¸å¯å¿½ç•¥çš„æ€§èƒ½å½±å“</strong>ã€‚</p>
</div>
<footer class=post-footer>
<div class=post-meta>
<time datetime=" 2021-11-06" itemprop=datePublished>Nov 6, 2021</time>
</div>
</footer>
</article>
<script src=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.min.js></script>
<aside class=typeface-sans lang=ja>
<nav class=toc></nav>
</aside>
<script>tocbot.init({tocSelector:'.toc',contentSelector:'article',headingSelector:'h1, h2, h3, h4, h5',hasInnerContainers:!0,collapseDepth:"3",positionFixedSelector:".toc",headingsOffset:10})</script>
</div><script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/filter-highlight-all/prism-filter-highlight-all.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script>Prism.plugins.filterHighlightAll.add(function(a){return a.language!=="mermaid"})</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.init({startOnLoad:!0},"pre code.language-mermaid",function(){const a=document.querySelectorAll('code.language-mermaid');for(const c of a){c.style.backgroundColor='initial';const b=c.parentNode;b.style.border='none',b.style.textAlign='center',window.darkmode&&!window.darkmode.isActivated()&&(b.style.backgroundColor='initial')}})</script>
</div>
</main><footer class=site-footer>
<div class=wrapper>
<div class=social-links>
<a class="social-link social-github" href=https://github.com/mayocream><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5C9.34 21.58 9.5 21.27 9.5 21 9.5 20.77 9.5 20.14 9.5 19.31 6.73 19.91 6.14 17.97 6.14 17.97c-.46-1.16-1.11-1.47-1.11-1.47C4.12 15.88 5.1 15.9 5.1 15.9 6.1 15.97 6.63 16.93 6.63 16.93 7.5 18.45 8.97 18 9.54 17.76 9.63 17.11 9.89 16.67 10.17 16.42c-2.22-.25-4.55-1.11-4.55-4.92.0-1.11.38-2 1.03-2.71C6.55 8.54 6.2 7.5 6.75 6.15c0 0 .84-.27 2.75 1.02C10.29 6.95 11.15 6.84 12 6.84s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02C17.8 7.5 17.45 8.54 17.35 8.79 18 9.5 18.38 10.39 18.38 11.5c0 3.82-2.34 4.66-4.57 4.91C14.17 16.72 14.5 17.33 14.5 18.26c0 1.34.0 2.42.0 2.74.0.27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg>
</a>
<a class="social-link social-rss" href=/index.xml target=_blank><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M6.18 15.64a2.18 2.18.0 012.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18.0 012.18-2.18M4 4.44A15.56 15.56.0 0119.56 20H16.73A12.73 12.73.0 004 7.27V4.44M4 10.1A9.9 9.9.0 0113.9 20H11.07A7.07 7.07.0 004 12.93V10.1z"/></svg>
</a>
</div>
<div class=credits>
Theme KAGAMI by Kamikat
</div>
</div>
</footer><script>(function(a){for(var a=Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')),b=0,c;b!=a.length;b++)c=a[b],c.innerHTML=c.innerHTML.replace(/[\u2000-\u206eâ¸€-\u2e7eâº€-\u2efeâ¼€-\u2fdeâ¿°-\u2ffe\u3000-ã€¾\u3040-ã‚ã‚ -ãƒ¾\u3100-\u312e\u3130-ã†ã†-ã†ã† -\u31beã‡€-\u31eeã‡°-ã‡¾ãˆ€-ã‹¾ãŒ€-ã¾ã€-\u4dbeä¸€-\u9ffe\ua960-\ua97eê°€-\ud7ae\ud7b0-\ud7feï¤€-\ufafeï¸°-ï¹\uff00-ï¿®]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud82c[\udc00-\udcfe]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e]/g,function(a){return'<span class="baseline-fix-block">'+a+'<'+'/span>'}),c.classList.remove('baseline-fix')})(Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')))</script>
<script type=text/javascript>const resize=function(){this.width=.5*(this.naturalWidth||this.width)};Array.prototype.forEach.call(document.querySelectorAll('.half-size, .retina2x'),function(a){a.naturalWidth?resize.call(a):a.onload=resize})</script>
<script src=https://cdn.jsdelivr.net/npm/twemoji@13.1.0/dist/twemoji.min.js></script>
<script>twemoji.parse(document.body,{folder:'svg',ext:'.svg'})</script>
</body>