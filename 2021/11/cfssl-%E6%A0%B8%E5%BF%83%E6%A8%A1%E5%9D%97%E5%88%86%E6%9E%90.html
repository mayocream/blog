<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/c3b55921f92a131e.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-072f062dc024cc52.js"/><script src="/_next/static/chunks/f4f1b8d9-0107da81548bf985.js" async=""></script><script src="/_next/static/chunks/435-d305dd8b5fb158de.js" async=""></script><script src="/_next/static/chunks/main-app-3958e659bb0a464b.js" async=""></script><title>Mayo Rocks!</title><meta name="description" content="Mayo&#x27;s Blog"/><link rel="icon" href="/icon.png?14d5a92fbe70e82a" type="image/png" sizes="460x460"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased"><article><h2>1. æ¦‚è¿°</h2>
<h3>1.1. é¡¹ç›®ç®€ä»‹</h3>
<p><em>cfssl</em> æ˜¯ Cloudflare çš„ PKIï¼Œä¹Ÿæ˜¯è¯ä¹¦ç”Ÿæˆçš„å·¥å…·é“¾ã€‚<em>cfssl</em> ä½œä¸ºè¯ä¹¦ç”Ÿæˆçš„å·¥å…·é“¾å¯èƒ½æ›´ä¸ºäººç†ŸçŸ¥ï¼ŒGoogle ä¸Šæœç´¢åˆ°çš„å…³äº <em>cfssl</em> çš„ä»‹ç»ä»¥åŠä½¿ç”¨éƒ½æ˜¯å…³äºä½¿ç”¨ CLI ç”Ÿæˆè‡ªç­¾åè¯ä¹¦çš„ï¼Œå‡ ä¹æ²¡æœ‰é’ˆå¯¹ <em>cfssl</em> ä½œä¸º CA ä¸­å¿ƒçš„ä»‹ç»ã€‚</p>
<p>ä» commit å†å²æ¥çœ‹è¿™æ˜¯ä¸€ä¸ª 7 å¹´å‰å°±å¯åŠ¨çš„é¡¹ç›®ï¼Œé¡¹ç›®ä¸­çš„æ–‡æ¡£å¤§éƒ¨åˆ†è¿˜æ˜¯ <em>.txt</em> åç¼€çš„çº¯æ–‡æœ¬ã€‚ä½†æ˜¯é¡¹ç›®çš„å®Œæˆåº¦å¾ˆé«˜ï¼Œå†…éƒ¨ CA å®ç°äº†å¤šå±‚çº§ï¼Œèƒ½å¤Ÿå¼•å…¥å¤–éƒ¨ CAï¼ŒåŒ…æ‹¬æä¾›äº†è°ƒç”¨ CA API çš„ Go çš„ Client åŒ…ï¼Œä»¥åŠç”¨äºè¯ä¹¦è½®æ¢çš„ KeyProvider packageã€‚</p>
<p>ä»¥åŠæœ‰ Cloudflare å®˜æ–¹çš„ certmgr é¡¹ç›®ï¼Œç”¨äºåœ¨ K8s é›†ç¾¤ä¸­ä½¿ç”¨ cfssl è‡ªåŠ¨ç­¾å‘è¯ä¹¦ï¼Œè¯¥é¡¹ç›®æè¿°ä¸­æåˆ°åœ¨ CF çš„ç”Ÿæˆç¯å¢ƒä½¿ç”¨ã€‚è¯´åˆ°æ­¤å¤„æœ¬äººæƒ³åˆ° CF åœ¨å…¶åŸŸåæ‰˜ç®¡çš„æœåŠ¡ä¸­æœ‰å…è´¹ TLS è¯ä¹¦ç”Ÿæˆï¼ŒåŒ…å« Originã€Browser è¯ä¹¦ï¼Œæˆ–è®¸æ˜¯ä½¿ç”¨è¯¥é¡¹ç›®è¿›è¡Œç”Ÿæˆçš„ã€‚</p>
<p>ä½†æ˜¯é¡¹ç›®æ›´æ–°é€Ÿåº¦æ¯”è¾ƒæ…¢ï¼Œæœ¬äººæçš„ 2 ä¸ª Pull Request ç­‰äº†ä¸€å‘¨åªè¢«åˆå¹¶äº†ä¸€ä¸ªï¼Œå¦ä¸€ä¸ª feature ç±»å‹çš„ PR è¿˜åœ¨ç­‰å¾…å®¡æ ¸ã€‚</p>
<p><em>Istio</em> æœ€å¼€å§‹ä¹Ÿæ˜¯ä½¿ç”¨ <em>cfssl</em> ç”Ÿæˆè‡ªç­¾å CA è¯ä¹¦ï¼Œä½†æ˜¯ç”±äº <em>Istio</em> å†…éƒ¨éœ€è¦å®ç° SDS åè®®ã€å…¼å®¹ SPIFFE ID æ ‡å‡†ï¼Œåœ¨åç»­çš„è¿­ä»£ä¸­ä½¿ç”¨äº†è‡ªå·±çš„ PKI å°†å…¶æ›¿æ¢äº†ã€‚</p>
<p><em>cfssl</em> å®˜æ–¹ master åˆ†æ”¯çš„ä»£ç ä¸èƒ½å®Œå…¨æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œä¾‹å¦‚ä¸å…¼å®¹ SAN URI å­—æ®µçš„è¯ä¹¦ç­¾å‘ï¼Œè¯ä¹¦è½®æ¢å®¢æˆ·ç«¯ä½¿ç”¨è¿‡äºç¹çâ€¦â€¦ä½†æ˜¯åŸºäº <em>cfssl</em> æˆ‘ä»¬èƒ½å¤Ÿå¿«é€Ÿå®ç°ä¸€ä¸ªä¸šç•Œæ ‡å‡†çš„ï¼Œå®Œå¤‡çš„ PKIã€CA ä¸­å¿ƒã€‚</p>
<h3>1.2. é¡¹ç›®ç»“æ„</h3>
<p><em>cfssl</em> ç”±ä¸€ç»„ç»„å·¥å…·åŒ…ç»„æˆï¼ŒåŠŸèƒ½è¾ƒä¸ºç‹¬ç«‹ï¼Œå› æ­¤ä¹Ÿèƒ½å¤Ÿæ–¹ä¾¿çš„ä»å…¶ä»–é¡¹ç›®å¼•ç”¨è¿™äº›åŒ…ã€‚</p>
<pre><code class="language-bash">$ tree -d -L 1 -A
.
â”œâ”€â”€ api
â”œâ”€â”€ auth
â”œâ”€â”€ bundler
â”œâ”€â”€ certdb
â”œâ”€â”€ certinfo
â”œâ”€â”€ cli
â”œâ”€â”€ cmd
â”œâ”€â”€ config
â”œâ”€â”€ crl
â”œâ”€â”€ crypto
â”œâ”€â”€ csr
â”œâ”€â”€ doc
â”œâ”€â”€ errors
â”œâ”€â”€ helpers
â”œâ”€â”€ info
â”œâ”€â”€ initca
â”œâ”€â”€ log
â”œâ”€â”€ multiroot
â”œâ”€â”€ ocsp
â”œâ”€â”€ revoke
â”œâ”€â”€ scan
â”œâ”€â”€ selfsign
â”œâ”€â”€ signer
â”œâ”€â”€ testdata
â”œâ”€â”€ transport
â”œâ”€â”€ ubiquity
â”œâ”€â”€ vendor
â””â”€â”€ whitelist

28 directories
</code></pre>
<h2>2. æºç åˆ†æ</h2>
<p>ç”±äºå¸‚é¢ä¸Šçš„ Golang PKI ç¨‹åºç›®å½•ç»“æ„éƒ½æ˜¯ä¸€ä¸ªä¸ªåŒ…ç»„æˆçš„ï¼Œä¾‹å¦‚ <a href="https://github.com/letsencrypt/boulder">letsencrypt/boulder</a> é¡¹ç›®ï¼Œè¿™é‡Œé€šè¿‡æµç¨‹åˆ†ææ›´æ¸…æ™°ã€‚</p>
<h3>2.0. æ¶æ„è®¾è®¡</h3>
<h4>2.0.1. Profiles</h4>
<p><em>cfssl</em> çš„é…ç½®ä»¥ <em>profile</em> åŒºåˆ†ï¼Œè¿™é‡Œçœ‹ä¸€ä¸ª<strong>CA ä¸­å¿ƒ</strong>ç¤ºä¾‹é…ç½®ï¼š</p>
<pre><code class="language-json">{
  "signing": {
    "default": {
      "expiry": "168h"
    },
    "profiles": {
      "client": {
        "expiry": "1h",
        "usages": [
          "signing",
          "key encipherment",
          "client auth"
        ]
      },
      "server": {
        "expiry": "1h",
        "usages": [
          "signing",
          "key encipherment",
          "server auth"
        ]
      }
    }
  }
}
</code></pre>
<p>æ ¹æ® profile name åŒºåˆ†ä¸åŒçš„ç­¾åç±»å‹ã€‚</p>
<p>æˆ‘ä»¬å†æ¥çœ‹é€šè¿‡ SDK è¿æ¥ CA ä¸­å¿ƒçš„é…ç½®æ–‡ä»¶ï¼š</p>
<pre><code class="language-json">{
  "request": {
    "CN": "test server",
    "hosts": [
      "127.0.0.1"
    ]
  },
  "profiles": {
    "paths": {
      "private_key": "server.key",
      "certificate": "server.pem"
    },
    "cfssl": {
      "profile": "server",
      "remote": "127.0.0.1:8888"
    }
  },
  "roots": [
    {
      "type": "system"
    }
  ],
  "client_roots": [
    {
      "type": "cfssl",
      "metadata": {
        "host": "127.0.0.1:8888",
        "profile": "client"
      }
    }
  ]
}

</code></pre>
<p>CA ä¸­å¿ƒä¼šæ ¹æ® profile ä¸åŒï¼Œä½¿ç”¨ä¸åŒçš„é…ç½®å»å¤„ç†è¯·æ±‚ã€ç­¾å‘è¯ä¹¦ã€‚</p>
<h4>2.0.2. è®¤è¯ä½“ç³»</h4>
<p><em>cfssl</em> æ”¯æŒä½¿ç”¨ mTLSï¼Œä»¥åŠ Auth Key æ¥è¿›è¡Œèº«ä»½éªŒè¯ã€‚</p>
<p>å…¶ä¸­ Auth Key æ”¯æŒ <code>standard</code> å’Œ <code>standard-ip</code> ä¸¤ç§ç±»å‹ã€‚</p>
<p>CA ä¸­å¿ƒé…ç½®ç¤ºä¾‹ï¼š</p>
<pre><code class="language-json">{
  "auth_keys": {
    "client": {
      "type": "standard",
      "key": "52abb3ac91971bb72bce17e7a289cd04476490b19e0d8eb7810dc42d4ac16c41"
    },
    "server": {
      "type": "standard",
      "key": "4f4f26686209f672e0ec7b19cbbc8b6d94fdd12cc0b20326f9005d5f234e6e3e"
    }
  },
  "signing": {
    "default": {
      "expiry": "168h"
    },
    "profiles": {
      "client": {
        "auth_key": "client",
        "expiry": "1h",
        "usages": [
          "signing",
          "key encipherment",
          "client auth"
        ]
      },
      "server": {
        "auth_key": "server",
        "expiry": "8760h",
        "usages": [
          "signing",
          "key encipherment",
          "server auth"
        ]
      }
    }
  }
}

</code></pre>
<p>SDK å®¢æˆ·ç«¯é…ç½®ç¤ºä¾‹ï¼š</p>
<pre><code class="language-json">{
  "request": {
    "CN": "test server",
    "hosts": ["127.0.0.1"]
  },
  "profiles": {
    "paths": {
      "private_key": "server.key",
      "certificate": "server.pem"
    },
    "cfssl": {
      "profile": "server",
      "remote": "127.0.0.1:8888",
      "auth-type": "standard",
      "auth-key": "4f4f26686209f672e0ec7b19cbbc8b6d94fdd12cc0b20326f9005d5f234e6e3e"
    }
  },
  "roots": [{
    "type": "system"
  }],
  "client_roots": [{
    "type": "cfssl",
    "metadata": {
      "host": "127.0.0.1:8888",
      "profile": "client"
    }
  }]
}
</code></pre>
<h3>2.1. è¯ä¹¦ç®¡ç†</h3>
<p>æˆ‘ä»¬ä»ä¸€ç»„å®˜æ–¹ç»™å‡ºçš„ç¤ºä¾‹ shell å½“ä½œå…¥å£æ¥çœ‹ï¼š</p>
<pre><code class="language-bash">#!/bin/sh

cfssl gencert -initca ca.json | cfssljson -bare ca
</code></pre>
<p><code>ca.json</code> æ–‡ä»¶å†…å®¹ï¼š</p>
<pre><code class="language-json">{
  "hosts": [
    "dropsonde.net"
  ],
  "key": {
    "algo": "rsa",
    "size": 4096
  },
  "names": [
    {
      "C": "US",
      "L": "San Francisco",
      "OU": "Dropsonde Certificate Authority",
      "ST": "California"
    }
  ]
}
</code></pre>
<p><code>cfssl gencert</code> å‘½ä»¤æ³¨é‡Šï¼š</p>
<pre><code class="language-go">var gencertUsageText = `cfssl gencert -- generate a new key and signed certificate

Usage of gencert:
    Generate a new key and cert from CSR:
        cfssl gencert -initca CSRJSON
        cfssl gencert -ca cert -ca-key key [-config config] [-profile profile] [-hostname hostname] CSRJSON
        cfssl gencert -remote remote_host [-config config] [-profile profile] [-label label] [-hostname hostname] CSRJSON

    Re-generate a CA cert with the CA key and CSR:
        cfssl gencert -initca -ca-key key CSRJSON

    Re-generate a CA cert with the CA key and certificate:
        cfssl gencert -renewca -ca cert -ca-key key

Arguments:
        CSRJSON:    JSON file containing the request, use '-' for reading JSON from stdin

Flags:
`
</code></pre>
<h4>2.1.1. ç”Ÿæˆç§é’¥</h4>
<p><code>-initca</code> å‚æ•°è¡¨ç¤ºæ˜¯ CAã€‚</p>
<pre><code class="language-go">// cli/gencert/gencert.go

// åˆ›å»ºé»˜è®¤ CSR è¯·æ±‚
req := csr.CertificateRequest{
   // é»˜è®¤ä½¿ç”¨ ecdsa, 256 ç”Ÿæˆ private key
   KeyRequest: csr.NewKeyRequest(),
}
</code></pre>
<p><em>cfssl</em> ä¸­é»˜è®¤ä½¿ç”¨ ECDSA with <em>curve P-256</em> ç®—æ³•ç”Ÿæˆç§é’¥ã€‚</p>
<p>ä»¥ä¸‹æ‘˜è‡ª <a href="https://tools.ietf.org/html/rfc6605">rfc6605</a> (Elliptic Curve Digital Signature Algorithm (DSA) for DNSSEC)</p>
<blockquote>
<p>Current estimates are that ECDSA with curve P-256 has an approximate
equivalent strength to RSA with 3072-bit keys.  Using ECDSA with
curve P-256 in DNSSEC has some advantages and disadvantages relative
to using RSA with SHA-256 and with 3072-bit keys.  ECDSA keys are
much shorter than RSA keys; at this size, the difference is 256
versus 3072 bits.  Similarly, ECDSA signatures are much shorter than
RSA signatures.  This is relevant because DNSSEC stores and transmits
both keys and signatures.</p>
</blockquote>
<p>In the two signing algorithms defined in this document, the size of
the key for the elliptic curve is matched with the size of the output
of the hash algorithm.  This design is based on the widespread belief
that the equivalent strength of P-256 and P-384 is half the length of
the key, and also that the equivalent strength of SHA-256 and SHA-384
is half the length of the key.  Using matched strengths prevents an
attacker from choosing the weaker half of a signature algorithm.  For
example, in a signature that uses RSA with 2048-bit keys and SHA-256,
the signing portion is significantly weaker than the hash portion,
whereas the two algorithms here are balanced.</p>
<p>Signing with ECDSA is significantly faster than with RSA (over 20
times in some implementations).  However, validating RSA signatures
is significantly faster than validating ECDSA signatures (about 5
times faster in some implementations).</p>
<p>ECDSA with curve P-256 ä¸ RSA with SHA-256 å¼ºåº¦ç›¸å½“ï¼›å‰è€…ç­¾åé€Ÿåº¦å¿«äºåè€…ï¼Œåè€…éªŒè¯é€Ÿåº¦å¿«äºå‰è€…ã€‚</p>
<pre><code class="language-go">// csr/csr.go

// Generate generates a key as specified in the request. Currently,
// only ECDSA and RSA are supported.
func (kr *KeyRequest) Generate() (crypto.PrivateKey, error) {
	log.Debugf("generate key from request: algo=%s, size=%d", kr.Algo(), kr.Size())
	switch kr.Algo() {
	case "rsa":
		if kr.Size() &#x3C; 2048 {
			return nil, errors.New("RSA key is too weak")
		}
		if kr.Size() > 8192 {
			return nil, errors.New("RSA key size too large")
		}
		return rsa.GenerateKey(rand.Reader, kr.Size())
	case "ecdsa":
		var curve elliptic.Curve
		switch kr.Size() {
		case curveP256:
			curve = elliptic.P256()
		case curveP384:
			curve = elliptic.P384()
		case curveP521:
			curve = elliptic.P521()
		default:
			return nil, errors.New("invalid curve")
		}
		// è°ƒç”¨å®˜æ–¹åŒ…ç”Ÿæˆç§é’¥
		return ecdsa.GenerateKey(curve, rand.Reader)
	default:
		return nil, errors.New("invalid algorithm")
	}
}
</code></pre>
<p>ç§é’¥è½¬æ¢ä¸º PEM æ ¼å¼ï¼š</p>
<pre><code class="language-go">// csr/csr.go

	// ç§é’¥è½¬æ¢æˆ pem æ ¼å¼
	switch priv := priv.(type) {
	case *rsa.PrivateKey:
		key = x509.MarshalPKCS1PrivateKey(priv)
		block := pem.Block{
			Type:  "RSA PRIVATE KEY",
			Bytes: key,
		}
		key = pem.EncodeToMemory(&#x26;block)
	case *ecdsa.PrivateKey:
		key, err = x509.MarshalECPrivateKey(priv)
		if err != nil {
			err = cferr.Wrap(cferr.PrivateKeyError, cferr.Unknown, err)
			return
		}
		block := pem.Block{
			Type:  "EC PRIVATE KEY",
			Bytes: key,
		}
		key = pem.EncodeToMemory(&#x26;block)
</code></pre>
<h4>2.1.2. ç”Ÿæˆ CSR</h4>
<p><code>csr, err = Generate(priv.(crypto.Signer), req)</code></p>
<pre><code class="language-go">// æ ¹æ®ç§é’¥å’Œè¯·æ±‚å‚æ•°ç”Ÿæˆæ ‡å‡† CSR
// Generate creates a new CSR from a CertificateRequest structure and
// an existing key. The KeyRequest field is ignored.
func Generate(priv crypto.Signer, req *CertificateRequest) (csr []byte, err error) {
	// è·å– x509 ç­¾åç®—æ³•
	sigAlgo := helpers.SignerAlgo(priv)
	if sigAlgo == x509.UnknownSignatureAlgorithm {
		return nil, cferr.New(cferr.PrivateKeyError, cferr.Unavailable)
	}

	// csr æ¨¡æ¿
	var tpl = x509.CertificateRequest{
		Subject:            req.Name(), // å¡«å…… subject å­—æ®µ
		SignatureAlgorithm: sigAlgo,
	}

	// è§£æå¡«å…… SAN å­—æ®µ
	for i := range req.Hosts {
		if ip := net.ParseIP(req.Hosts[i]); ip != nil {
			tpl.IPAddresses = append(tpl.IPAddresses, ip)
		} else if email, err := mail.ParseAddress(req.Hosts[i]); err == nil &#x26;&#x26; email != nil {
			tpl.EmailAddresses = append(tpl.EmailAddresses, email.Address)
		} else if uri, err := url.ParseRequestURI(req.Hosts[i]); err == nil &#x26;&#x26; uri != nil {
			tpl.URIs = append(tpl.URIs, uri)
		} else {
			tpl.DNSNames = append(tpl.DNSNames, req.Hosts[i])
		}
	}

	tpl.ExtraExtensions = []pkix.Extension{}

    ...

	// è°ƒç”¨ x509 åŒ…ç”Ÿæˆ csr
	csr, err = x509.CreateCertificateRequest(rand.Reader, &#x26;tpl, priv)
	if err != nil {
		log.Errorf("failed to generate a CSR: %v", err)
		err = cferr.Wrap(cferr.CSRError, cferr.BadRequest, err)
		return
	}
	block := pem.Block{
		Type:  "CERTIFICATE REQUEST",
		Bytes: csr,
	}

	log.Info("encoded CSR")
	// ç”Ÿæˆ pem æ ¼å¼ csr
	csr = pem.EncodeToMemory(&#x26;block)
	return
}
</code></pre>
<p><code>csr.Generate()</code> æ¥æ”¶çš„ Request å‚æ•°å®é™…ä¸Šæ˜¯ä½œä¸º CSR çš„æ¨¡æ¿ã€‚</p>
<p>æ­¤å¤„ä¸ Istio PKI ä¸­ç”Ÿæˆ CSR çš„å‡½æ•°ç›¸ä¼¼ï¼Œæ„Ÿå…´è¶£çš„ä¹Ÿå¯ä»¥æŸ¥çœ‹æœ¬äººçš„ã€ŠIstio å®‰å…¨æ¨¡å—è§£æã€‹æ–‡æ¡£ã€‚</p>
<p>å®é™…å¼€å‘è¿‡ç¨‹ä¸­å‘ç°æ­¤å¤„æœ‰å‘ï¼Œ<em>cfssl</em> æ­¤å¤„è™½ç„¶æ”¯æŒäº† SAN URI çš„å­—æ®µï¼Œä½†æ˜¯åœ¨é€šè¿‡ cfssl CA Provider å‘é€ CSRã€€è¯·æ±‚è¯ä¹¦çš„æ—¶å€™ï¼Œå…¶æœåŠ¡ç«¯ä¸æ”¯æŒ SAN URI å­—æ®µåˆ°è¯ä¹¦çš„å¡«å……ã€‚é’ˆå¯¹è¿™ä¸€ç‚¹æˆ‘å·²ç»æäº¤äº† Pull Requstã€‚</p>
<p>æˆ‘ä»¬åœ¨å®é™…å¼€å‘ä¸­ï¼Œä½¿ç”¨åˆ›å»º CSR è¯·æ±‚çš„åŒ…æ˜¯æ¥è‡ª Istio PKI çš„ï¼Œå…¶æä¾›äº†æ›´ä¾¿æ·çš„ä½¿ç”¨æ–¹å¼ã€‚</p>
<h4>2.1.3. Signer</h4>
<h5>2.1.3.1. æœ¬åœ°è‡ªç­¾å</h5>
<pre><code class="language-go">// initca/initca.go

// åˆ›å»ºæœ¬åœ°è‡ªç­¾å signer
s, err := local.NewSigner(priv, nil, signer.DefaultSigAlgo(priv), policy)
if err != nil {
	log.Errorf("failed to create signer: %v", err)
	return
}

signReq := signer.SignRequest{Hosts: req.Hosts, Request: string(csrPEM)}
cert, err = s.Sign(signReq)
</code></pre>
<h5>2.1.3.2. Universal</h5>
<p>è®¾ç½® Remote CAï¼Œæˆ–é€šè¿‡ Server å¯åŠ¨æ—¶ï¼Œä¼šåˆ›å»º Universal Signerã€‚</p>
<pre><code class="language-go">// SignerFromConfigAndDB takes the Config and creates the appropriate
// signer.Signer object with a specified db
func SignerFromConfigAndDB(c cli.Config, db *sqlx.DB) (signer.Signer, error) {
   // If there is a config, use its signing policy. Otherwise create a default policy.
   var policy *config.Signing
   if c.CFG != nil {
      policy = c.CFG.Signing
   } else {
      policy = &#x26;config.Signing{
         Profiles: map[string]*config.SigningProfile{},
         Default:  config.DefaultConfig(),
      }
   }

   // Make sure the policy reflects the new remote
   if c.Remote != "" {
      err := policy.OverrideRemotes(c.Remote)
      if err != nil {
         log.Infof("Invalid remote %v, reverting to configuration default", c.Remote)
         return nil, err
      }
   }

   if c.MutualTLSCertFile != "" &#x26;&#x26; c.MutualTLSKeyFile != "" {
      err := policy.SetClientCertKeyPairFromFile(c.MutualTLSCertFile, c.MutualTLSKeyFile)
      if err != nil {
         log.Infof("Invalid mutual-tls-cert: %s or mutual-tls-key: %s, defaulting to no client auth", c.MutualTLSCertFile, c.MutualTLSKeyFile)
         return nil, err
      }
      log.Infof("Using client auth with mutual-tls-cert: %s and mutual-tls-key: %s", c.MutualTLSCertFile, c.MutualTLSKeyFile)
   }

   if c.TLSRemoteCAs != "" {
      err := policy.SetRemoteCAsFromFile(c.TLSRemoteCAs)
      if err != nil {
         log.Infof("Invalid tls-remote-ca: %s, defaulting to system trust store", c.TLSRemoteCAs)
         return nil, err
      }
      log.Infof("Using trusted CA from tls-remote-ca: %s", c.TLSRemoteCAs)
   }

   s, err := universal.NewSigner(cli.RootFromConfig(&#x26;c), policy)
   if err != nil {
      return nil, err
   }

   if db != nil {
      dbAccessor := certsql.NewAccessor(db)
      s.SetDBAccessor(dbAccessor)
   }

   return s, nil
}
</code></pre>
<p>è¿™é‡Œå¯ä»¥çœ‹åˆ°èƒ½å¤Ÿè®¾ç½® TLS å®¢æˆ·ç«¯è¯ä¹¦ã€ä¿¡ä»»çš„ CA è¯ä¹¦ï¼Œä»¥åŠ DBã€‚</p>
<p>è¿™äº›é…ç½®é¡¹éƒ½æ˜¯ä»æ–‡ä»¶è¯»å–çš„ï¼Œåç»­å¼€å‘è¿‡ç¨‹ä¸­æˆ‘è€ƒè™‘ä¼šæ”¹æˆé…ç½®é¡¹è·å–æµç¨‹ï¼š</p>
<ol>
<li>ä» ENV è·å–é…ç½®é¡¹</li>
<li>ä»æ•°æ®åº“è·å–è‡ªèº« CA è¯ä¹¦ã€æ²¡æœ‰åˆ™åˆ›å»º CA è¯ä¹¦</li>
<li>å°†è¯ä¹¦å†™å…¥ä¸´æ—¶æ–‡ä»¶ï¼Œå°†ä¸´æ—¶æ–‡ä»¶åœ°å€ä¼ å…¥ cfssl é…ç½®é¡¹</li>
</ol>
<p>å°½é‡å‡å°‘ä¿®æ”¹æºä»£ç çš„å·¥ç¨‹é‡ï¼Œä¿æŒæœ€å¤§çš„ç¤¾åŒºå…¼å®¹æ€§ã€‚</p>
<h5>2.1.3.3. Remote</h5>
<p><em>cfssl</em> é…ç½®è¿œç¨‹è¯ä¹¦ç­¾å‘ï¼Œ</p>
<pre><code class="language-go">// Helper function to perform a remote sign or info request.
func (s *Signer) remoteOp(req interface{}, profile, target string) (resp interface{}, err error) {
   jsonData, err := json.Marshal(req)
   if err != nil {
      return nil, cferr.Wrap(cferr.APIClientError, cferr.JSONError, err)
   }

   p, err := signer.Profile(s, profile)
   if err != nil {
      return
   }

   server := client.NewServerTLS(p.RemoteServer, helpers.CreateTLSConfig(p.RemoteCAs, p.ClientCert))
   if server == nil {
      return nil, cferr.Wrap(cferr.PolicyError, cferr.InvalidRequest,
         errors.New("failed to connect to remote"))
   }

   server.SetReqModifier(s.reqModifier)

   // There's no auth provider for the "info" method
   if target == "info" {
      resp, err = server.Info(jsonData)
   } else if p.RemoteProvider != nil {
      resp, err = server.AuthSign(jsonData, nil, p.RemoteProvider)
   } else {
      resp, err = server.Sign(jsonData)
   }

   if err != nil {
      return nil, err
   }

   return
}
</code></pre>
<p>æ¶‰åŠåˆ°ä½¿ç”¨ Remote CA çš„æ“ä½œä¼šä½¿ç”¨ <em>cfssl/api</em> åŒ…ï¼Œè°ƒç”¨è¿œç¨‹ CA æ¥å£å¤„ç†ã€‚</p>
<h4>2.1.4. è¯ä¹¦å¤„ç†</h4>
<h5>2.1.4.1. Pre-Issuance Linting</h5>
<pre><code class="language-go">// signer/local/local.go

	var lintPriv crypto.Signer
	// If there is at least one profile (including the default) that configures
	// pre-issuance linting then generate the one-off lintPriv key.
	for _, profile := range policy.Profiles {
		if profile.LintErrLevel > 0 || policy.Default.LintErrLevel > 0 {
			// In the future there may be demand for specifying the type of signer used
			// for pre-issuance linting in configuration. For now we assume that signing
			// with a randomly generated P-256 ECDSA private key is acceptable for all cases
			// where linting is requested.
			k, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
			if err != nil {
				return nil, cferr.New(cferr.PrivateKeyError, cferr.GenerationFailed)
			}
			lintPriv = k
			break
		}
	}
</code></pre>
<p>pre-issuance linting å³é¢„ç­¾å‘æ ¡éªŒï¼Œ<a href="https://wiki.mozilla.org/CA/Required_or_Recommended_Practices#Pre-Issuance_Linting">Mozilla CA</a> å¯¹æ­¤çš„è§£é‡Šæ˜¯ï¼š</p>
<blockquote>
<p>Recently, several tools have been developed (<a href="https://github.com/awslabs/certlint">certlint/cablint</a>, <a href="https://github.com/kroeckx/x509lint">x509lint</a>, <a href="https://github.com/zmap/zlint">zlint</a>) which can check a tbsCertificate (To Be Signed Certificate - the  certificate complete except for the signature) for a large number of  standards violations (BRs, RFCs etc.). It is strongly recommended that  CAs integrate such tools into their issuance pipelines such that  issuance is, minimally, held up for manual review if an error or warning is found. Because BR or RFC violations are generally considered by  Mozilla to be misissuance, such integration will reduce the number of  misissuance events a CA experiences, if earlier parts of their pipeline  fail in their job of keeping certificates compliant.</p>
</blockquote>
<p><em>cfssl</em> åœ¨ <a href="https://github.com/cloudflare/cfssl/issues/1008">Issue #1008</a> ä¸­å¢åŠ å¯¹è¯ä¹¦ lint çš„æ”¯æŒã€‚</p>
<pre><code class="language-go">// signer/local/local.go

// lint performs pre-issuance linting of a given TBS certificate template when
// the provided errLevel is > 0. Note that the template is provided by-value and
// not by-reference. This is important as the lint function needs to mutate the
// template's signature algorithm to match the lintPriv.
func (s *Signer) lint(template x509.Certificate, errLevel lint.LintStatus, lintRegistry lint.Registry) error {
	// Always return nil when linting is disabled (lint.Reserved == 0).
	if errLevel == lint.Reserved {
		return nil
	}
	// without a lintPriv key to use to sign the tbsCertificate we can't lint it.
	if s.lintPriv == nil {
		return cferr.New(cferr.PrivateKeyError, cferr.Unavailable)
	}

	// The template's SignatureAlgorithm must be mutated to match the lintPriv or
	// x509.CreateCertificate will error because of the mismatch. At the time of
	// writing s.lintPriv is always an ECDSA private key. This switch will need to
	// be expanded if the lint key type is made configurable.
	switch s.lintPriv.(type) {
	case *ecdsa.PrivateKey:
		template.SignatureAlgorithm = x509.ECDSAWithSHA256
	default:
		return cferr.New(cferr.PrivateKeyError, cferr.KeyMismatch)
	}

	prelintBytes, err := x509.CreateCertificate(rand.Reader, &#x26;template, s.ca, template.PublicKey, s.lintPriv)
	if err != nil {
		return cferr.Wrap(cferr.CertificateError, cferr.Unknown, err)
	}
	prelintCert, err := zx509.ParseCertificate(prelintBytes)
	if err != nil {
		return cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
	}
	errorResults := map[string]lint.LintResult{}
	results := zlint.LintCertificateEx(prelintCert, lintRegistry)
	for name, res := range results.Results {
		if res.Status > errLevel {
			errorResults[name] = *res
		}
	}
	if len(errorResults) > 0 {
		return &#x26;LintError{
			ErrorResults: errorResults,
		}
	}
	return nil
}
</code></pre>
<p>è‡ªç­¾åæ—¶è°ƒç”¨ zlint è¿›è¡Œè¯ä¹¦åˆæ³•æ€§æ ¡éªŒã€‚</p>
<h5>2.1.4.2. è¯ä¹¦æ¨¡æ¿</h5>
<p>CSR æ¨¡æ¿å¤„ç†ï¼š</p>
<pre><code class="language-go">// signer/local/local.go

	// è§£æ CSR æ¨¡æ¿
	csrTemplate, err := signer.ParseCertificateRequest(s, profile, block.Bytes)
	if err != nil {
		return nil, err
	}

	// Copy out only the fields from the CSR authorized by policy.
	safeTemplate := x509.Certificate{}
	// If the profile contains no explicit whitelist, assume that all fields
	// should be copied from the CSR.
	if profile.CSRWhitelist == nil {
		safeTemplate = *csrTemplate
	} else {
		// å¦‚æœè®¾ç½®äº† CSR æ¨¡æ¿ç™½åå•ï¼Œåˆ™åªæ”¾è¡Œç™½åå•é‡Œçš„å­—æ®µ
		if profile.CSRWhitelist.Subject {
			safeTemplate.Subject = csrTemplate.Subject
		}
		if profile.CSRWhitelist.PublicKeyAlgorithm {
			safeTemplate.PublicKeyAlgorithm = csrTemplate.PublicKeyAlgorithm
		}
		if profile.CSRWhitelist.PublicKey {
			safeTemplate.PublicKey = csrTemplate.PublicKey
		}
		if profile.CSRWhitelist.SignatureAlgorithm {
			safeTemplate.SignatureAlgorithm = csrTemplate.SignatureAlgorithm
		}
		if profile.CSRWhitelist.DNSNames {
			safeTemplate.DNSNames = csrTemplate.DNSNames
		}
		if profile.CSRWhitelist.IPAddresses {
			safeTemplate.IPAddresses = csrTemplate.IPAddresses
		}
		if profile.CSRWhitelist.EmailAddresses {
			safeTemplate.EmailAddresses = csrTemplate.EmailAddresses
		}
		if profile.CSRWhitelist.URIs {
			safeTemplate.URIs = csrTemplate.URIs
		}
	}

	...

	// ç”¨ hosts å­—æ®µè¦†ç›– SAN
	OverrideHosts(&#x26;safeTemplate, req.Hosts)
</code></pre>
<p>ç”Ÿæˆè¯ä¹¦åºåˆ—å·ï¼š</p>
<pre><code class="language-go">		// RFC 5280 4.1.2.2:
		// Certificate users MUST be able to handle serialNumber
		// values up to 20 octets.  Conforming CAs MUST NOT use
		// serialNumber values longer than 20 octets.
		//
		// If CFSSL is providing the serial numbers, it makes
		// sense to use the max supported size.
		serialNumber := make([]byte, 20)
		_, err = io.ReadFull(rand.Reader, serialNumber)
		if err != nil {
			return nil, cferr.Wrap(cferr.CertificateError, cferr.Unknown, err)
		}

		// SetBytes interprets buf as the bytes of a big-endian
		// unsigned integer. The leading byte should be masked
		// off to ensure it isn't negative.
		serialNumber[0] &#x26;= 0x7F

		safeTemplate.SerialNumber = new(big.Int).SetBytes(serialNumber)
</code></pre>
<p>å¡«å……è¯ä¹¦ç‰¹æ®Šå­—æ®µï¼š</p>
<pre><code class="language-go">// signer/signer.go

	// è¯ä¹¦ OCSP å­—æ®µæ¥è‡ªé…ç½®çš„ Profile OCSP URL
	if ocspURL = profile.OCSP; ocspURL == "" {
		ocspURL = defaultProfile.OCSP
	}

	if template.IsCA {
		template.MaxPathLen = profile.CAConstraint.MaxPathLen
		if template.MaxPathLen == 0 {
			template.MaxPathLenZero = profile.CAConstraint.MaxPathLenZero
		}
		// å¦‚æœæ˜¯ CA è¯ä¹¦ï¼Œåˆ™æ²¡æœ‰ SAN å­—æ®µ
		template.DNSNames = nil
		template.EmailAddresses = nil
		template.URIs = nil
	}

	// è‹¥è®¾ç½® OCSP No Check
	if profile.OCSPNoCheck {
		ocspNoCheckExtension := pkix.Extension{
			Id:       asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 48, 1, 5},
			Critical: false,
			Value:    []byte{0x05, 0x00},
		}
		template.ExtraExtensions = append(template.ExtraExtensions, ocspNoCheckExtension)
	}
</code></pre>
<h5>2.1.4.3. ç­¾åè¯ä¹¦</h5>
<pre><code class="language-go">// signer/local/local.go
func (s *Signer) sign(template *x509.Certificate, lintErrLevel lint.LintStatus, lintRegistry lint.Registry) (cert []byte, err error) {
   var initRoot bool
   // æ²¡æœ‰æŒ‡å®š cert
   if s.ca == nil {
      // ä¸æ˜¯ ca è¯ä¹¦åˆ™æŠ¥é”™
      if !template.IsCA {
         err = cferr.New(cferr.PolicyError, cferr.InvalidRequest)
         return
      }
      // ca è¯ä¹¦æ²¡æœ‰ SAN å­—æ®µ
      template.DNSNames = nil
      template.EmailAddresses = nil
      template.URIs = nil
      s.ca = template
      initRoot = true
   }

   if err := s.lint(*template, lintErrLevel, lintRegistry); err != nil {
      return nil, err
   }

   // ç­¾åè¯ä¹¦
   derBytes, err := x509.CreateCertificate(rand.Reader, template, s.ca, template.PublicKey, s.priv)
   if err != nil {
      return nil, cferr.Wrap(cferr.CertificateError, cferr.Unknown, err)
   }
   if initRoot {
      s.ca, err = x509.ParseCertificate(derBytes)
      if err != nil {
         return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
      }
   }

   cert = pem.EncodeToMemory(&#x26;pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
   log.Infof("signed certificate with serial number %d", template.SerialNumber)
   return
}
</code></pre>
<h5>2.1.4.4. æ•°æ®åº“å‚¨å­˜</h5>
<pre><code class="language-go">// å¦‚æœè®¾ç½®äº† DB å‚¨å­˜
if s.dbAccessor != nil {
   now := time.Now()
   var certRecord = certdb.CertificateRecord{
      Serial: certTBS.SerialNumber.String(),
      // this relies on the specific behavior of x509.CreateCertificate
      // which sets the AuthorityKeyId from the signer's SubjectKeyId
      AKI:        hex.EncodeToString(parsedCert.AuthorityKeyId),
      CALabel:    req.Label,
      Status:     "good",
      Expiry:     certTBS.NotAfter,
      PEM:        string(signedCert),
      IssuedAt:   &#x26;now,
      NotBefore:  &#x26;certTBS.NotBefore,
      CommonName: sql.NullString{String: certTBS.Subject.CommonName, Valid: true},
   }

   if err := certRecord.SetMetadata(req.Metadata); err != nil {
      return nil, err
   }
   if err := certRecord.SetSANs(certTBS.DNSNames); err != nil {
      return nil, err
   }

   // åœ¨æ•°æ®åº“åˆ›å»ºä¸€æ¡ row
   if err := s.dbAccessor.InsertCertificate(certRecord); err != nil {
      return nil, err
   }
   log.Debug("saved certificate with serial number ", certTBS.SerialNumber)
}
</code></pre>
<h4>2.1.4. å¯¼å‡ºæ–‡ä»¶</h4>
<p><em>cfssljson</em> Cmd å·¥ä½œä¸ºæ¥æ”¶è¯·æ±‚è¿”å›ï¼Œå¹¶å°†å…¶é€šè¿‡ Pipeline è§£æï¼Œè¾“å‡ºåˆ°æ–‡ä»¶ã€‚</p>
<pre><code class="language-go">// cmd/cfssljson/cfssljson.go
func readFile(filespec string) ([]byte, error) {
	if filespec == "-" {
		// è‹¥å‚æ•°ä¸º "-"ï¼Œåˆ™ä» stdin è·å–
		return ioutil.ReadAll(os.Stdin)
	}
	return ioutil.ReadFile(filespec)
}
</code></pre>
<p>è§£ææˆå¯¹åº”æ ¼å¼çš„æ–‡ä»¶å¹¶è¾“å‡ºã€‚</p>
<pre><code class="language-go">	if contents, ok := input["cert"]; ok {
		cert = contents.(string)
	} else if contents, ok = input["certificate"]; ok {
		cert = contents.(string)
	}
	if cert != "" {
		outs = append(outs, outputFile{
			Filename: baseName + ".pem",
			Contents: cert,
			Perms:    0664,
		})
	}

	if contents, ok := input["key"]; ok {
		key = contents.(string)
	} else if contents, ok = input["private_key"]; ok {
		key = contents.(string)
	}
	if key != "" {
		outs = append(outs, outputFile{
			Filename: baseName + "-key.pem",
			Contents: key,
			Perms:    0600,
		})
	}

	for _, e := range outs {
		if *output {
			if e.IsBinary {
				e.Contents = base64.StdEncoding.EncodeToString([]byte(e.Contents))
			}
			fmt.Fprintf(os.Stdout, "%s\n", e.Contents)
		} else {
			writeFile(e.Filename, e.Contents, e.Perms)
		}
	}
</code></pre>
<h4>2.1.5. è¯ä¹¦ Bundle</h4>
<blockquote>
<p><strong>CA bundle</strong> is a file that contains root and  intermediate certificates. The end-entity certificate along with a CA  bundle constitutes the certificate chain.</p>
</blockquote>
<p>How do I make CA-bundle file from CRT files?</p>
<p>There are a few *.crt files in your package:</p>
<ul>
<li><strong>AddTrustExternalCARoot.crt</strong> - Root CA Certificate</li>
<li><strong>COMODORSAAddTrustCA.crt</strong> - Intermediate CA Certificate 1</li>
<li><strong>COMODORSADomainValidationSecureServerCA.crt</strong> - Intermediate CA Certificate 2</li>
<li><strong>yourDomain.crt</strong> - Your SSL Certificate</li>
</ul>
<p>CA-bundle is a file that contains root and intermediate certificates in the right order. The order must be:</p>
<p>- Intermediate CA Certificate 2</p>
<p>- Intermediate CA Certificate 1</p>
<p>- Root CA Certificate</p>
<pre><code class="language-bash">$ cat ComodoRSADomainValidationSecureServerCA.crt ComodoRSAAddTrustCA.crt AddTrustExternalCARoot.crt > yourDomain.ca-bundle
</code></pre>
<p><em>cfssl bundle</em> å‘½ä»¤åªç”¨äºç”ŸæˆåŒ…å« end-entry è¯ä¹¦çš„è¯ä¹¦é“¾ï¼Œä½†åœ¨æˆ‘ä»¬å®é™…ä½¿ç”¨ä¸­ï¼Œåœ¨ Workload é—´ä¼ è¾“çš„åªæ˜¯ Workload è¯ä¹¦ï¼Œä¸ä¼šä¼ è¾“ CA è¯ä¹¦ã€‚</p>
<h3>2.2. CA Server</h3>
<h4>2.2.1. å¯åŠ¨</h4>
<pre><code class="language-go">// serverMain is the command line entry point to the API server. It sets up a
// new HTTP server to handle sign, bundle, and validate requests.
func serverMain(args []string, c cli.Config) error {
	
    ...

    // åˆå§‹åŒ– signer
	if s, err = sign.SignerFromConfigAndDB(c, db); err != nil {
		log.Warningf("couldn't initialize signer: %v", err)
	}

    // åˆå§‹åŒ– ocsp signer
	if ocspSigner, err = ocspsign.SignerFromConfig(c); err != nil {
		log.Warningf("couldn't initialize ocsp signer: %v", err)
	}

    // æ³¨å†Œ api handler
	registerHandlers()

	addr := net.JoinHostPort(conf.Address, strconv.Itoa(conf.Port))

	tlscfg := tls.Config{}
	if conf.MinTLSVersion != "" {
		tlscfg.MinVersion = helpers.StringTLSVersion(conf.MinTLSVersion)
	}

	if conf.TLSCertFile == "" || conf.TLSKeyFile == "" {
		log.Info("Now listening on ", addr)
		return http.ListenAndServe(addr, nil)
	}

    ...
	return server.ListenAndServeTLS(conf.TLSCertFile, conf.TLSKeyFile)

}
</code></pre>
<p>å¯åŠ¨æ—¶æµç¨‹ï¼š</p>
<ol>
<li>åˆ›å»º Signerï¼Œå‚è€ƒ 2.1.3 èŠ‚</li>
<li>æ³¨å†Œ API Handlerï¼Œå¤„ç† HTTP è¯·æ±‚</li>
<li>å¯åŠ¨ HTTP / TLS æœåŠ¡å™¨ï¼ˆæ”¯æŒ mTLSï¼‰</li>
</ol>
<h4>2.2.2. æ³¨å†Œ API Handler</h4>
<pre><code class="language-go">// cli/serve/serve.go

var endpoints = map[string]func() (http.Handler, error){
	"sign": func() (http.Handler, error) {
		if s == nil {
			return nil, errBadSigner
		}

		h, err := signhandler.NewHandlerFromSigner(s)
		if err != nil {
			return nil, err
		}

		if conf.CABundleFile != "" &#x26;&#x26; conf.IntBundleFile != "" {
			sh := h.Handler.(*signhandler.Handler)
			if err := sh.SetBundler(conf.CABundleFile, conf.IntBundleFile); err != nil {
				return nil, err
			}
		}

		return h, nil
	},

	"authsign": func() (http.Handler, error) {
		if s == nil {
			return nil, errBadSigner
		}

		h, err := signhandler.NewAuthHandlerFromSigner(s)
		if err != nil {
			return nil, err
		}

		if conf.CABundleFile != "" &#x26;&#x26; conf.IntBundleFile != "" {
			sh := h.(*api.HTTPHandler).Handler.(*signhandler.AuthHandler)
			if err := sh.SetBundler(conf.CABundleFile, conf.IntBundleFile); err != nil {
				return nil, err
			}
		}

		return h, nil
	},

	"info": func() (http.Handler, error) {
		if s == nil {
			return nil, errBadSigner
		}
		return info.NewHandler(s)
	},

	"crl": func() (http.Handler, error) {
		if s == nil {
			return nil, errBadSigner
		}

		if db == nil {
			return nil, errNoCertDBConfigured
		}

		return crl.NewHandler(certsql.NewAccessor(db), conf.CAFile, conf.CAKeyFile)
	},

	"gencrl": func() (http.Handler, error) {
		if s == nil {
			return nil, errBadSigner
		}
		return gencrl.NewHandler(), nil
	},

	"newcert": func() (http.Handler, error) {
		if s == nil {
			return nil, errBadSigner
		}
		h := generator.NewCertGeneratorHandlerFromSigner(generator.CSRValidate, s)
		if conf.CABundleFile != "" &#x26;&#x26; conf.IntBundleFile != "" {
			cg := h.(api.HTTPHandler).Handler.(*generator.CertGeneratorHandler)
			if err := cg.SetBundler(conf.CABundleFile, conf.IntBundleFile); err != nil {
				return nil, err
			}
		}
		return h, nil
	},

	"bundle": func() (http.Handler, error) {
		return bundle.NewHandler(conf.CABundleFile, conf.IntBundleFile)
	},

	"newkey": func() (http.Handler, error) {
		return generator.NewHandler(generator.CSRValidate)
	},

	"init_ca": func() (http.Handler, error) {
		return initca.NewHandler(), nil
	},

	"scan": func() (http.Handler, error) {
		return scan.NewHandler(conf.CABundleFile)
	},

	"scaninfo": func() (http.Handler, error) {
		return scan.NewInfoHandler(), nil
	},

	"certinfo": func() (http.Handler, error) {
		if db != nil {
			return certinfo.NewAccessorHandler(certsql.NewAccessor(db)), nil
		}

		return certinfo.NewHandler(), nil
	},

	"ocspsign": func() (http.Handler, error) {
		if ocspSigner == nil {
			return nil, errBadSigner
		}
		return apiocsp.NewHandler(ocspSigner), nil
	},

	"revoke": func() (http.Handler, error) {
		if db == nil {
			return nil, errNoCertDBConfigured
		}
		return revoke.NewHandler(certsql.NewAccessor(db)), nil
	},

	"/": func() (http.Handler, error) {
		if err := staticBox.findStaticBox(); err != nil {
			return nil, err
		}

		return http.FileServer(staticBox), nil
	},

	"health": func() (http.Handler, error) {
		return health.NewHealthCheck(), nil
	},
}
</code></pre>
<h4>2.2.3. OCSP</h4>
<blockquote>
<p>Partly to combat these scalability issues, OCSP was introduced. OCSP  provides on-demand answers about the revocation status of a given  certificate. An OCSP responder is a service that returns signed answers  to the question "is this certificate revoked?". The response is either  "Yes" or "No". Each response is signed by the CA and has a validity  period so the client knows how long to cache the response.</p>
<p>CFSSL now has an OCSP responder service that can be configured to run in a distributed way, without access to the CA. There are also OCSP  management tools in CFSSL to automatically populate the data for the  OCSP responder and keep it fresh using the certificate database.</p>
</blockquote>
<p><img src="https://blog.cloudflare.com/content/images/2016/03/image_8.png" alt="refreshing the OCSP responder"></p>
<p>OCSP ç­¾åï¼Œå’Œ OCSP è¿”å›æ˜¯ç‹¬ç«‹çš„ç¨‹åºï¼Œåˆ©äºåˆ†å¸ƒå¼éƒ¨ç½²ã€‚</p>
<h5>2.2.3.1. OCSP Responder</h5>
<p>ä»‹ç»ï¼š</p>
<pre><code class="language-go">// Usage text of 'cfssl serve'
var ocspServerUsageText = `cfssl ocspserve -- set up an HTTP server that handles OCSP requests from either a file or directly from a database (see RFC 5019)

  Usage of ocspserve:
          cfssl ocspserve [-address address] [-port port] [-responses file] [-db-config db-config]

  Flags:
  `
</code></pre>
<p>OCSP Server èƒ½å¤Ÿåœ¨è‡ªå®šä¹‰çš„ Path ä¸Šå¯åŠ¨ï¼š</p>
<pre><code class="language-go">	log.Info("Registering OCSP responder handler")
	http.Handle(c.Path, ocsp.NewResponder(src, nil))
</code></pre>
<p><em>cfssl</em> OCSP å¤„ç†è¯·æ±‚æ¥å£ï¼š</p>
<pre><code class="language-go">// ocsp/responder.go

// A Responder can process both GET and POST requests.  The mapping
// from an OCSP request to an OCSP response is done by the Source;
// the Responder simply decodes the request, and passes back whatever
// response is provided by the source.
// Note: The caller must use http.StripPrefix to strip any path components
// (including '/') on GET requests.
// Do not use this responder in conjunction with http.NewServeMux, because the
// default handler will try to canonicalize path components by changing any
// strings of repeated '/' into a single '/', which will break the base64
// encoding.
func (rs Responder) ServeHTTP(response http.ResponseWriter, request *http.Request) {

	...
    
	// Parse response as an OCSP request
	// XXX: This fails if the request contains the nonce extension.
	//      We don't intend to support nonces anyway, but maybe we
	//      should return unauthorizedRequest instead of malformed.
	ocspRequest, err := ocsp.ParseRequest(requestBody)

    ...
    
	// Look up OCSP response from source
	ocspResponse, headers, err := rs.Source.Response(ocspRequest)

    ...
    
	parsedResponse, err := ocsp.ParseResponse(ocspResponse, nil)

    ...

	response.WriteHeader(http.StatusOK)
	response.Write(ocspResponse)
}

</code></pre>
<p>OCSP è¿”å›çš„å†…å®¹å®é™…ä¸Šç›´æ¥ä»æ•°æ®åº“è¯»å–åè¿”å›ï¼š</p>
<pre><code class="language-go">// ocsp/responder.go

// Response implements cfssl.ocsp.responder.Source, which returns the
// OCSP response in the Database for the given request with the expiration
// date furthest in the future.
func (src DBSource) Response(req *ocsp.Request) ([]byte, http.Header, error) {
	...
	records, err := src.Accessor.GetOCSP(strSN, aki)
	...
	return []byte(cur.Body), nil, nil
}
</code></pre>
<pre><code class="language-go">// GetOCSP retrieves a certdb.OCSPRecord from db by serial.
func (d *Accessor) GetOCSP(serial, aki string) (ors []certdb.OCSPRecord, err error) {
	err = d.checkDB()
	if err != nil {
		return nil, err
	}

	err = d.db.Select(&#x26;ors, fmt.Sprintf(d.db.Rebind(selectOCSPSQL), sqlstruct.Columns(certdb.OCSPRecord{})), serial, aki)
	if err != nil {
		return nil, wrapSQLError(err)
	}

	return ors, nil
}
</code></pre>
<h5>2.2.3.2. OCSP Sign</h5>
<p>OCSP ç­¾åå’Œè¿”å›æ˜¯åˆ†å¼€çš„ï¼Œå¹¶ä¸”ä¸ä¼šåœ¨åˆ›å»ºè¯ä¹¦ä¸€å¹¶åˆ›å»ºã€‚</p>
<p><img src="/images/2021-11-01-07.png" alt="">åœºæ™¯1ï¼šOCSP ç­¾åä¼šåœ¨è¯ä¹¦è¢«åŠé”€æ—¶åˆ›å»ºã€‚</p>
<pre><code class="language-go">// cli/ocsprefresh/ocsprefresh.go

// ocsprefreshMain is the main CLI of OCSP refresh functionality.
func ocsprefreshMain(args []string, c cli.Config) error {
   ...

	s, err := SignerFromConfig(c)
	if err != nil {
		log.Critical("Unable to create OCSP signer: ", err)
		return err
	}

	db, err := dbconf.DBFromConfig(c.DBConfigFile)
	if err != nil {
		return err
	}

	dbAccessor := sql.NewAccessor(db)
	certs, err := dbAccessor.GetUnexpiredCertificates()
	if err != nil {
		return err
	}

	// Set an expiry timestamp for all certificates refreshed in this batch
	ocspExpiry := time.Now().Add(c.Interval)
	for _, certRecord := range certs {
		cert, err := helpers.ParseCertificatePEM([]byte(certRecord.PEM))
		if err != nil {
			log.Critical("Unable to parse certificate: ", err)
			return err
		}

		req := ocsp.SignRequest{
			Certificate: cert,
			Status:      certRecord.Status,
		}

		if certRecord.Status == "revoked" {
			req.Reason = int(certRecord.Reason)
			req.RevokedAt = certRecord.RevokedAt
		}

		resp, err := s.Sign(req)
		if err != nil {
			log.Critical("Unable to sign OCSP response: ", err)
			return err
		}

		err = dbAccessor.UpsertOCSP(cert.SerialNumber.String(), hex.EncodeToString(cert.AuthorityKeyId), string(resp), ocspExpiry)
		if err != nil {
			log.Critical("Unable to save OCSP response: ", err)
			return err
		}
	}

	return nil
}
</code></pre>
<p>åœºæ™¯2ï¼šé€šè¿‡ <code>cfssl ocsprefresh</code> å‘½ä»¤æ‰§è¡Œã€‚</p>
<p>äºŒæ¬¡å¼€å‘æ—¶å¯ä»¥è€ƒè™‘å°† OCSP è®°å½•åœ¨ç­¾å‘è¯ä¹¦æ—¶è¿›è¡Œåˆ›å»ºã€‚</p>
<h4>2.2.4. API Client</h4>
<p><code>api/client</code> åŒ…å®ç°äº† cfssl çš„ API å®¢æˆ·ç«¯ã€‚</p>
<pre><code class="language-go">// A Remote points to at least one (but possibly multiple) remote
// CFSSL instances. It must be able to perform a authenticated and
// unauthenticated certificate signing requests, return information
// about the CA on the other end, and return a list of the hosts that
// are used by the remote.
type Remote interface {
   AuthSign(req, id []byte, provider auth.Provider) ([]byte, error)
   Sign(jsonData []byte) ([]byte, error)
   Info(jsonData []byte) (*info.Resp, error)
   Hosts() []string
   SetReqModifier(func(*http.Request, []byte))
   SetRequestTimeout(d time.Duration)
   SetProxy(func(*http.Request) (*url.URL, error))
}
</code></pre>
<p>ä¸»è¦åŠŸèƒ½ä¸º API æ¥å£å’Œå‚æ•°çš„å°è£…ã€‚ä¼šåœ¨ä¸‹ä¸€èŠ‚ä¸­è¢«ç”¨åˆ°ã€‚</p>
<h5>2.2.4.1. è·å– CA è¯ä¹¦</h5>
<pre><code class="language-go">// signer/local/local.go

// è·å– CA Info
// Info return a populated info.Resp struct or an error.
func (s *Signer) Info(req info.Req) (resp *info.Resp, err error) {
	cert, err := s.Certificate(req.Label, req.Profile)
	if err != nil {
		return
	}

	profile, err := signer.Profile(s, req.Profile)
	if err != nil {
		return
	}

	resp = new(info.Resp)
	if cert.Raw != nil {
		resp.Certificate = string(bytes.TrimSpace(pem.EncodeToMemory(&#x26;pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})))
	}
	resp.Usage = profile.Usage
	resp.ExpiryString = profile.ExpiryString

	return
}
</code></pre>
<p>è¿”å›æœåŠ¡ç«¯çš„ CA è¯ä¹¦ï¼Œè¯¥è¯ä¹¦ä¼šç”¨åœ¨ Client çš„ TrustRoot ä¸­ã€‚</p>
<p>é—®é¢˜ç‚¹ï¼šRoot CA è¯ä¹¦æ²¡æœ‰è¢«åŠ è½½åˆ°ç¨‹åºä¸­ï¼Œéœ€è¦åœ¨æœåŠ¡ç«¯å¢åŠ  Root è¯ä¹¦çš„è¿”å›å€¼ã€‚</p>
<h4>2.2.5. è¯ä¹¦åŠé”€</h4>
<h5>2.2.5.1. åŠé”€æ¥å£</h5>
<p>è¯ä¹¦åŠé”€æ¥å£æ”¯æŒä¸‰ä¸ªå‚æ•°ï¼š</p>
<pre><code class="language-sql">UPDATE certificates
	SET status='revoked', revoked_at=CURRENT_TIMESTAMP, reason=:reason
	WHERE (serial_number = :serial_number AND authority_key_identifier = :authority_key_identifier);
</code></pre>
<p>è¯ä¹¦åºåˆ—å·å’Œ AKI å®šä½ä¸€ä¸ªè¯ä¹¦ã€‚</p>
<pre><code class="language-go">// api/revoke/revoke.go

	// If we were given a signer, try and generate an OCSP
	// response indicating revocation
	if h.Signer != nil {
		// TODO: should these errors be errors?
		// Grab the certificate from the database
		cr, err := h.dbAccessor.GetCertificate(req.Serial, req.AKI)
		if err != nil {
			return err
		}
		if len(cr) != 1 {
			return errors.NewBadRequestString("No unique certificate found")
		}

		cert, err := helpers.ParseCertificatePEM([]byte(cr[0].PEM))
		if err != nil {
			return errors.NewBadRequestString("Unable to parse certificates from PEM data")
		}

		sr := ocsp.SignRequest{
			Certificate: cert,
			Status:      "revoked",
			Reason:      reasonCode,
			RevokedAt:   time.Now().UTC(),
		}

		ocspResponse, err := h.Signer.Sign(sr)
		if err != nil {
			return err
		}

		// We parse the OCSP response in order to get the next
		// update time/expiry time
		ocspParsed, err := stdocsp.ParseResponse(ocspResponse, nil)
		if err != nil {
			return err
		}

		ocspRecord := certdb.OCSPRecord{
			Serial: req.Serial,
			AKI:    req.AKI,
			Body:   string(ocspResponse),
			Expiry: ocspParsed.NextUpdate,
		}

		if err = h.dbAccessor.InsertOCSP(ocspRecord); err != nil {
			return err
		}
	}
</code></pre>
<p>è¯ä¹¦åŠé”€æ—¶ä¼šè¿›è¡Œ OCSP ç­¾åï¼Œåˆ›å»ºä¸€ä¸ªåŠé”€çŠ¶æ€çš„ OCSP Responseã€‚</p>
<h5>2.2.5.2. æŸ¥è¯¢è¯ä¹¦åŠé”€</h5>
<p>è¯ä¹¦åŠé”€æ²¡æœ‰ä¸»åŠ¨é€šçŸ¥æœºåˆ¶ï¼Œå¦‚ä½•æ„Ÿåº”åˆ°è¯ä¹¦å·²ç»è¢«åŠé”€ï¼Ÿ</p>
<p><a href="https://github.com/snowflakedb/gosnowflake/issues/5">https://github.com/snowflakedb/gosnowflake/issues/5</a></p>
<blockquote>
<p>Here are the steps to implement the revocation checks with OCSP:</p>
<ul>
<li>Check if certificate validation can be intercepted to add revocation checks (Yes. TLSClientConfig including verifyPeerCertificate can be  injected in Client)</li>
<li>Extract OCSP URL from the certificate</li>
<li>Make sure OCSP Request can be composed.</li>
<li>Make sure a simple roundtrip with OCSP server returns OCSP Response and can be decoded.</li>
<li>Make sure OCSP Response can include enough information to validate the revocation status.</li>
<li>Implement concurrent OCSP round trips for chained certificates.</li>
<li>Implement caching the results in a cache directory</li>
</ul>
</blockquote>
<p>é€šè¿‡å®ç° <code>tls.Config.VerifyPeerCertificate</code> æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå®šä¹‰å®ç° OCSP æŸ¥è¯¢ï¼š</p>
<pre><code class="language-go">    // VerifyPeerCertificate, if not nil, is called after normal
    // certificate verification by either a TLS client or server. It
    // receives the raw ASN.1 certificates provided by the peer and also
    // any verified chains that normal processing found. If it returns a
    // non-nil error, the handshake is aborted and that error results.
    //
    // If normal verification fails then the handshake will abort before
    // considering this callback. If normal verification is disabled by
    // setting InsecureSkipVerify, or (for a server) when ClientAuth is
    // RequestClientCert or RequireAnyClientCert, then this callback will
    // be considered but the verifiedChains argument will always be nil.
    VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error // Go 1.8
</code></pre>
<p>è®¤è¯ OCSP çš„ç¤ºä¾‹ä»£ç  <a href="https://github.com/snowflakedb/gosnowflake/blob/master/ocsp.go%EF%BC%9A">https://github.com/snowflakedb/gosnowflake/blob/master/ocsp.goï¼š</a></p>
<pre><code class="language-go">// verifyPeerCertificate verifies all of certificate revocation status
func verifyPeerCertificate(ctx context.Context, verifiedChains [][]*x509.Certificate) (err error) {
	for i := 0; i &#x3C; len(verifiedChains); i++ {
		// Certificate signed by Root CA. This should be one before the last in the Certificate Chain
		numberOfNoneRootCerts := len(verifiedChains[i]) - 1
		if !verifiedChains[i][numberOfNoneRootCerts].IsCA || string(verifiedChains[i][numberOfNoneRootCerts].RawIssuer) != string(verifiedChains[i][numberOfNoneRootCerts].RawSubject) {
			// Check if the last Non Root Cert is also a CA or is self signed.
			// if the last certificate is not, add it to the list
			rca := caRoot[string(verifiedChains[i][numberOfNoneRootCerts].RawIssuer)]
			if rca == nil {
				return fmt.Errorf("failed to find root CA. pkix.name: %v", verifiedChains[i][numberOfNoneRootCerts].Issuer)
			}
			verifiedChains[i] = append(verifiedChains[i], rca)
			numberOfNoneRootCerts++
		}
		results := getAllRevocationStatus(ctx, verifiedChains[i])
		if r := canEarlyExitForOCSP(results, numberOfNoneRootCerts); r != nil {
			return r.err
		}
	}

	ocspResponseCacheLock.Lock()
	if cacheUpdated {
		writeOCSPCacheFile()
	}
	cacheUpdated = false
	ocspResponseCacheLock.Unlock()
	return nil
}
</code></pre>
<h3>2.3. Transport</h3>
<p>æˆ‘ç§°å‘¼å®ƒä¸º Workload SDKã€‚</p>
<p>æˆ‘ä»¬åç»­çš„ Workload SDK æ˜¯åŸºäºæ­¤åŒ…ä¿®æ”¹è€Œæ¥ã€‚æœ¬è´¨ä¸Šä¸ Istio Pilot Agent çš„ CA Client ç±»ä¼¼ã€‚</p>
<p><img src="https://blog.cloudflare.com/content/images/2016/03/image_3.png" alt="Certificate Issuance"></p>
<p>æˆ‘å‘ç°ä¸Šå›¾ä¸­ cfssl æŠŠ "OCSP" å†™æˆäº† "OSCP"ï¼ŒğŸ¤£ã€‚</p>
<h4>2.3.1. é…ç½®é¡¹</h4>
<p>é…ç½®é¡¹ä½œä¸ºä¸€ä¸ªç‰¹æ€§ï¼Œåœ¨ CFSSL çš„å®˜æ–¹æ–‡æ¡£ä¸­è¢«æåˆ°ã€‚</p>
<pre><code class="language-go">{
  "request": {
    "CN": "test server",
    "hosts": ["127.0.0.1"]
  },
  "profiles": {
    "paths": {
      "private_key": "server.key",
      "certificate": "server.pem"
    },
    "cfssl": {
      "profile": "server",
      "remote": "127.0.0.1:8888",
      "auth-type": "standard",
      "auth-key": "4f4f26686209f672e0ec7b19cbbc8b6d94fdd12cc0b20326f9005d5f234e6e3e"
    }
  },
  "roots": [{
    "type": "system"
  }],
  "client_roots": [{
    "type": "cfssl",
    "metadata": {
      "host": "127.0.0.1:8888",
      "profile": "client"
    }
  }]
}
</code></pre>
<p><code>roots</code> ä»¥åŠ <code>client_roots</code> æ˜¯ç”¨æ¥é…ç½® System Trust Store å’Œ Client Trust Store çš„ã€‚</p>
<pre><code class="language-go">	// TrustStore contains the certificates trusted by this
	// transport.
	TrustStore *roots.TrustStore

	// ClientTrustStore contains the certificate authorities to
	// use in verifying client authentication certificates.
	ClientTrustStore *roots.TrustStore
</code></pre>
<h4>2.3.2. TrustStore</h4>
<blockquote>
<p>A <strong>TrustStore</strong> holds the certificates of external systems that you trust. So a <strong>TrustStore</strong> is a KeyStore file, that contains the public keys/certificate of external hosts that you trust.</p>
</blockquote>
<h5>2.3.2.1. System Cert Pool</h5>
<p><em>cfssl</em> æºç ä¸­å°† Golang å®˜æ–¹ x509 åŒ…ä¸­ system éƒ¨åˆ† copy åˆ°äº† <code>transport/roots/system</code> ç›®å½•ä¸‹ï¼Œç”¨äºåˆ›å»ºç³»ç»Ÿä¿¡ä»»çš„ CA è¯ä¹¦æ± ï¼Œä½†æ²¡æœ‰å¯¹ Windows è¿›è¡Œå¤„ç†ï¼Œå¯¼è‡´åœ¨ Windows ä¸Šå‡ºç°æŠ¥é”™ã€‚</p>
<p>æˆ‘å¯¹å…¶è¿›è¡Œäº†æ›´æ”¹ï¼Œå…¶åŠŸèƒ½æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œä½†ä¸ä¼šå‡ºç°ç¼–è¯‘æŠ¥é”™ï¼š</p>
<pre><code class="language-go">// transport/roots/system.go

func NewSystem(_ map[string]string) ([]*x509.Certificate, error) {
	var certs []*x509.Certificate
	certpool, err := x509.SystemCertPool()
	if err != nil {
		// è¿”å› nilï¼Œå¦åˆ™ panic
		return nil, nil
	}
	for _, pem := range certpool.Subjects() {
		cert, err := helpers.ParseCertificatesPEM(pem)
		if err != nil {
			return nil, err
		}
		certs = append(certs, cert...)
	}
	return certs, nil
}
</code></pre>
<p>æŸ¥çœ‹ Golang å®˜æ–¹ x509 åŒ…ä¸­ï¼š</p>
<pre><code class="language-go">func SystemCertPool() (*CertPool, error) {
	if runtime.GOOS == "windows" {
		// Issue 16736, 18609:
		return nil, errors.New("crypto/x509: system root pool is not available on Windows")
	}
	...
	return loadSystemRoots()
}
</code></pre>
<p>Windows è·å–ä¸åˆ° system root poolã€‚</p>
<p>Linux ä¸­çš„ç³»ç»Ÿå†…ç½® CA è¯ä¹¦åœ¨ï¼š</p>
<pre><code class="language-go">// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x509

// Possible certificate files; stop after finding one.
var certFiles = []string{
    "/etc/ssl/certs/ca-certificates.crt",                // Debian/Ubuntu/Gentoo etc.
    "/etc/pki/tls/certs/ca-bundle.crt",                  // Fedora/RHEL 6
    "/etc/ssl/ca-bundle.pem",                            // OpenSUSE
    "/etc/pki/tls/cacert.pem",                           // OpenELEC
    "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem", // CentOS/RHEL 7
    "/etc/ssl/cert.pem",                                 // Alpine Linux
}
</code></pre>
<h5>2.3.2.2. è·å– CA è¯ä¹¦</h5>
<pre><code class="language-go">// transport/roots/provider.go

// A TrustStore contains a pool of certificate that are trusted for a
// given TLS configuration.
type TrustStore struct {
   roots map[string]*x509.Certificate
}

// New produces a new trusted root provider from a collection of
// roots. If there are no roots, the system roots will be used.
func New(rootDefs []*core.Root) (*TrustStore, error) {
	var err error

	var store = &#x26;TrustStore{}
	var roots []*x509.Certificate

    ...
    
	err = errors.New("transport: no supported root providers found")
	for _, root := range rootDefs {
		pfn, ok := Providers[root.Type]
		if ok {
			roots, err = pfn(root.Metadata)
			if err != nil {
				break
			}

			store.addCerts(roots)
		}
	}
	...
	return store, err
}
</code></pre>
<p>å½“æˆ‘ä»¬æ·»åŠ ä¸€ä¸ª CA è¯ä¹¦æ¥æºæ—¶ï¼Œç¨‹åºä¼šè°ƒç”¨ <code>Providers[root.Type]()</code> è·å– CA è¯ä¹¦ã€‚</p>
<p>æ”¯æŒçš„ CA è¯ä¹¦æ¥æºæœ‰ï¼š</p>
<pre><code class="language-go">// Providers is a mapping of supported providers and the functions
// that can build them.
var Providers = map[string]func(map[string]string) ([]*x509.Certificate, error){
	"system": NewSystem,
	"cfssl":  NewCFSSL,
	"file":   TrustPEM,
}
</code></pre>
<p>å…¶ä¸­ <em>cfssl</em> æºè·å– CA è¯ä¹¦æ–¹æ³•å¦‚ä¸‹ï¼š</p>
<pre><code class="language-go">// transport/roots/cfssl.go

// NewCFSSL produces a new CFSSL root.
func NewCFSSL(metadata map[string]string) ([]*x509.Certificate, error) {
	host, ok := metadata["host"]
	if !ok {
		return nil, errors.New("transport: CFSSL root provider requires a host")
	}

	label := metadata["label"]
	profile := metadata["profile"]
    // è¿™é‡Œè·å–ä¸åˆ°è¯ä¹¦ä¼šè¿”å› nilï¼Œä¸ä¼šæŠ¥é”™
	cert, err := helpers.LoadClientCertificate(metadata["mutual-tls-cert"], metadata["mutual-tls-key"])
	if err != nil {
		return nil, err
	}
    // è¿™é‡Œè·å–ä¸åˆ°è¯ä¹¦ä¼šè¿”å› nilï¼Œä¸ä¼šæŠ¥é”™
	remoteCAs, err := helpers.LoadPEMCertPool(metadata["tls-remote-ca"])
	if err != nil {
		return nil, err
	}
    // åˆ›å»º http/https å®¢æˆ·ç«¯
	srv := client.NewServerTLS(host, helpers.CreateTLSConfig(remoteCAs, cert))
	data, err := json.Marshal(info.Req{Label: label, Profile: profile})
	if err != nil {
		return nil, err
	}

    // è°ƒç”¨ "info" API æ¥å£
	resp, err := srv.Info(data)
	if err != nil {
		return nil, err
	}

	return helpers.ParseCertificatesPEM([]byte(resp.Certificate))
}
</code></pre>
<p>å®¢æˆ·ç«¯ä¼šè°ƒç”¨ 2.2.4.1 èŠ‚çš„æ¥å£ã€‚</p>
<h4>2.3.3. CA Provider</h4>
<p>åˆå Cert Providerã€‚</p>
<pre><code class="language-go">// A CertificateAuthority is capable of signing certificates given
// certificate signing requests.
type CertificateAuthority interface {
	// SignCSR submits a PKCS #10 certificate signing request to a
	// CA for signing.
	SignCSR(csrPEM []byte) (cert []byte, err error)

	// CACertificate returns the certificate authority's
	// certificate.
	CACertificate() (cert []byte, err error)
}
</code></pre>
<p>ç”¨äºä¸ CA è¿›è¡Œé€šä¿¡ã€‚</p>
<pre><code class="language-go">// transport/ca/cfssl_provider.go

// SignCSR requests a certificate from a CFSSL signer.
func (cap *CFSSL) SignCSR(csrPEM []byte) (cert []byte, err error) {
	p, _ := pem.Decode(csrPEM)
	if p == nil || p.Type != "CERTIFICATE REQUEST" {
		return nil, errors.New("transport: invalid PEM-encoded certificate signing request")
	}

	csr, err := x509.ParseCertificateRequest(p.Bytes)
	if err != nil {
		return nil, err
	}

	// åŸæ¥è¿™ä¸ªåœ°æ–¹ä¸æ”¯æŒ SAN URI
	hosts := make([]string, len(csr.DNSNames), len(csr.DNSNames)+len(csr.IPAddresses)+len(csr.URIs))
	copy(hosts, csr.DNSNames)

	for i := range csr.IPAddresses {
		hosts = append(hosts, csr.IPAddresses[i].String())
	}

	for i := range csr.URIs {
		hosts = append(hosts, csr.URIs[i].String())
	}

	sreq := &#x26;signer.SignRequest{
		Hosts:   hosts,
		Request: string(csrPEM),
		Profile: cap.Profile,
		Label:   cap.Label,
	}

	out, err := json.Marshal(sreq)
	if err != nil {
		return nil, err
	}

	if cap.provider != nil {
		return cap.remote.AuthSign(out, nil, cap.provider)
	}

	return cap.remote.Sign(out)
}
</code></pre>
<p>å‘ CA ä¸­å¿ƒå‘é€ CSR è¯·æ±‚ã€‚</p>
<h4>2.3.4. Key Provider</h4>
<pre><code class="language-go">// transport/kp/key_provider.go

// A KeyProvider provides some mechanism for managing private keys and
// certificates. It is not required to store the crypto.Signer itself.
type KeyProvider interface {
   // Certificate returns the associated certificate, or nil if
   // one isn't ready.
   Certificate() *x509.Certificate

   // Given some metadata about a certificate request, the
   // provider should be able to generate a new CSR.
   CertificateRequest(*csr.CertificateRequest) ([]byte, error)

   // Check returns an error if the provider has an invalid setup.
   Check() error

   // Generate should trigger the creation of a new private
   // key. This will invalidate any certificates stored in the
   // key provider.
   Generate(algo string, size int) error

   // Load causes a private key and certificate associated with
   // this provider to be loaded into memory and be prepared for
   // use.
   Load() error

   // Persistent returns true if the provider keeps state on disk.
   Persistent() bool

   // Ready returns true if the provider has a key and
   // certificate.
   Ready() bool

   // SetCertificatePEM takes a PEM-encoded certificate and
   // associates it with this key provider.
   SetCertificatePEM([]byte) error

   // SignalFailure is used to notify the KeyProvider that an
   // error has occurred obtaining a certificate. If this returns
   // true, the caller should re-attempt to refresh the
   // keys. This, for example, can be used to implement failover
   // key providers that require different keys.
   SignalFailure(err error) bool

   // SignCSR allows a templated CSR to be signed.
   SignCSR(csr *x509.CertificateRequest) ([]byte, error)

   // Store should perform whatever actions are necessary such
   // that a call to Load later will reload the key and
   // certificate associated with this provider.
   Store() error

   // X509KeyPair returns a tls.Certficate. The returns
   // tls.Certificate should have a parsed Leaf certificate.
   X509KeyPair() (tls.Certificate, error)
}
</code></pre>
<p>å¯ä»¥çœ‹åˆ° Key Provider æ˜¯ç»™ Workload ä»¥ç”Ÿæˆç§é’¥ã€CSRã€è¯·æ±‚è¯ä¹¦ã€æŒä¹…åŒ–çš„èƒ½åŠ›ã€‚</p>
<p>æˆ‘ä»¬å¯¹è¯¥ package è¿›è¡Œäº†æ”¹é€ ï¼Œåœ¨ä¸Šå±‚ï¼ˆCapitalizoneï¼‰è¿›è¡Œäº†é‡å†™ï¼Œä»¥é…åˆ SPIFFE ID å…±åŒå·¥ä½œã€‚</p>
<h4>2.3.5. ç”Ÿå‘½å‘¨æœŸ</h4>
<p><code>cfssl/transport</code> åŒ…æä¾›äº† mTLS è¿æ¥çš„å°è£…ï¼ŒåŒ…æ‹¬è¯ä¹¦è½®è½¬åŠŸèƒ½ã€‚</p>
<pre><code class="language-go">// transport/client.go

// A Transport is capable of providing transport-layer security using
// TLS.
type Transport struct {
	// Before defines how long before the certificate expires the
	// transport should start attempting to refresh the
	// certificate. For example, if this is 24h, then 24 hours
	// before the certificate expires the Transport will start
	// attempting to replace it.
	Before time.Duration

	// Provider contains a key management provider.
	Provider kp.KeyProvider

	// CA contains a mechanism for obtaining signed certificates.
	CA ca.CertificateAuthority

	// TrustStore contains the certificates trusted by this
	// transport.
	TrustStore *roots.TrustStore

	// ClientTrustStore contains the certificate authorities to
	// use in verifying client authentication certificates.
	ClientTrustStore *roots.TrustStore

	// Identity contains information about the entity that will be
	// used to construct certificates.
	Identity *core.Identity

	// Backoff is used to control the behaviour of a Transport
	// when it is attempting to automatically update a certificate
	// as part of AutoUpdate.
	Backoff *backoff.Backoff

	// RevokeSoftFail, if true, will cause a failure to check
	// revocation (such that the revocation status of a
	// certificate cannot be checked) to not be treated as an
	// error.
	RevokeSoftFail bool
}
</code></pre>
<p>è¿™é‡ŒåŒæ—¶å°†æè¿° mTLS é€šä¿¡çš„æ•´ä¸ªæµç¨‹ã€‚</p>
<h5>2.3.5.1. è·å–è¯ä¹¦</h5>
<blockquote>
<p>In a TLS handshake, the certificate presented by a remote server is sent alongside the <code>ServerHello</code> message. At this point in the connection, the remote server has received the <code>ClientHello</code> message, and that is all the information it needs to decide which certificate to present to the connecting client.</p>
</blockquote>
&#x3C;img src="https://diogomonica.com/content/images/2017/01/begining-tls-handshake-1.png" width="400" />
<p>ServerHello é˜¶æ®µä¼šä¼ è¾“è¯ä¹¦ï¼Œè¿™é‡Œæ¶‰åŠåˆ°ä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•çƒ­æ›´æ–°è¯ä¹¦ã€‚</p>
<blockquote>
<p>It turns out that Go supports passing a callback in a TLS Config that will get executed every time a TLS <code>ClientHello</code> is sent by a remote peer. This method is conveniently called <code>GetCertificate</code>, and it returns the certificate we wish to use for that particular TLS handshake.</p>
<p>The idea of <code>GetCertificate</code> is to allow the dynamic  selection of which certificate to provide to a particular remote peer.  This method can be used to support virtual hosts, where one web server  is responsible for multiple domains, and therefore has to choose the  appropriate certificate to return to each remote peer.</p>
</blockquote>
<p>Golang çš„ tls åŒ…æä¾›äº†è·å–è¯ä¹¦çš„å‡½æ•°æ”¯æŒï¼š</p>
<pre><code class="language-go">    // GetCertificate returns a Certificate based on the given
    // ClientHelloInfo. It will only be called if the client supplies SNI
    // information or if Certificates is empty.
    //
    // If GetCertificate is nil or returns nil, then the certificate is
    // retrieved from NameToCertificate. If NameToCertificate is nil, the
    // best element of Certificates will be used.
    GetCertificate func(*ClientHelloInfo) (*Certificate, error) // Go 1.4

    // GetClientCertificate, if not nil, is called when a server requests a
    // certificate from a client. If set, the contents of Certificates will
    // be ignored.
    //
    // If GetClientCertificate returns an error, the handshake will be
    // aborted and that error will be returned. Otherwise
    // GetClientCertificate must return a non-nil Certificate. If
    // Certificate.Certificate is empty then no certificate will be sent to
    // the server. If this is unacceptable to the server then it may abort
    // the handshake.
    //
    // GetClientCertificate may be called multiple times for the same
    // connection if renegotiation occurs or if TLS 1.3 is in use.
    GetClientCertificate func(*CertificateRequestInfo) (*Certificate, error) // Go 1.8
</code></pre>
<p>æ¯æ¬¡ TLS æ¡æ‰‹æ—¶ï¼Œ<code>GetCertificate</code> / <code>GetClientCertificate</code> æ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼Œæˆ‘ä»¬èƒ½å¤Ÿå®ç°è¿™ä¸ªæ–¹æ³•ï¼ŒåŠ¨æ€æ›´æ–°è¯ä¹¦ã€‚</p>
<p><a href="https://diogomonica.com/2017/01/11/hitless-tls-certificate-rotation-in-go/">ç¤ºä¾‹ä»£ç </a>ï¼š</p>
<pre><code class="language-go">type wrappedCertificate struct {
	sync.Mutex
	certificate *tls.Certificate
}

func (c *wrappedCertificate) getCertificate(clientHello *tls.ClientHelloInfo) (*tls.Certificate, error) {
	c.Lock()
	defer c.Unlock()

	return c.certificate, nil
}
</code></pre>
&#x3C;img src="https://diogomonica.com/content/images/2017/01/golang-new-certificate-being-served.png" height="400" />
<blockquote>
<p>Old established connections using the previous certificate will remain  active, but new connections coming in to our TLS server will use the  most recent certificate.</p>
</blockquote>
<h5>2.3.5.2. è¯ä¹¦è½®è½¬</h5>
<pre><code class="language-go">// transport/client.go

// AutoUpdate will automatically update the listener. If a non-nil
// certUpdates chan is provided, it will receive timestamps for
// reissued certificates. If errChan is non-nil, any errors that occur
// in the updater will be passed along.
func (tr *Transport) AutoUpdate(certUpdates chan&#x3C;- time.Time, errChan chan&#x3C;- error) {
	defer func() {
		if r := recover(); r != nil {
			log.Criticalf("AutoUpdate panicked: %v", r)
		}
	}()

	for {
		// Wait until it's time to update the certificate.
		target := time.Now().Add(tr.Lifespan())
		if PollInterval == 0 {
			&#x3C;-time.After(tr.Lifespan())
		} else {
			pollWait(target)
		}

		// Keep trying to update the certificate until it's
		// ready.
		for {
			log.Debugf("attempting to refresh keypair")
			err := tr.RefreshKeys()
			if err == nil {
				break
			}

			delay := tr.Backoff.Duration()
			log.Debugf("failed to update certificate, will try again in %s", delay)
			if errChan != nil {
				errChan &#x3C;- err
			}

			&#x3C;-time.After(delay)
		}

		log.Debugf("certificate updated")
		if certUpdates != nil {
			certUpdates &#x3C;- time.Now()
		}

		tr.Backoff.Reset()
	}
}
</code></pre>
<p>è¯¥æ–¹æ³•ä¼šä¿æŒä¸€ä¸ªåç¨‹è¿è¡Œï¼Œæ£€æŸ¥è¯ä¹¦æœ‰æ•ˆæ—¶é—´ï¼Œå®šæ—¶æ›´æ–°è¯ä¹¦ã€‚</p>
<h5>2.3.5.3. CA è¯ä¹¦è®¤è¯</h5>
<pre><code class="language-go">// transport/client.go

// TLSClientAuthClientConfig returns a new client authentication TLS
// configuration that can be used for a client using client auth
// connecting to the named host.
func (tr *Transport) TLSClientAuthClientConfig(host string) (*tls.Config, error) {
	cert, err := tr.getCertificate()
	if err != nil {
		return nil, err
	}

	return &#x26;tls.Config{
		Certificates: []tls.Certificate{cert},
		RootCAs:      tr.TrustStore.Pool(),
		ServerName:   host,
		CipherSuites: core.CipherSuites,
		MinVersion:   tls.VersionTLS12,
		ClientAuth:   tls.RequireAndVerifyClientCert,
	}, nil
}

// TLSClientAuthServerConfig returns a new client authentication TLS
// configuration for servers expecting mutually authenticated
// clients. The clientAuth parameter should contain the root pool used
// to authenticate clients.
func (tr *Transport) TLSClientAuthServerConfig() (*tls.Config, error) {
	logger.DEBUG.Print("------------------------ è·å–æœåŠ¡å™¨è¯ä¹¦")
	cert, err := tr.getCertificate()
	if err != nil {
		return nil, err
	}

	logger.DEBUG.Print("------------------------ OK æœåŠ¡å™¨è¯ä¹¦")
	return &#x26;tls.Config{
		Certificates: []tls.Certificate{cert},
		RootCAs:      tr.TrustStore.Pool(),
		ClientCAs:    tr.ClientTrustStore.Pool(),
		ClientAuth:   tls.RequireAndVerifyClientCert,
		CipherSuites: core.CipherSuites,
		MinVersion:   tls.VersionTLS12,
	}, nil
}
</code></pre>
<p>Server ç«¯å’Œ Client ç«¯çš„åŒºåˆ«åœ¨äºï¼š</p>
<ol>
<li>Server ç«¯ <code>tls.Config</code> éœ€è¦ <code>ClientCAs</code> å‚æ•°</li>
<li>Client ç«¯éœ€è¦ <code>ServerName</code> å‚æ•°</li>
</ol>
<p>Server ç«¯çš„  <code>ClientCAs</code> å’Œ Client ç«¯çš„ <code>RootCAs</code> éœ€è¦åŒ…å« Root CA å’Œ ICA è¯ä¹¦ã€‚</p>
<h5>2.3.5.4. è¯ä¹¦éªŒè¯</h5>
<p>é™¤äº†ä¸€èˆ¬çš„è¯ä¹¦æ ¡éªŒä»¥å¤–ï¼ŒIstio è¿˜é€šè¿‡è‡ªå®šä¹‰æ ¡éªŒæ–¹æ³•ï¼Œè¿›è¡Œäº† SPIFFE ID çš„éªŒè¯ã€‚</p>
<pre><code class="language-go">    // VerifyPeerCertificate, if not nil, is called after normal
    // certificate verification by either a TLS client or server. It
    // receives the raw ASN.1 certificates provided by the peer and also
    // any verified chains that normal processing found. If it returns a
    // non-nil error, the handshake is aborted and that error results.
    //
    // If normal verification fails then the handshake will abort before
    // considering this callback. If normal verification is disabled by
    // setting InsecureSkipVerify, or (for a server) when ClientAuth is
    // RequestClientCert or RequireAnyClientCert, then this callback will
    // be considered but the verifiedChains argument will always be nil.
    VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error // Go 1.8

    // VerifyConnection, if not nil, is called after normal certificate
    // verification and after VerifyPeerCertificate by either a TLS client
    // or server. If it returns a non-nil error, the handshake is aborted
    // and that error results.
    //
    // If normal verification fails then the handshake will abort before
    // considering this callback. This callback will run for all connections
    // regardless of InsecureSkipVerify or ClientAuth settings.
    VerifyConnection func(ConnectionState) error // Go 1.15
</code></pre>
<p><code>VerifyPeerCertificate</code> é‡Œèƒ½å¤Ÿæä¾› SPIFFE çš„è®¤è¯ï¼Œ<code>VerifyConnection</code> èƒ½å¤Ÿé€šè¿‡ SDK æä¾›è‡ªå®šä¹‰è®¤è¯ã€‚</p></article><script src="/_next/static/chunks/webpack-072f062dc024cc52.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5803,[],\"\"]\n3:I[695,[],\"\"]\n5:I[2576,[],\"OutletBoundary\"]\n7:I[2576,[],\"MetadataBoundary\"]\n9:I[2576,[],\"ViewportBoundary\"]\nb:I[7614,[],\"\"]\n:HL[\"/_next/static/css/c3b55921f92a131e.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"n66w3jQXdD0TOkFlxRfSe\",\"p\":\"\",\"c\":[\"\",\"2021\",\"11\",\"cfssl-%25E6%25A0%25B8%25E5%25BF%2583%25E6%25A8%25A1%25E5%259D%2597%25E5%2588%2586%25E6%259E%2590\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(posts)\",{\"children\":[[\"year\",\"2021\",\"d\"],{\"children\":[[\"month\",\"11\",\"d\"],{\"children\":[[\"slug\",\"cfssl-%25E6%25A0%25B8%25E5%25BF%2583%25E6%25A8%25A1%25E5%259D%2597%25E5%2588%2586%25E6%259E%2590\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c3b55921f92a131e.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"(posts)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:style\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:1:props:style\",\"children\":404}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:2:props:style\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:2:props:children:props:style\",\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"year\",\"2021\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"month\",\"11\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"cfssl-%25E6%25A0%25B8%25E5%25BF%2583%25E6%25A8%25A1%25E5%259D%2597%25E5%2588%2586%25E6%259E%2590\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"3khdmbivPA7JrEzH2HTgF\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],null]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Mayo Rocks!\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Mayo's Blog\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/icon.png?14d5a92fbe70e82a\",\"type\":\"image/png\",\"sizes\":\"460x460\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script><script>self.__next_f.push([1,"c:T1043b,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e1. æ¦‚è¿°\u003c/h2\u003e\n\u003ch3\u003e1.1. é¡¹ç›®ç®€ä»‹\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e æ˜¯ Cloudflare çš„ PKIï¼Œä¹Ÿæ˜¯è¯ä¹¦ç”Ÿæˆçš„å·¥å…·é“¾ã€‚\u003cem\u003ecfssl\u003c/em\u003e ä½œä¸ºè¯ä¹¦ç”Ÿæˆçš„å·¥å…·é“¾å¯èƒ½æ›´ä¸ºäººç†ŸçŸ¥ï¼ŒGoogle ä¸Šæœç´¢åˆ°çš„å…³äº \u003cem\u003ecfssl\u003c/em\u003e çš„ä»‹ç»ä»¥åŠä½¿ç”¨éƒ½æ˜¯å…³äºä½¿ç”¨ CLI ç”Ÿæˆè‡ªç­¾åè¯ä¹¦çš„ï¼Œå‡ ä¹æ²¡æœ‰é’ˆå¯¹ \u003cem\u003ecfssl\u003c/em\u003e ä½œä¸º CA ä¸­å¿ƒçš„ä»‹ç»ã€‚\u003c/p\u003e\n\u003cp\u003eä» commit å†å²æ¥çœ‹è¿™æ˜¯ä¸€ä¸ª 7 å¹´å‰å°±å¯åŠ¨çš„é¡¹ç›®ï¼Œé¡¹ç›®ä¸­çš„æ–‡æ¡£å¤§éƒ¨åˆ†è¿˜æ˜¯ \u003cem\u003e.txt\u003c/em\u003e åç¼€çš„çº¯æ–‡æœ¬ã€‚ä½†æ˜¯é¡¹ç›®çš„å®Œæˆåº¦å¾ˆé«˜ï¼Œå†…éƒ¨ CA å®ç°äº†å¤šå±‚çº§ï¼Œèƒ½å¤Ÿå¼•å…¥å¤–éƒ¨ CAï¼ŒåŒ…æ‹¬æä¾›äº†è°ƒç”¨ CA API çš„ Go çš„ Client åŒ…ï¼Œä»¥åŠç”¨äºè¯ä¹¦è½®æ¢çš„ KeyProvider packageã€‚\u003c/p\u003e\n\u003cp\u003eä»¥åŠæœ‰ Cloudflare å®˜æ–¹çš„ certmgr é¡¹ç›®ï¼Œç”¨äºåœ¨ K8s é›†ç¾¤ä¸­ä½¿ç”¨ cfssl è‡ªåŠ¨ç­¾å‘è¯ä¹¦ï¼Œè¯¥é¡¹ç›®æè¿°ä¸­æåˆ°åœ¨ CF çš„ç”Ÿæˆç¯å¢ƒä½¿ç”¨ã€‚è¯´åˆ°æ­¤å¤„æœ¬äººæƒ³åˆ° CF åœ¨å…¶åŸŸåæ‰˜ç®¡çš„æœåŠ¡ä¸­æœ‰å…è´¹ TLS è¯ä¹¦ç”Ÿæˆï¼ŒåŒ…å« Originã€Browser è¯ä¹¦ï¼Œæˆ–è®¸æ˜¯ä½¿ç”¨è¯¥é¡¹ç›®è¿›è¡Œç”Ÿæˆçš„ã€‚\u003c/p\u003e\n\u003cp\u003eä½†æ˜¯é¡¹ç›®æ›´æ–°é€Ÿåº¦æ¯”è¾ƒæ…¢ï¼Œæœ¬äººæçš„ 2 ä¸ª Pull Request ç­‰äº†ä¸€å‘¨åªè¢«åˆå¹¶äº†ä¸€ä¸ªï¼Œå¦ä¸€ä¸ª feature ç±»å‹çš„ PR è¿˜åœ¨ç­‰å¾…å®¡æ ¸ã€‚\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eIstio\u003c/em\u003e æœ€å¼€å§‹ä¹Ÿæ˜¯ä½¿ç”¨ \u003cem\u003ecfssl\u003c/em\u003e ç”Ÿæˆè‡ªç­¾å CA è¯ä¹¦ï¼Œä½†æ˜¯ç”±äº \u003cem\u003eIstio\u003c/em\u003e å†…éƒ¨éœ€è¦å®ç° SDS åè®®ã€å…¼å®¹ SPIFFE ID æ ‡å‡†ï¼Œåœ¨åç»­çš„è¿­ä»£ä¸­ä½¿ç”¨äº†è‡ªå·±çš„ PKI å°†å…¶æ›¿æ¢äº†ã€‚\u003c/p\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e å®˜æ–¹ master åˆ†æ”¯çš„ä»£ç ä¸èƒ½å®Œå…¨æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œä¾‹å¦‚ä¸å…¼å®¹ SAN URI å­—æ®µçš„è¯ä¹¦ç­¾å‘ï¼Œè¯ä¹¦è½®æ¢å®¢æˆ·ç«¯ä½¿ç”¨è¿‡äºç¹çâ€¦â€¦ä½†æ˜¯åŸºäº \u003cem\u003ecfssl\u003c/em\u003e æˆ‘ä»¬èƒ½å¤Ÿå¿«é€Ÿå®ç°ä¸€ä¸ªä¸šç•Œæ ‡å‡†çš„ï¼Œå®Œå¤‡çš„ PKIã€CA ä¸­å¿ƒã€‚\u003c/p\u003e\n\u003ch3\u003e1.2. é¡¹ç›®ç»“æ„\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e ç”±ä¸€ç»„ç»„å·¥å…·åŒ…ç»„æˆï¼ŒåŠŸèƒ½è¾ƒä¸ºç‹¬ç«‹ï¼Œå› æ­¤ä¹Ÿèƒ½å¤Ÿæ–¹ä¾¿çš„ä»å…¶ä»–é¡¹ç›®å¼•ç”¨è¿™äº›åŒ…ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ tree -d -L 1 -A\n.\nâ”œâ”€â”€ api\nâ”œâ”€â”€ auth\nâ”œâ”€â”€ bundler\nâ”œâ”€â”€ certdb\nâ”œâ”€â”€ certinfo\nâ”œâ”€â”€ cli\nâ”œâ”€â”€ cmd\nâ”œâ”€â”€ config\nâ”œâ”€â”€ crl\nâ”œâ”€â”€ crypto\nâ”œâ”€â”€ csr\nâ”œâ”€â”€ doc\nâ”œâ”€â”€ errors\nâ”œâ”€â”€ helpers\nâ”œâ”€â”€ info\nâ”œâ”€â”€ initca\nâ”œâ”€â”€ log\nâ”œâ”€â”€ multiroot\nâ”œâ”€â”€ ocsp\nâ”œâ”€â”€ revoke\nâ”œâ”€â”€ scan\nâ”œâ”€â”€ selfsign\nâ”œâ”€â”€ signer\nâ”œâ”€â”€ testdata\nâ”œâ”€â”€ transport\nâ”œâ”€â”€ ubiquity\nâ”œâ”€â”€ vendor\nâ””â”€â”€ whitelist\n\n28 directories\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. æºç åˆ†æ\u003c/h2\u003e\n\u003cp\u003eç”±äºå¸‚é¢ä¸Šçš„ Golang PKI ç¨‹åºç›®å½•ç»“æ„éƒ½æ˜¯ä¸€ä¸ªä¸ªåŒ…ç»„æˆçš„ï¼Œä¾‹å¦‚ \u003ca href=\"https://github.com/letsencrypt/boulder\"\u003eletsencrypt/boulder\u003c/a\u003e é¡¹ç›®ï¼Œè¿™é‡Œé€šè¿‡æµç¨‹åˆ†ææ›´æ¸…æ™°ã€‚\u003c/p\u003e\n\u003ch3\u003e2.0. æ¶æ„è®¾è®¡\u003c/h3\u003e\n\u003ch4\u003e2.0.1. Profiles\u003c/h4\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e çš„é…ç½®ä»¥ \u003cem\u003eprofile\u003c/em\u003e åŒºåˆ†ï¼Œè¿™é‡Œçœ‹ä¸€ä¸ª\u003cstrong\u003eCA ä¸­å¿ƒ\u003c/strong\u003eç¤ºä¾‹é…ç½®ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"signing\": {\n    \"default\": {\n      \"expiry\": \"168h\"\n    },\n    \"profiles\": {\n      \"client\": {\n        \"expiry\": \"1h\",\n        \"usages\": [\n          \"signing\",\n          \"key encipherment\",\n          \"client auth\"\n        ]\n      },\n      \"server\": {\n        \"expiry\": \"1h\",\n        \"usages\": [\n          \"signing\",\n          \"key encipherment\",\n          \"server auth\"\n        ]\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ ¹æ® profile name åŒºåˆ†ä¸åŒçš„ç­¾åç±»å‹ã€‚\u003c/p\u003e\n\u003cp\u003eæˆ‘ä»¬å†æ¥çœ‹é€šè¿‡ SDK è¿æ¥ CA ä¸­å¿ƒçš„é…ç½®æ–‡ä»¶ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"request\": {\n    \"CN\": \"test server\",\n    \"hosts\": [\n      \"127.0.0.1\"\n    ]\n  },\n  \"profiles\": {\n    \"paths\": {\n      \"private_key\": \"server.key\",\n      \"certificate\": \"server.pem\"\n    },\n    \"cfssl\": {\n      \"profile\": \"server\",\n      \"remote\": \"127.0.0.1:8888\"\n    }\n  },\n  \"roots\": [\n    {\n      \"type\": \"system\"\n    }\n  ],\n  \"client_roots\": [\n    {\n      \"type\": \"cfssl\",\n      \"metadata\": {\n        \"host\": \"127.0.0.1:8888\",\n        \"profile\": \"client\"\n      }\n    }\n  ]\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCA ä¸­å¿ƒä¼šæ ¹æ® profile ä¸åŒï¼Œä½¿ç”¨ä¸åŒçš„é…ç½®å»å¤„ç†è¯·æ±‚ã€ç­¾å‘è¯ä¹¦ã€‚\u003c/p\u003e\n\u003ch4\u003e2.0.2. è®¤è¯ä½“ç³»\u003c/h4\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e æ”¯æŒä½¿ç”¨ mTLSï¼Œä»¥åŠ Auth Key æ¥è¿›è¡Œèº«ä»½éªŒè¯ã€‚\u003c/p\u003e\n\u003cp\u003eå…¶ä¸­ Auth Key æ”¯æŒ \u003ccode\u003estandard\u003c/code\u003e å’Œ \u003ccode\u003estandard-ip\u003c/code\u003e ä¸¤ç§ç±»å‹ã€‚\u003c/p\u003e\n\u003cp\u003eCA ä¸­å¿ƒé…ç½®ç¤ºä¾‹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"auth_keys\": {\n    \"client\": {\n      \"type\": \"standard\",\n      \"key\": \"52abb3ac91971bb72bce17e7a289cd04476490b19e0d8eb7810dc42d4ac16c41\"\n    },\n    \"server\": {\n      \"type\": \"standard\",\n      \"key\": \"4f4f26686209f672e0ec7b19cbbc8b6d94fdd12cc0b20326f9005d5f234e6e3e\"\n    }\n  },\n  \"signing\": {\n    \"default\": {\n      \"expiry\": \"168h\"\n    },\n    \"profiles\": {\n      \"client\": {\n        \"auth_key\": \"client\",\n        \"expiry\": \"1h\",\n        \"usages\": [\n          \"signing\",\n          \"key encipherment\",\n          \"client auth\"\n        ]\n      },\n      \"server\": {\n        \"auth_key\": \"server\",\n        \"expiry\": \"8760h\",\n        \"usages\": [\n          \"signing\",\n          \"key encipherment\",\n          \"server auth\"\n        ]\n      }\n    }\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSDK å®¢æˆ·ç«¯é…ç½®ç¤ºä¾‹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"request\": {\n    \"CN\": \"test server\",\n    \"hosts\": [\"127.0.0.1\"]\n  },\n  \"profiles\": {\n    \"paths\": {\n      \"private_key\": \"server.key\",\n      \"certificate\": \"server.pem\"\n    },\n    \"cfssl\": {\n      \"profile\": \"server\",\n      \"remote\": \"127.0.0.1:8888\",\n      \"auth-type\": \"standard\",\n      \"auth-key\": \"4f4f26686209f672e0ec7b19cbbc8b6d94fdd12cc0b20326f9005d5f234e6e3e\"\n    }\n  },\n  \"roots\": [{\n    \"type\": \"system\"\n  }],\n  \"client_roots\": [{\n    \"type\": \"cfssl\",\n    \"metadata\": {\n      \"host\": \"127.0.0.1:8888\",\n      \"profile\": \"client\"\n    }\n  }]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2.1. è¯ä¹¦ç®¡ç†\u003c/h3\u003e\n\u003cp\u003eæˆ‘ä»¬ä»ä¸€ç»„å®˜æ–¹ç»™å‡ºçš„ç¤ºä¾‹ shell å½“ä½œå…¥å£æ¥çœ‹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/sh\n\ncfssl gencert -initca ca.json | cfssljson -bare ca\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eca.json\u003c/code\u003e æ–‡ä»¶å†…å®¹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"hosts\": [\n    \"dropsonde.net\"\n  ],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 4096\n  },\n  \"names\": [\n    {\n      \"C\": \"US\",\n      \"L\": \"San Francisco\",\n      \"OU\": \"Dropsonde Certificate Authority\",\n      \"ST\": \"California\"\n    }\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecfssl gencert\u003c/code\u003e å‘½ä»¤æ³¨é‡Šï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003evar gencertUsageText = `cfssl gencert -- generate a new key and signed certificate\n\nUsage of gencert:\n    Generate a new key and cert from CSR:\n        cfssl gencert -initca CSRJSON\n        cfssl gencert -ca cert -ca-key key [-config config] [-profile profile] [-hostname hostname] CSRJSON\n        cfssl gencert -remote remote_host [-config config] [-profile profile] [-label label] [-hostname hostname] CSRJSON\n\n    Re-generate a CA cert with the CA key and CSR:\n        cfssl gencert -initca -ca-key key CSRJSON\n\n    Re-generate a CA cert with the CA key and certificate:\n        cfssl gencert -renewca -ca cert -ca-key key\n\nArguments:\n        CSRJSON:    JSON file containing the request, use '-' for reading JSON from stdin\n\nFlags:\n`\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.1.1. ç”Ÿæˆç§é’¥\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003e-initca\u003c/code\u003e å‚æ•°è¡¨ç¤ºæ˜¯ CAã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// cli/gencert/gencert.go\n\n// åˆ›å»ºé»˜è®¤ CSR è¯·æ±‚\nreq := csr.CertificateRequest{\n   // é»˜è®¤ä½¿ç”¨ ecdsa, 256 ç”Ÿæˆ private key\n   KeyRequest: csr.NewKeyRequest(),\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e ä¸­é»˜è®¤ä½¿ç”¨ ECDSA with \u003cem\u003ecurve P-256\u003c/em\u003e ç®—æ³•ç”Ÿæˆç§é’¥ã€‚\u003c/p\u003e\n\u003cp\u003eä»¥ä¸‹æ‘˜è‡ª \u003ca href=\"https://tools.ietf.org/html/rfc6605\"\u003erfc6605\u003c/a\u003e (Elliptic Curve Digital Signature Algorithm (DSA) for DNSSEC)\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCurrent estimates are that ECDSA with curve P-256 has an approximate\nequivalent strength to RSA with 3072-bit keys.  Using ECDSA with\ncurve P-256 in DNSSEC has some advantages and disadvantages relative\nto using RSA with SHA-256 and with 3072-bit keys.  ECDSA keys are\nmuch shorter than RSA keys; at this size, the difference is 256\nversus 3072 bits.  Similarly, ECDSA signatures are much shorter than\nRSA signatures.  This is relevant because DNSSEC stores and transmits\nboth keys and signatures.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn the two signing algorithms defined in this document, the size of\nthe key for the elliptic curve is matched with the size of the output\nof the hash algorithm.  This design is based on the widespread belief\nthat the equivalent strength of P-256 and P-384 is half the length of\nthe key, and also that the equivalent strength of SHA-256 and SHA-384\nis half the length of the key.  Using matched strengths prevents an\nattacker from choosing the weaker half of a signature algorithm.  For\nexample, in a signature that uses RSA with 2048-bit keys and SHA-256,\nthe signing portion is significantly weaker than the hash portion,\nwhereas the two algorithms here are balanced.\u003c/p\u003e\n\u003cp\u003eSigning with ECDSA is significantly faster than with RSA (over 20\ntimes in some implementations).  However, validating RSA signatures\nis significantly faster than validating ECDSA signatures (about 5\ntimes faster in some implementations).\u003c/p\u003e\n\u003cp\u003eECDSA with curve P-256 ä¸ RSA with SHA-256 å¼ºåº¦ç›¸å½“ï¼›å‰è€…ç­¾åé€Ÿåº¦å¿«äºåè€…ï¼Œåè€…éªŒè¯é€Ÿåº¦å¿«äºå‰è€…ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// csr/csr.go\n\n// Generate generates a key as specified in the request. Currently,\n// only ECDSA and RSA are supported.\nfunc (kr *KeyRequest) Generate() (crypto.PrivateKey, error) {\n\tlog.Debugf(\"generate key from request: algo=%s, size=%d\", kr.Algo(), kr.Size())\n\tswitch kr.Algo() {\n\tcase \"rsa\":\n\t\tif kr.Size() \u0026#x3C; 2048 {\n\t\t\treturn nil, errors.New(\"RSA key is too weak\")\n\t\t}\n\t\tif kr.Size() \u003e 8192 {\n\t\t\treturn nil, errors.New(\"RSA key size too large\")\n\t\t}\n\t\treturn rsa.GenerateKey(rand.Reader, kr.Size())\n\tcase \"ecdsa\":\n\t\tvar curve elliptic.Curve\n\t\tswitch kr.Size() {\n\t\tcase curveP256:\n\t\t\tcurve = elliptic.P256()\n\t\tcase curveP384:\n\t\t\tcurve = elliptic.P384()\n\t\tcase curveP521:\n\t\t\tcurve = elliptic.P521()\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"invalid curve\")\n\t\t}\n\t\t// è°ƒç”¨å®˜æ–¹åŒ…ç”Ÿæˆç§é’¥\n\t\treturn ecdsa.GenerateKey(curve, rand.Reader)\n\tdefault:\n\t\treturn nil, errors.New(\"invalid algorithm\")\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eç§é’¥è½¬æ¢ä¸º PEM æ ¼å¼ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// csr/csr.go\n\n\t// ç§é’¥è½¬æ¢æˆ pem æ ¼å¼\n\tswitch priv := priv.(type) {\n\tcase *rsa.PrivateKey:\n\t\tkey = x509.MarshalPKCS1PrivateKey(priv)\n\t\tblock := pem.Block{\n\t\t\tType:  \"RSA PRIVATE KEY\",\n\t\t\tBytes: key,\n\t\t}\n\t\tkey = pem.EncodeToMemory(\u0026#x26;block)\n\tcase *ecdsa.PrivateKey:\n\t\tkey, err = x509.MarshalECPrivateKey(priv)\n\t\tif err != nil {\n\t\t\terr = cferr.Wrap(cferr.PrivateKeyError, cferr.Unknown, err)\n\t\t\treturn\n\t\t}\n\t\tblock := pem.Block{\n\t\t\tType:  \"EC PRIVATE KEY\",\n\t\t\tBytes: key,\n\t\t}\n\t\tkey = pem.EncodeToMemory(\u0026#x26;block)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.1.2. ç”Ÿæˆ CSR\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ecsr, err = Generate(priv.(crypto.Signer), req)\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// æ ¹æ®ç§é’¥å’Œè¯·æ±‚å‚æ•°ç”Ÿæˆæ ‡å‡† CSR\n// Generate creates a new CSR from a CertificateRequest structure and\n// an existing key. The KeyRequest field is ignored.\nfunc Generate(priv crypto.Signer, req *CertificateRequest) (csr []byte, err error) {\n\t// è·å– x509 ç­¾åç®—æ³•\n\tsigAlgo := helpers.SignerAlgo(priv)\n\tif sigAlgo == x509.UnknownSignatureAlgorithm {\n\t\treturn nil, cferr.New(cferr.PrivateKeyError, cferr.Unavailable)\n\t}\n\n\t// csr æ¨¡æ¿\n\tvar tpl = x509.CertificateRequest{\n\t\tSubject:            req.Name(), // å¡«å…… subject å­—æ®µ\n\t\tSignatureAlgorithm: sigAlgo,\n\t}\n\n\t// è§£æå¡«å…… SAN å­—æ®µ\n\tfor i := range req.Hosts {\n\t\tif ip := net.ParseIP(req.Hosts[i]); ip != nil {\n\t\t\ttpl.IPAddresses = append(tpl.IPAddresses, ip)\n\t\t} else if email, err := mail.ParseAddress(req.Hosts[i]); err == nil \u0026#x26;\u0026#x26; email != nil {\n\t\t\ttpl.EmailAddresses = append(tpl.EmailAddresses, email.Address)\n\t\t} else if uri, err := url.ParseRequestURI(req.Hosts[i]); err == nil \u0026#x26;\u0026#x26; uri != nil {\n\t\t\ttpl.URIs = append(tpl.URIs, uri)\n\t\t} else {\n\t\t\ttpl.DNSNames = append(tpl.DNSNames, req.Hosts[i])\n\t\t}\n\t}\n\n\ttpl.ExtraExtensions = []pkix.Extension{}\n\n    ...\n\n\t// è°ƒç”¨ x509 åŒ…ç”Ÿæˆ csr\n\tcsr, err = x509.CreateCertificateRequest(rand.Reader, \u0026#x26;tpl, priv)\n\tif err != nil {\n\t\tlog.Errorf(\"failed to generate a CSR: %v\", err)\n\t\terr = cferr.Wrap(cferr.CSRError, cferr.BadRequest, err)\n\t\treturn\n\t}\n\tblock := pem.Block{\n\t\tType:  \"CERTIFICATE REQUEST\",\n\t\tBytes: csr,\n\t}\n\n\tlog.Info(\"encoded CSR\")\n\t// ç”Ÿæˆ pem æ ¼å¼ csr\n\tcsr = pem.EncodeToMemory(\u0026#x26;block)\n\treturn\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecsr.Generate()\u003c/code\u003e æ¥æ”¶çš„ Request å‚æ•°å®é™…ä¸Šæ˜¯ä½œä¸º CSR çš„æ¨¡æ¿ã€‚\u003c/p\u003e\n\u003cp\u003eæ­¤å¤„ä¸ Istio PKI ä¸­ç”Ÿæˆ CSR çš„å‡½æ•°ç›¸ä¼¼ï¼Œæ„Ÿå…´è¶£çš„ä¹Ÿå¯ä»¥æŸ¥çœ‹æœ¬äººçš„ã€ŠIstio å®‰å…¨æ¨¡å—è§£æã€‹æ–‡æ¡£ã€‚\u003c/p\u003e\n\u003cp\u003eå®é™…å¼€å‘è¿‡ç¨‹ä¸­å‘ç°æ­¤å¤„æœ‰å‘ï¼Œ\u003cem\u003ecfssl\u003c/em\u003e æ­¤å¤„è™½ç„¶æ”¯æŒäº† SAN URI çš„å­—æ®µï¼Œä½†æ˜¯åœ¨é€šè¿‡ cfssl CA Provider å‘é€ CSRã€€è¯·æ±‚è¯ä¹¦çš„æ—¶å€™ï¼Œå…¶æœåŠ¡ç«¯ä¸æ”¯æŒ SAN URI å­—æ®µåˆ°è¯ä¹¦çš„å¡«å……ã€‚é’ˆå¯¹è¿™ä¸€ç‚¹æˆ‘å·²ç»æäº¤äº† Pull Requstã€‚\u003c/p\u003e\n\u003cp\u003eæˆ‘ä»¬åœ¨å®é™…å¼€å‘ä¸­ï¼Œä½¿ç”¨åˆ›å»º CSR è¯·æ±‚çš„åŒ…æ˜¯æ¥è‡ª Istio PKI çš„ï¼Œå…¶æä¾›äº†æ›´ä¾¿æ·çš„ä½¿ç”¨æ–¹å¼ã€‚\u003c/p\u003e\n\u003ch4\u003e2.1.3. Signer\u003c/h4\u003e\n\u003ch5\u003e2.1.3.1. æœ¬åœ°è‡ªç­¾å\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// initca/initca.go\n\n// åˆ›å»ºæœ¬åœ°è‡ªç­¾å signer\ns, err := local.NewSigner(priv, nil, signer.DefaultSigAlgo(priv), policy)\nif err != nil {\n\tlog.Errorf(\"failed to create signer: %v\", err)\n\treturn\n}\n\nsignReq := signer.SignRequest{Hosts: req.Hosts, Request: string(csrPEM)}\ncert, err = s.Sign(signReq)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e2.1.3.2. Universal\u003c/h5\u003e\n\u003cp\u003eè®¾ç½® Remote CAï¼Œæˆ–é€šè¿‡ Server å¯åŠ¨æ—¶ï¼Œä¼šåˆ›å»º Universal Signerã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// SignerFromConfigAndDB takes the Config and creates the appropriate\n// signer.Signer object with a specified db\nfunc SignerFromConfigAndDB(c cli.Config, db *sqlx.DB) (signer.Signer, error) {\n   // If there is a config, use its signing policy. Otherwise create a default policy.\n   var policy *config.Signing\n   if c.CFG != nil {\n      policy = c.CFG.Signing\n   } else {\n      policy = \u0026#x26;config.Signing{\n         Profiles: map[string]*config.SigningProfile{},\n         Default:  config.DefaultConfig(),\n      }\n   }\n\n   // Make sure the policy reflects the new remote\n   if c.Remote != \"\" {\n      err := policy.OverrideRemotes(c.Remote)\n      if err != nil {\n         log.Infof(\"Invalid remote %v, reverting to configuration default\", c.Remote)\n         return nil, err\n      }\n   }\n\n   if c.MutualTLSCertFile != \"\" \u0026#x26;\u0026#x26; c.MutualTLSKeyFile != \"\" {\n      err := policy.SetClientCertKeyPairFromFile(c.MutualTLSCertFile, c.MutualTLSKeyFile)\n      if err != nil {\n         log.Infof(\"Invalid mutual-tls-cert: %s or mutual-tls-key: %s, defaulting to no client auth\", c.MutualTLSCertFile, c.MutualTLSKeyFile)\n         return nil, err\n      }\n      log.Infof(\"Using client auth with mutual-tls-cert: %s and mutual-tls-key: %s\", c.MutualTLSCertFile, c.MutualTLSKeyFile)\n   }\n\n   if c.TLSRemoteCAs != \"\" {\n      err := policy.SetRemoteCAsFromFile(c.TLSRemoteCAs)\n      if err != nil {\n         log.Infof(\"Invalid tls-remote-ca: %s, defaulting to system trust store\", c.TLSRemoteCAs)\n         return nil, err\n      }\n      log.Infof(\"Using trusted CA from tls-remote-ca: %s\", c.TLSRemoteCAs)\n   }\n\n   s, err := universal.NewSigner(cli.RootFromConfig(\u0026#x26;c), policy)\n   if err != nil {\n      return nil, err\n   }\n\n   if db != nil {\n      dbAccessor := certsql.NewAccessor(db)\n      s.SetDBAccessor(dbAccessor)\n   }\n\n   return s, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¿™é‡Œå¯ä»¥çœ‹åˆ°èƒ½å¤Ÿè®¾ç½® TLS å®¢æˆ·ç«¯è¯ä¹¦ã€ä¿¡ä»»çš„ CA è¯ä¹¦ï¼Œä»¥åŠ DBã€‚\u003c/p\u003e\n\u003cp\u003eè¿™äº›é…ç½®é¡¹éƒ½æ˜¯ä»æ–‡ä»¶è¯»å–çš„ï¼Œåç»­å¼€å‘è¿‡ç¨‹ä¸­æˆ‘è€ƒè™‘ä¼šæ”¹æˆé…ç½®é¡¹è·å–æµç¨‹ï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eä» ENV è·å–é…ç½®é¡¹\u003c/li\u003e\n\u003cli\u003eä»æ•°æ®åº“è·å–è‡ªèº« CA è¯ä¹¦ã€æ²¡æœ‰åˆ™åˆ›å»º CA è¯ä¹¦\u003c/li\u003e\n\u003cli\u003eå°†è¯ä¹¦å†™å…¥ä¸´æ—¶æ–‡ä»¶ï¼Œå°†ä¸´æ—¶æ–‡ä»¶åœ°å€ä¼ å…¥ cfssl é…ç½®é¡¹\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eå°½é‡å‡å°‘ä¿®æ”¹æºä»£ç çš„å·¥ç¨‹é‡ï¼Œä¿æŒæœ€å¤§çš„ç¤¾åŒºå…¼å®¹æ€§ã€‚\u003c/p\u003e\n\u003ch5\u003e2.1.3.3. Remote\u003c/h5\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e é…ç½®è¿œç¨‹è¯ä¹¦ç­¾å‘ï¼Œ\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// Helper function to perform a remote sign or info request.\nfunc (s *Signer) remoteOp(req interface{}, profile, target string) (resp interface{}, err error) {\n   jsonData, err := json.Marshal(req)\n   if err != nil {\n      return nil, cferr.Wrap(cferr.APIClientError, cferr.JSONError, err)\n   }\n\n   p, err := signer.Profile(s, profile)\n   if err != nil {\n      return\n   }\n\n   server := client.NewServerTLS(p.RemoteServer, helpers.CreateTLSConfig(p.RemoteCAs, p.ClientCert))\n   if server == nil {\n      return nil, cferr.Wrap(cferr.PolicyError, cferr.InvalidRequest,\n         errors.New(\"failed to connect to remote\"))\n   }\n\n   server.SetReqModifier(s.reqModifier)\n\n   // There's no auth provider for the \"info\" method\n   if target == \"info\" {\n      resp, err = server.Info(jsonData)\n   } else if p.RemoteProvider != nil {\n      resp, err = server.AuthSign(jsonData, nil, p.RemoteProvider)\n   } else {\n      resp, err = server.Sign(jsonData)\n   }\n\n   if err != nil {\n      return nil, err\n   }\n\n   return\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ¶‰åŠåˆ°ä½¿ç”¨ Remote CA çš„æ“ä½œä¼šä½¿ç”¨ \u003cem\u003ecfssl/api\u003c/em\u003e åŒ…ï¼Œè°ƒç”¨è¿œç¨‹ CA æ¥å£å¤„ç†ã€‚\u003c/p\u003e\n\u003ch4\u003e2.1.4. è¯ä¹¦å¤„ç†\u003c/h4\u003e\n\u003ch5\u003e2.1.4.1. Pre-Issuance Linting\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// signer/local/local.go\n\n\tvar lintPriv crypto.Signer\n\t// If there is at least one profile (including the default) that configures\n\t// pre-issuance linting then generate the one-off lintPriv key.\n\tfor _, profile := range policy.Profiles {\n\t\tif profile.LintErrLevel \u003e 0 || policy.Default.LintErrLevel \u003e 0 {\n\t\t\t// In the future there may be demand for specifying the type of signer used\n\t\t\t// for pre-issuance linting in configuration. For now we assume that signing\n\t\t\t// with a randomly generated P-256 ECDSA private key is acceptable for all cases\n\t\t\t// where linting is requested.\n\t\t\tk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, cferr.New(cferr.PrivateKeyError, cferr.GenerationFailed)\n\t\t\t}\n\t\t\tlintPriv = k\n\t\t\tbreak\n\t\t}\n\t}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epre-issuance linting å³é¢„ç­¾å‘æ ¡éªŒï¼Œ\u003ca href=\"https://wiki.mozilla.org/CA/Required_or_Recommended_Practices#Pre-Issuance_Linting\"\u003eMozilla CA\u003c/a\u003e å¯¹æ­¤çš„è§£é‡Šæ˜¯ï¼š\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRecently, several tools have been developed (\u003ca href=\"https://github.com/awslabs/certlint\"\u003ecertlint/cablint\u003c/a\u003e, \u003ca href=\"https://github.com/kroeckx/x509lint\"\u003ex509lint\u003c/a\u003e, \u003ca href=\"https://github.com/zmap/zlint\"\u003ezlint\u003c/a\u003e) which can check a tbsCertificate (To Be Signed Certificate - the  certificate complete except for the signature) for a large number of  standards violations (BRs, RFCs etc.). It is strongly recommended that  CAs integrate such tools into their issuance pipelines such that  issuance is, minimally, held up for manual review if an error or warning is found. Because BR or RFC violations are generally considered by  Mozilla to be misissuance, such integration will reduce the number of  misissuance events a CA experiences, if earlier parts of their pipeline  fail in their job of keeping certificates compliant.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e åœ¨ \u003ca href=\"https://github.com/cloudflare/cfssl/issues/1008\"\u003eIssue #1008\u003c/a\u003e ä¸­å¢åŠ å¯¹è¯ä¹¦ lint çš„æ”¯æŒã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// signer/local/local.go\n\n// lint performs pre-issuance linting of a given TBS certificate template when\n// the provided errLevel is \u003e 0. Note that the template is provided by-value and\n// not by-reference. This is important as the lint function needs to mutate the\n// template's signature algorithm to match the lintPriv.\nfunc (s *Signer) lint(template x509.Certificate, errLevel lint.LintStatus, lintRegistry lint.Registry) error {\n\t// Always return nil when linting is disabled (lint.Reserved == 0).\n\tif errLevel == lint.Reserved {\n\t\treturn nil\n\t}\n\t// without a lintPriv key to use to sign the tbsCertificate we can't lint it.\n\tif s.lintPriv == nil {\n\t\treturn cferr.New(cferr.PrivateKeyError, cferr.Unavailable)\n\t}\n\n\t// The template's SignatureAlgorithm must be mutated to match the lintPriv or\n\t// x509.CreateCertificate will error because of the mismatch. At the time of\n\t// writing s.lintPriv is always an ECDSA private key. This switch will need to\n\t// be expanded if the lint key type is made configurable.\n\tswitch s.lintPriv.(type) {\n\tcase *ecdsa.PrivateKey:\n\t\ttemplate.SignatureAlgorithm = x509.ECDSAWithSHA256\n\tdefault:\n\t\treturn cferr.New(cferr.PrivateKeyError, cferr.KeyMismatch)\n\t}\n\n\tprelintBytes, err := x509.CreateCertificate(rand.Reader, \u0026#x26;template, s.ca, template.PublicKey, s.lintPriv)\n\tif err != nil {\n\t\treturn cferr.Wrap(cferr.CertificateError, cferr.Unknown, err)\n\t}\n\tprelintCert, err := zx509.ParseCertificate(prelintBytes)\n\tif err != nil {\n\t\treturn cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)\n\t}\n\terrorResults := map[string]lint.LintResult{}\n\tresults := zlint.LintCertificateEx(prelintCert, lintRegistry)\n\tfor name, res := range results.Results {\n\t\tif res.Status \u003e errLevel {\n\t\t\terrorResults[name] = *res\n\t\t}\n\t}\n\tif len(errorResults) \u003e 0 {\n\t\treturn \u0026#x26;LintError{\n\t\t\tErrorResults: errorResults,\n\t\t}\n\t}\n\treturn nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè‡ªç­¾åæ—¶è°ƒç”¨ zlint è¿›è¡Œè¯ä¹¦åˆæ³•æ€§æ ¡éªŒã€‚\u003c/p\u003e\n\u003ch5\u003e2.1.4.2. è¯ä¹¦æ¨¡æ¿\u003c/h5\u003e\n\u003cp\u003eCSR æ¨¡æ¿å¤„ç†ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// signer/local/local.go\n\n\t// è§£æ CSR æ¨¡æ¿\n\tcsrTemplate, err := signer.ParseCertificateRequest(s, profile, block.Bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Copy out only the fields from the CSR authorized by policy.\n\tsafeTemplate := x509.Certificate{}\n\t// If the profile contains no explicit whitelist, assume that all fields\n\t// should be copied from the CSR.\n\tif profile.CSRWhitelist == nil {\n\t\tsafeTemplate = *csrTemplate\n\t} else {\n\t\t// å¦‚æœè®¾ç½®äº† CSR æ¨¡æ¿ç™½åå•ï¼Œåˆ™åªæ”¾è¡Œç™½åå•é‡Œçš„å­—æ®µ\n\t\tif profile.CSRWhitelist.Subject {\n\t\t\tsafeTemplate.Subject = csrTemplate.Subject\n\t\t}\n\t\tif profile.CSRWhitelist.PublicKeyAlgorithm {\n\t\t\tsafeTemplate.PublicKeyAlgorithm = csrTemplate.PublicKeyAlgorithm\n\t\t}\n\t\tif profile.CSRWhitelist.PublicKey {\n\t\t\tsafeTemplate.PublicKey = csrTemplate.PublicKey\n\t\t}\n\t\tif profile.CSRWhitelist.SignatureAlgorithm {\n\t\t\tsafeTemplate.SignatureAlgorithm = csrTemplate.SignatureAlgorithm\n\t\t}\n\t\tif profile.CSRWhitelist.DNSNames {\n\t\t\tsafeTemplate.DNSNames = csrTemplate.DNSNames\n\t\t}\n\t\tif profile.CSRWhitelist.IPAddresses {\n\t\t\tsafeTemplate.IPAddresses = csrTemplate.IPAddresses\n\t\t}\n\t\tif profile.CSRWhitelist.EmailAddresses {\n\t\t\tsafeTemplate.EmailAddresses = csrTemplate.EmailAddresses\n\t\t}\n\t\tif profile.CSRWhitelist.URIs {\n\t\t\tsafeTemplate.URIs = csrTemplate.URIs\n\t\t}\n\t}\n\n\t...\n\n\t// ç”¨ hosts å­—æ®µè¦†ç›– SAN\n\tOverrideHosts(\u0026#x26;safeTemplate, req.Hosts)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eç”Ÿæˆè¯ä¹¦åºåˆ—å·ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e\t\t// RFC 5280 4.1.2.2:\n\t\t// Certificate users MUST be able to handle serialNumber\n\t\t// values up to 20 octets.  Conforming CAs MUST NOT use\n\t\t// serialNumber values longer than 20 octets.\n\t\t//\n\t\t// If CFSSL is providing the serial numbers, it makes\n\t\t// sense to use the max supported size.\n\t\tserialNumber := make([]byte, 20)\n\t\t_, err = io.ReadFull(rand.Reader, serialNumber)\n\t\tif err != nil {\n\t\t\treturn nil, cferr.Wrap(cferr.CertificateError, cferr.Unknown, err)\n\t\t}\n\n\t\t// SetBytes interprets buf as the bytes of a big-endian\n\t\t// unsigned integer. The leading byte should be masked\n\t\t// off to ensure it isn't negative.\n\t\tserialNumber[0] \u0026#x26;= 0x7F\n\n\t\tsafeTemplate.SerialNumber = new(big.Int).SetBytes(serialNumber)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå¡«å……è¯ä¹¦ç‰¹æ®Šå­—æ®µï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// signer/signer.go\n\n\t// è¯ä¹¦ OCSP å­—æ®µæ¥è‡ªé…ç½®çš„ Profile OCSP URL\n\tif ocspURL = profile.OCSP; ocspURL == \"\" {\n\t\tocspURL = defaultProfile.OCSP\n\t}\n\n\tif template.IsCA {\n\t\ttemplate.MaxPathLen = profile.CAConstraint.MaxPathLen\n\t\tif template.MaxPathLen == 0 {\n\t\t\ttemplate.MaxPathLenZero = profile.CAConstraint.MaxPathLenZero\n\t\t}\n\t\t// å¦‚æœæ˜¯ CA è¯ä¹¦ï¼Œåˆ™æ²¡æœ‰ SAN å­—æ®µ\n\t\ttemplate.DNSNames = nil\n\t\ttemplate.EmailAddresses = nil\n\t\ttemplate.URIs = nil\n\t}\n\n\t// è‹¥è®¾ç½® OCSP No Check\n\tif profile.OCSPNoCheck {\n\t\tocspNoCheckExtension := pkix.Extension{\n\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 48, 1, 5},\n\t\t\tCritical: false,\n\t\t\tValue:    []byte{0x05, 0x00},\n\t\t}\n\t\ttemplate.ExtraExtensions = append(template.ExtraExtensions, ocspNoCheckExtension)\n\t}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e2.1.4.3. ç­¾åè¯ä¹¦\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// signer/local/local.go\nfunc (s *Signer) sign(template *x509.Certificate, lintErrLevel lint.LintStatus, lintRegistry lint.Registry) (cert []byte, err error) {\n   var initRoot bool\n   // æ²¡æœ‰æŒ‡å®š cert\n   if s.ca == nil {\n      // ä¸æ˜¯ ca è¯ä¹¦åˆ™æŠ¥é”™\n      if !template.IsCA {\n         err = cferr.New(cferr.PolicyError, cferr.InvalidRequest)\n         return\n      }\n      // ca è¯ä¹¦æ²¡æœ‰ SAN å­—æ®µ\n      template.DNSNames = nil\n      template.EmailAddresses = nil\n      template.URIs = nil\n      s.ca = template\n      initRoot = true\n   }\n\n   if err := s.lint(*template, lintErrLevel, lintRegistry); err != nil {\n      return nil, err\n   }\n\n   // ç­¾åè¯ä¹¦\n   derBytes, err := x509.CreateCertificate(rand.Reader, template, s.ca, template.PublicKey, s.priv)\n   if err != nil {\n      return nil, cferr.Wrap(cferr.CertificateError, cferr.Unknown, err)\n   }\n   if initRoot {\n      s.ca, err = x509.ParseCertificate(derBytes)\n      if err != nil {\n         return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)\n      }\n   }\n\n   cert = pem.EncodeToMemory(\u0026#x26;pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes})\n   log.Infof(\"signed certificate with serial number %d\", template.SerialNumber)\n   return\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e2.1.4.4. æ•°æ®åº“å‚¨å­˜\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// å¦‚æœè®¾ç½®äº† DB å‚¨å­˜\nif s.dbAccessor != nil {\n   now := time.Now()\n   var certRecord = certdb.CertificateRecord{\n      Serial: certTBS.SerialNumber.String(),\n      // this relies on the specific behavior of x509.CreateCertificate\n      // which sets the AuthorityKeyId from the signer's SubjectKeyId\n      AKI:        hex.EncodeToString(parsedCert.AuthorityKeyId),\n      CALabel:    req.Label,\n      Status:     \"good\",\n      Expiry:     certTBS.NotAfter,\n      PEM:        string(signedCert),\n      IssuedAt:   \u0026#x26;now,\n      NotBefore:  \u0026#x26;certTBS.NotBefore,\n      CommonName: sql.NullString{String: certTBS.Subject.CommonName, Valid: true},\n   }\n\n   if err := certRecord.SetMetadata(req.Metadata); err != nil {\n      return nil, err\n   }\n   if err := certRecord.SetSANs(certTBS.DNSNames); err != nil {\n      return nil, err\n   }\n\n   // åœ¨æ•°æ®åº“åˆ›å»ºä¸€æ¡ row\n   if err := s.dbAccessor.InsertCertificate(certRecord); err != nil {\n      return nil, err\n   }\n   log.Debug(\"saved certificate with serial number \", certTBS.SerialNumber)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.1.4. å¯¼å‡ºæ–‡ä»¶\u003c/h4\u003e\n\u003cp\u003e\u003cem\u003ecfssljson\u003c/em\u003e Cmd å·¥ä½œä¸ºæ¥æ”¶è¯·æ±‚è¿”å›ï¼Œå¹¶å°†å…¶é€šè¿‡ Pipeline è§£æï¼Œè¾“å‡ºåˆ°æ–‡ä»¶ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// cmd/cfssljson/cfssljson.go\nfunc readFile(filespec string) ([]byte, error) {\n\tif filespec == \"-\" {\n\t\t// è‹¥å‚æ•°ä¸º \"-\"ï¼Œåˆ™ä» stdin è·å–\n\t\treturn ioutil.ReadAll(os.Stdin)\n\t}\n\treturn ioutil.ReadFile(filespec)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè§£ææˆå¯¹åº”æ ¼å¼çš„æ–‡ä»¶å¹¶è¾“å‡ºã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e\tif contents, ok := input[\"cert\"]; ok {\n\t\tcert = contents.(string)\n\t} else if contents, ok = input[\"certificate\"]; ok {\n\t\tcert = contents.(string)\n\t}\n\tif cert != \"\" {\n\t\touts = append(outs, outputFile{\n\t\t\tFilename: baseName + \".pem\",\n\t\t\tContents: cert,\n\t\t\tPerms:    0664,\n\t\t})\n\t}\n\n\tif contents, ok := input[\"key\"]; ok {\n\t\tkey = contents.(string)\n\t} else if contents, ok = input[\"private_key\"]; ok {\n\t\tkey = contents.(string)\n\t}\n\tif key != \"\" {\n\t\touts = append(outs, outputFile{\n\t\t\tFilename: baseName + \"-key.pem\",\n\t\t\tContents: key,\n\t\t\tPerms:    0600,\n\t\t})\n\t}\n\n\tfor _, e := range outs {\n\t\tif *output {\n\t\t\tif e.IsBinary {\n\t\t\t\te.Contents = base64.StdEncoding.EncodeToString([]byte(e.Contents))\n\t\t\t}\n\t\t\tfmt.Fprintf(os.Stdout, \"%s\\n\", e.Contents)\n\t\t} else {\n\t\t\twriteFile(e.Filename, e.Contents, e.Perms)\n\t\t}\n\t}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.1.5. è¯ä¹¦ Bundle\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eCA bundle\u003c/strong\u003e is a file that contains root and  intermediate certificates. The end-entity certificate along with a CA  bundle constitutes the certificate chain.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eHow do I make CA-bundle file from CRT files?\u003c/p\u003e\n\u003cp\u003eThere are a few *.crt files in your package:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAddTrustExternalCARoot.crt\u003c/strong\u003e - Root CA Certificate\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCOMODORSAAddTrustCA.crt\u003c/strong\u003e - Intermediate CA Certificate 1\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCOMODORSADomainValidationSecureServerCA.crt\u003c/strong\u003e - Intermediate CA Certificate 2\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eyourDomain.crt\u003c/strong\u003e - Your SSL Certificate\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCA-bundle is a file that contains root and intermediate certificates in the right order. The order must be:\u003c/p\u003e\n\u003cp\u003e- Intermediate CA Certificate 2\u003c/p\u003e\n\u003cp\u003e- Intermediate CA Certificate 1\u003c/p\u003e\n\u003cp\u003e- Root CA Certificate\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ cat ComodoRSADomainValidationSecureServerCA.crt ComodoRSAAddTrustCA.crt AddTrustExternalCARoot.crt \u003e yourDomain.ca-bundle\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003ecfssl bundle\u003c/em\u003e å‘½ä»¤åªç”¨äºç”ŸæˆåŒ…å« end-entry è¯ä¹¦çš„è¯ä¹¦é“¾ï¼Œä½†åœ¨æˆ‘ä»¬å®é™…ä½¿ç”¨ä¸­ï¼Œåœ¨ Workload é—´ä¼ è¾“çš„åªæ˜¯ Workload è¯ä¹¦ï¼Œä¸ä¼šä¼ è¾“ CA è¯ä¹¦ã€‚\u003c/p\u003e\n\u003ch3\u003e2.2. CA Server\u003c/h3\u003e\n\u003ch4\u003e2.2.1. å¯åŠ¨\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// serverMain is the command line entry point to the API server. It sets up a\n// new HTTP server to handle sign, bundle, and validate requests.\nfunc serverMain(args []string, c cli.Config) error {\n\t\n    ...\n\n    // åˆå§‹åŒ– signer\n\tif s, err = sign.SignerFromConfigAndDB(c, db); err != nil {\n\t\tlog.Warningf(\"couldn't initialize signer: %v\", err)\n\t}\n\n    // åˆå§‹åŒ– ocsp signer\n\tif ocspSigner, err = ocspsign.SignerFromConfig(c); err != nil {\n\t\tlog.Warningf(\"couldn't initialize ocsp signer: %v\", err)\n\t}\n\n    // æ³¨å†Œ api handler\n\tregisterHandlers()\n\n\taddr := net.JoinHostPort(conf.Address, strconv.Itoa(conf.Port))\n\n\ttlscfg := tls.Config{}\n\tif conf.MinTLSVersion != \"\" {\n\t\ttlscfg.MinVersion = helpers.StringTLSVersion(conf.MinTLSVersion)\n\t}\n\n\tif conf.TLSCertFile == \"\" || conf.TLSKeyFile == \"\" {\n\t\tlog.Info(\"Now listening on \", addr)\n\t\treturn http.ListenAndServe(addr, nil)\n\t}\n\n    ...\n\treturn server.ListenAndServeTLS(conf.TLSCertFile, conf.TLSKeyFile)\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå¯åŠ¨æ—¶æµç¨‹ï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eåˆ›å»º Signerï¼Œå‚è€ƒ 2.1.3 èŠ‚\u003c/li\u003e\n\u003cli\u003eæ³¨å†Œ API Handlerï¼Œå¤„ç† HTTP è¯·æ±‚\u003c/li\u003e\n\u003cli\u003eå¯åŠ¨ HTTP / TLS æœåŠ¡å™¨ï¼ˆæ”¯æŒ mTLSï¼‰\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e2.2.2. æ³¨å†Œ API Handler\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// cli/serve/serve.go\n\nvar endpoints = map[string]func() (http.Handler, error){\n\t\"sign\": func() (http.Handler, error) {\n\t\tif s == nil {\n\t\t\treturn nil, errBadSigner\n\t\t}\n\n\t\th, err := signhandler.NewHandlerFromSigner(s)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif conf.CABundleFile != \"\" \u0026#x26;\u0026#x26; conf.IntBundleFile != \"\" {\n\t\t\tsh := h.Handler.(*signhandler.Handler)\n\t\t\tif err := sh.SetBundler(conf.CABundleFile, conf.IntBundleFile); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\treturn h, nil\n\t},\n\n\t\"authsign\": func() (http.Handler, error) {\n\t\tif s == nil {\n\t\t\treturn nil, errBadSigner\n\t\t}\n\n\t\th, err := signhandler.NewAuthHandlerFromSigner(s)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif conf.CABundleFile != \"\" \u0026#x26;\u0026#x26; conf.IntBundleFile != \"\" {\n\t\t\tsh := h.(*api.HTTPHandler).Handler.(*signhandler.AuthHandler)\n\t\t\tif err := sh.SetBundler(conf.CABundleFile, conf.IntBundleFile); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\treturn h, nil\n\t},\n\n\t\"info\": func() (http.Handler, error) {\n\t\tif s == nil {\n\t\t\treturn nil, errBadSigner\n\t\t}\n\t\treturn info.NewHandler(s)\n\t},\n\n\t\"crl\": func() (http.Handler, error) {\n\t\tif s == nil {\n\t\t\treturn nil, errBadSigner\n\t\t}\n\n\t\tif db == nil {\n\t\t\treturn nil, errNoCertDBConfigured\n\t\t}\n\n\t\treturn crl.NewHandler(certsql.NewAccessor(db), conf.CAFile, conf.CAKeyFile)\n\t},\n\n\t\"gencrl\": func() (http.Handler, error) {\n\t\tif s == nil {\n\t\t\treturn nil, errBadSigner\n\t\t}\n\t\treturn gencrl.NewHandler(), nil\n\t},\n\n\t\"newcert\": func() (http.Handler, error) {\n\t\tif s == nil {\n\t\t\treturn nil, errBadSigner\n\t\t}\n\t\th := generator.NewCertGeneratorHandlerFromSigner(generator.CSRValidate, s)\n\t\tif conf.CABundleFile != \"\" \u0026#x26;\u0026#x26; conf.IntBundleFile != \"\" {\n\t\t\tcg := h.(api.HTTPHandler).Handler.(*generator.CertGeneratorHandler)\n\t\t\tif err := cg.SetBundler(conf.CABundleFile, conf.IntBundleFile); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn h, nil\n\t},\n\n\t\"bundle\": func() (http.Handler, error) {\n\t\treturn bundle.NewHandler(conf.CABundleFile, conf.IntBundleFile)\n\t},\n\n\t\"newkey\": func() (http.Handler, error) {\n\t\treturn generator.NewHandler(generator.CSRValidate)\n\t},\n\n\t\"init_ca\": func() (http.Handler, error) {\n\t\treturn initca.NewHandler(), nil\n\t},\n\n\t\"scan\": func() (http.Handler, error) {\n\t\treturn scan.NewHandler(conf.CABundleFile)\n\t},\n\n\t\"scaninfo\": func() (http.Handler, error) {\n\t\treturn scan.NewInfoHandler(), nil\n\t},\n\n\t\"certinfo\": func() (http.Handler, error) {\n\t\tif db != nil {\n\t\t\treturn certinfo.NewAccessorHandler(certsql.NewAccessor(db)), nil\n\t\t}\n\n\t\treturn certinfo.NewHandler(), nil\n\t},\n\n\t\"ocspsign\": func() (http.Handler, error) {\n\t\tif ocspSigner == nil {\n\t\t\treturn nil, errBadSigner\n\t\t}\n\t\treturn apiocsp.NewHandler(ocspSigner), nil\n\t},\n\n\t\"revoke\": func() (http.Handler, error) {\n\t\tif db == nil {\n\t\t\treturn nil, errNoCertDBConfigured\n\t\t}\n\t\treturn revoke.NewHandler(certsql.NewAccessor(db)), nil\n\t},\n\n\t\"/\": func() (http.Handler, error) {\n\t\tif err := staticBox.findStaticBox(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn http.FileServer(staticBox), nil\n\t},\n\n\t\"health\": func() (http.Handler, error) {\n\t\treturn health.NewHealthCheck(), nil\n\t},\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.2.3. OCSP\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003ePartly to combat these scalability issues, OCSP was introduced. OCSP  provides on-demand answers about the revocation status of a given  certificate. An OCSP responder is a service that returns signed answers  to the question \"is this certificate revoked?\". The response is either  \"Yes\" or \"No\". Each response is signed by the CA and has a validity  period so the client knows how long to cache the response.\u003c/p\u003e\n\u003cp\u003eCFSSL now has an OCSP responder service that can be configured to run in a distributed way, without access to the CA. There are also OCSP  management tools in CFSSL to automatically populate the data for the  OCSP responder and keep it fresh using the certificate database.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://blog.cloudflare.com/content/images/2016/03/image_8.png\" alt=\"refreshing the OCSP responder\"\u003e\u003c/p\u003e\n\u003cp\u003eOCSP ç­¾åï¼Œå’Œ OCSP è¿”å›æ˜¯ç‹¬ç«‹çš„ç¨‹åºï¼Œåˆ©äºåˆ†å¸ƒå¼éƒ¨ç½²ã€‚\u003c/p\u003e\n\u003ch5\u003e2.2.3.1. OCSP Responder\u003c/h5\u003e\n\u003cp\u003eä»‹ç»ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// Usage text of 'cfssl serve'\nvar ocspServerUsageText = `cfssl ocspserve -- set up an HTTP server that handles OCSP requests from either a file or directly from a database (see RFC 5019)\n\n  Usage of ocspserve:\n          cfssl ocspserve [-address address] [-port port] [-responses file] [-db-config db-config]\n\n  Flags:\n  `\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCSP Server èƒ½å¤Ÿåœ¨è‡ªå®šä¹‰çš„ Path ä¸Šå¯åŠ¨ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e\tlog.Info(\"Registering OCSP responder handler\")\n\thttp.Handle(c.Path, ocsp.NewResponder(src, nil))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e OCSP å¤„ç†è¯·æ±‚æ¥å£ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// ocsp/responder.go\n\n// A Responder can process both GET and POST requests.  The mapping\n// from an OCSP request to an OCSP response is done by the Source;\n// the Responder simply decodes the request, and passes back whatever\n// response is provided by the source.\n// Note: The caller must use http.StripPrefix to strip any path components\n// (including '/') on GET requests.\n// Do not use this responder in conjunction with http.NewServeMux, because the\n// default handler will try to canonicalize path components by changing any\n// strings of repeated '/' into a single '/', which will break the base64\n// encoding.\nfunc (rs Responder) ServeHTTP(response http.ResponseWriter, request *http.Request) {\n\n\t...\n    \n\t// Parse response as an OCSP request\n\t// XXX: This fails if the request contains the nonce extension.\n\t//      We don't intend to support nonces anyway, but maybe we\n\t//      should return unauthorizedRequest instead of malformed.\n\tocspRequest, err := ocsp.ParseRequest(requestBody)\n\n    ...\n    \n\t// Look up OCSP response from source\n\tocspResponse, headers, err := rs.Source.Response(ocspRequest)\n\n    ...\n    \n\tparsedResponse, err := ocsp.ParseResponse(ocspResponse, nil)\n\n    ...\n\n\tresponse.WriteHeader(http.StatusOK)\n\tresponse.Write(ocspResponse)\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOCSP è¿”å›çš„å†…å®¹å®é™…ä¸Šç›´æ¥ä»æ•°æ®åº“è¯»å–åè¿”å›ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// ocsp/responder.go\n\n// Response implements cfssl.ocsp.responder.Source, which returns the\n// OCSP response in the Database for the given request with the expiration\n// date furthest in the future.\nfunc (src DBSource) Response(req *ocsp.Request) ([]byte, http.Header, error) {\n\t...\n\trecords, err := src.Accessor.GetOCSP(strSN, aki)\n\t...\n\treturn []byte(cur.Body), nil, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// GetOCSP retrieves a certdb.OCSPRecord from db by serial.\nfunc (d *Accessor) GetOCSP(serial, aki string) (ors []certdb.OCSPRecord, err error) {\n\terr = d.checkDB()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = d.db.Select(\u0026#x26;ors, fmt.Sprintf(d.db.Rebind(selectOCSPSQL), sqlstruct.Columns(certdb.OCSPRecord{})), serial, aki)\n\tif err != nil {\n\t\treturn nil, wrapSQLError(err)\n\t}\n\n\treturn ors, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e2.2.3.2. OCSP Sign\u003c/h5\u003e\n\u003cp\u003eOCSP ç­¾åå’Œè¿”å›æ˜¯åˆ†å¼€çš„ï¼Œå¹¶ä¸”ä¸ä¼šåœ¨åˆ›å»ºè¯ä¹¦ä¸€å¹¶åˆ›å»ºã€‚\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021-11-01-07.png\" alt=\"\"\u003eåœºæ™¯1ï¼šOCSP ç­¾åä¼šåœ¨è¯ä¹¦è¢«åŠé”€æ—¶åˆ›å»ºã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// cli/ocsprefresh/ocsprefresh.go\n\n// ocsprefreshMain is the main CLI of OCSP refresh functionality.\nfunc ocsprefreshMain(args []string, c cli.Config) error {\n   ...\n\n\ts, err := SignerFromConfig(c)\n\tif err != nil {\n\t\tlog.Critical(\"Unable to create OCSP signer: \", err)\n\t\treturn err\n\t}\n\n\tdb, err := dbconf.DBFromConfig(c.DBConfigFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdbAccessor := sql.NewAccessor(db)\n\tcerts, err := dbAccessor.GetUnexpiredCertificates()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set an expiry timestamp for all certificates refreshed in this batch\n\tocspExpiry := time.Now().Add(c.Interval)\n\tfor _, certRecord := range certs {\n\t\tcert, err := helpers.ParseCertificatePEM([]byte(certRecord.PEM))\n\t\tif err != nil {\n\t\t\tlog.Critical(\"Unable to parse certificate: \", err)\n\t\t\treturn err\n\t\t}\n\n\t\treq := ocsp.SignRequest{\n\t\t\tCertificate: cert,\n\t\t\tStatus:      certRecord.Status,\n\t\t}\n\n\t\tif certRecord.Status == \"revoked\" {\n\t\t\treq.Reason = int(certRecord.Reason)\n\t\t\treq.RevokedAt = certRecord.RevokedAt\n\t\t}\n\n\t\tresp, err := s.Sign(req)\n\t\tif err != nil {\n\t\t\tlog.Critical(\"Unable to sign OCSP response: \", err)\n\t\t\treturn err\n\t\t}\n\n\t\terr = dbAccessor.UpsertOCSP(cert.SerialNumber.String(), hex.EncodeToString(cert.AuthorityKeyId), string(resp), ocspExpiry)\n\t\tif err != nil {\n\t\t\tlog.Critical(\"Unable to save OCSP response: \", err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåœºæ™¯2ï¼šé€šè¿‡ \u003ccode\u003ecfssl ocsprefresh\u003c/code\u003e å‘½ä»¤æ‰§è¡Œã€‚\u003c/p\u003e\n\u003cp\u003eäºŒæ¬¡å¼€å‘æ—¶å¯ä»¥è€ƒè™‘å°† OCSP è®°å½•åœ¨ç­¾å‘è¯ä¹¦æ—¶è¿›è¡Œåˆ›å»ºã€‚\u003c/p\u003e\n\u003ch4\u003e2.2.4. API Client\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eapi/client\u003c/code\u003e åŒ…å®ç°äº† cfssl çš„ API å®¢æˆ·ç«¯ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// A Remote points to at least one (but possibly multiple) remote\n// CFSSL instances. It must be able to perform a authenticated and\n// unauthenticated certificate signing requests, return information\n// about the CA on the other end, and return a list of the hosts that\n// are used by the remote.\ntype Remote interface {\n   AuthSign(req, id []byte, provider auth.Provider) ([]byte, error)\n   Sign(jsonData []byte) ([]byte, error)\n   Info(jsonData []byte) (*info.Resp, error)\n   Hosts() []string\n   SetReqModifier(func(*http.Request, []byte))\n   SetRequestTimeout(d time.Duration)\n   SetProxy(func(*http.Request) (*url.URL, error))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eä¸»è¦åŠŸèƒ½ä¸º API æ¥å£å’Œå‚æ•°çš„å°è£…ã€‚ä¼šåœ¨ä¸‹ä¸€èŠ‚ä¸­è¢«ç”¨åˆ°ã€‚\u003c/p\u003e\n\u003ch5\u003e2.2.4.1. è·å– CA è¯ä¹¦\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// signer/local/local.go\n\n// è·å– CA Info\n// Info return a populated info.Resp struct or an error.\nfunc (s *Signer) Info(req info.Req) (resp *info.Resp, err error) {\n\tcert, err := s.Certificate(req.Label, req.Profile)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tprofile, err := signer.Profile(s, req.Profile)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresp = new(info.Resp)\n\tif cert.Raw != nil {\n\t\tresp.Certificate = string(bytes.TrimSpace(pem.EncodeToMemory(\u0026#x26;pem.Block{Type: \"CERTIFICATE\", Bytes: cert.Raw})))\n\t}\n\tresp.Usage = profile.Usage\n\tresp.ExpiryString = profile.ExpiryString\n\n\treturn\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¿”å›æœåŠ¡ç«¯çš„ CA è¯ä¹¦ï¼Œè¯¥è¯ä¹¦ä¼šç”¨åœ¨ Client çš„ TrustRoot ä¸­ã€‚\u003c/p\u003e\n\u003cp\u003eé—®é¢˜ç‚¹ï¼šRoot CA è¯ä¹¦æ²¡æœ‰è¢«åŠ è½½åˆ°ç¨‹åºä¸­ï¼Œéœ€è¦åœ¨æœåŠ¡ç«¯å¢åŠ  Root è¯ä¹¦çš„è¿”å›å€¼ã€‚\u003c/p\u003e\n\u003ch4\u003e2.2.5. è¯ä¹¦åŠé”€\u003c/h4\u003e\n\u003ch5\u003e2.2.5.1. åŠé”€æ¥å£\u003c/h5\u003e\n\u003cp\u003eè¯ä¹¦åŠé”€æ¥å£æ”¯æŒä¸‰ä¸ªå‚æ•°ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eUPDATE certificates\n\tSET status='revoked', revoked_at=CURRENT_TIMESTAMP, reason=:reason\n\tWHERE (serial_number = :serial_number AND authority_key_identifier = :authority_key_identifier);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¯ä¹¦åºåˆ—å·å’Œ AKI å®šä½ä¸€ä¸ªè¯ä¹¦ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// api/revoke/revoke.go\n\n\t// If we were given a signer, try and generate an OCSP\n\t// response indicating revocation\n\tif h.Signer != nil {\n\t\t// TODO: should these errors be errors?\n\t\t// Grab the certificate from the database\n\t\tcr, err := h.dbAccessor.GetCertificate(req.Serial, req.AKI)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(cr) != 1 {\n\t\t\treturn errors.NewBadRequestString(\"No unique certificate found\")\n\t\t}\n\n\t\tcert, err := helpers.ParseCertificatePEM([]byte(cr[0].PEM))\n\t\tif err != nil {\n\t\t\treturn errors.NewBadRequestString(\"Unable to parse certificates from PEM data\")\n\t\t}\n\n\t\tsr := ocsp.SignRequest{\n\t\t\tCertificate: cert,\n\t\t\tStatus:      \"revoked\",\n\t\t\tReason:      reasonCode,\n\t\t\tRevokedAt:   time.Now().UTC(),\n\t\t}\n\n\t\tocspResponse, err := h.Signer.Sign(sr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// We parse the OCSP response in order to get the next\n\t\t// update time/expiry time\n\t\tocspParsed, err := stdocsp.ParseResponse(ocspResponse, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tocspRecord := certdb.OCSPRecord{\n\t\t\tSerial: req.Serial,\n\t\t\tAKI:    req.AKI,\n\t\t\tBody:   string(ocspResponse),\n\t\t\tExpiry: ocspParsed.NextUpdate,\n\t\t}\n\n\t\tif err = h.dbAccessor.InsertOCSP(ocspRecord); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¯ä¹¦åŠé”€æ—¶ä¼šè¿›è¡Œ OCSP ç­¾åï¼Œåˆ›å»ºä¸€ä¸ªåŠé”€çŠ¶æ€çš„ OCSP Responseã€‚\u003c/p\u003e\n\u003ch5\u003e2.2.5.2. æŸ¥è¯¢è¯ä¹¦åŠé”€\u003c/h5\u003e\n\u003cp\u003eè¯ä¹¦åŠé”€æ²¡æœ‰ä¸»åŠ¨é€šçŸ¥æœºåˆ¶ï¼Œå¦‚ä½•æ„Ÿåº”åˆ°è¯ä¹¦å·²ç»è¢«åŠé”€ï¼Ÿ\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/snowflakedb/gosnowflake/issues/5\"\u003ehttps://github.com/snowflakedb/gosnowflake/issues/5\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHere are the steps to implement the revocation checks with OCSP:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCheck if certificate validation can be intercepted to add revocation checks (Yes. TLSClientConfig including verifyPeerCertificate can be  injected in Client)\u003c/li\u003e\n\u003cli\u003eExtract OCSP URL from the certificate\u003c/li\u003e\n\u003cli\u003eMake sure OCSP Request can be composed.\u003c/li\u003e\n\u003cli\u003eMake sure a simple roundtrip with OCSP server returns OCSP Response and can be decoded.\u003c/li\u003e\n\u003cli\u003eMake sure OCSP Response can include enough information to validate the revocation status.\u003c/li\u003e\n\u003cli\u003eImplement concurrent OCSP round trips for chained certificates.\u003c/li\u003e\n\u003cli\u003eImplement caching the results in a cache directory\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eé€šè¿‡å®ç° \u003ccode\u003etls.Config.VerifyPeerCertificate\u003c/code\u003e æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå®šä¹‰å®ç° OCSP æŸ¥è¯¢ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e    // VerifyPeerCertificate, if not nil, is called after normal\n    // certificate verification by either a TLS client or server. It\n    // receives the raw ASN.1 certificates provided by the peer and also\n    // any verified chains that normal processing found. If it returns a\n    // non-nil error, the handshake is aborted and that error results.\n    //\n    // If normal verification fails then the handshake will abort before\n    // considering this callback. If normal verification is disabled by\n    // setting InsecureSkipVerify, or (for a server) when ClientAuth is\n    // RequestClientCert or RequireAnyClientCert, then this callback will\n    // be considered but the verifiedChains argument will always be nil.\n    VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error // Go 1.8\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè®¤è¯ OCSP çš„ç¤ºä¾‹ä»£ç  \u003ca href=\"https://github.com/snowflakedb/gosnowflake/blob/master/ocsp.go%EF%BC%9A\"\u003ehttps://github.com/snowflakedb/gosnowflake/blob/master/ocsp.goï¼š\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// verifyPeerCertificate verifies all of certificate revocation status\nfunc verifyPeerCertificate(ctx context.Context, verifiedChains [][]*x509.Certificate) (err error) {\n\tfor i := 0; i \u0026#x3C; len(verifiedChains); i++ {\n\t\t// Certificate signed by Root CA. This should be one before the last in the Certificate Chain\n\t\tnumberOfNoneRootCerts := len(verifiedChains[i]) - 1\n\t\tif !verifiedChains[i][numberOfNoneRootCerts].IsCA || string(verifiedChains[i][numberOfNoneRootCerts].RawIssuer) != string(verifiedChains[i][numberOfNoneRootCerts].RawSubject) {\n\t\t\t// Check if the last Non Root Cert is also a CA or is self signed.\n\t\t\t// if the last certificate is not, add it to the list\n\t\t\trca := caRoot[string(verifiedChains[i][numberOfNoneRootCerts].RawIssuer)]\n\t\t\tif rca == nil {\n\t\t\t\treturn fmt.Errorf(\"failed to find root CA. pkix.name: %v\", verifiedChains[i][numberOfNoneRootCerts].Issuer)\n\t\t\t}\n\t\t\tverifiedChains[i] = append(verifiedChains[i], rca)\n\t\t\tnumberOfNoneRootCerts++\n\t\t}\n\t\tresults := getAllRevocationStatus(ctx, verifiedChains[i])\n\t\tif r := canEarlyExitForOCSP(results, numberOfNoneRootCerts); r != nil {\n\t\t\treturn r.err\n\t\t}\n\t}\n\n\tocspResponseCacheLock.Lock()\n\tif cacheUpdated {\n\t\twriteOCSPCacheFile()\n\t}\n\tcacheUpdated = false\n\tocspResponseCacheLock.Unlock()\n\treturn nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2.3. Transport\u003c/h3\u003e\n\u003cp\u003eæˆ‘ç§°å‘¼å®ƒä¸º Workload SDKã€‚\u003c/p\u003e\n\u003cp\u003eæˆ‘ä»¬åç»­çš„ Workload SDK æ˜¯åŸºäºæ­¤åŒ…ä¿®æ”¹è€Œæ¥ã€‚æœ¬è´¨ä¸Šä¸ Istio Pilot Agent çš„ CA Client ç±»ä¼¼ã€‚\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://blog.cloudflare.com/content/images/2016/03/image_3.png\" alt=\"Certificate Issuance\"\u003e\u003c/p\u003e\n\u003cp\u003eæˆ‘å‘ç°ä¸Šå›¾ä¸­ cfssl æŠŠ \"OCSP\" å†™æˆäº† \"OSCP\"ï¼ŒğŸ¤£ã€‚\u003c/p\u003e\n\u003ch4\u003e2.3.1. é…ç½®é¡¹\u003c/h4\u003e\n\u003cp\u003eé…ç½®é¡¹ä½œä¸ºä¸€ä¸ªç‰¹æ€§ï¼Œåœ¨ CFSSL çš„å®˜æ–¹æ–‡æ¡£ä¸­è¢«æåˆ°ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e{\n  \"request\": {\n    \"CN\": \"test server\",\n    \"hosts\": [\"127.0.0.1\"]\n  },\n  \"profiles\": {\n    \"paths\": {\n      \"private_key\": \"server.key\",\n      \"certificate\": \"server.pem\"\n    },\n    \"cfssl\": {\n      \"profile\": \"server\",\n      \"remote\": \"127.0.0.1:8888\",\n      \"auth-type\": \"standard\",\n      \"auth-key\": \"4f4f26686209f672e0ec7b19cbbc8b6d94fdd12cc0b20326f9005d5f234e6e3e\"\n    }\n  },\n  \"roots\": [{\n    \"type\": \"system\"\n  }],\n  \"client_roots\": [{\n    \"type\": \"cfssl\",\n    \"metadata\": {\n      \"host\": \"127.0.0.1:8888\",\n      \"profile\": \"client\"\n    }\n  }]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eroots\u003c/code\u003e ä»¥åŠ \u003ccode\u003eclient_roots\u003c/code\u003e æ˜¯ç”¨æ¥é…ç½® System Trust Store å’Œ Client Trust Store çš„ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e\t// TrustStore contains the certificates trusted by this\n\t// transport.\n\tTrustStore *roots.TrustStore\n\n\t// ClientTrustStore contains the certificate authorities to\n\t// use in verifying client authentication certificates.\n\tClientTrustStore *roots.TrustStore\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.3.2. TrustStore\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA \u003cstrong\u003eTrustStore\u003c/strong\u003e holds the certificates of external systems that you trust. So a \u003cstrong\u003eTrustStore\u003c/strong\u003e is a KeyStore file, that contains the public keys/certificate of external hosts that you trust.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch5\u003e2.3.2.1. System Cert Pool\u003c/h5\u003e\n\u003cp\u003e\u003cem\u003ecfssl\u003c/em\u003e æºç ä¸­å°† Golang å®˜æ–¹ x509 åŒ…ä¸­ system éƒ¨åˆ† copy åˆ°äº† \u003ccode\u003etransport/roots/system\u003c/code\u003e ç›®å½•ä¸‹ï¼Œç”¨äºåˆ›å»ºç³»ç»Ÿä¿¡ä»»çš„ CA è¯ä¹¦æ± ï¼Œä½†æ²¡æœ‰å¯¹ Windows è¿›è¡Œå¤„ç†ï¼Œå¯¼è‡´åœ¨ Windows ä¸Šå‡ºç°æŠ¥é”™ã€‚\u003c/p\u003e\n\u003cp\u003eæˆ‘å¯¹å…¶è¿›è¡Œäº†æ›´æ”¹ï¼Œå…¶åŠŸèƒ½æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œä½†ä¸ä¼šå‡ºç°ç¼–è¯‘æŠ¥é”™ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// transport/roots/system.go\n\nfunc NewSystem(_ map[string]string) ([]*x509.Certificate, error) {\n\tvar certs []*x509.Certificate\n\tcertpool, err := x509.SystemCertPool()\n\tif err != nil {\n\t\t// è¿”å› nilï¼Œå¦åˆ™ panic\n\t\treturn nil, nil\n\t}\n\tfor _, pem := range certpool.Subjects() {\n\t\tcert, err := helpers.ParseCertificatesPEM(pem)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcerts = append(certs, cert...)\n\t}\n\treturn certs, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæŸ¥çœ‹ Golang å®˜æ–¹ x509 åŒ…ä¸­ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc SystemCertPool() (*CertPool, error) {\n\tif runtime.GOOS == \"windows\" {\n\t\t// Issue 16736, 18609:\n\t\treturn nil, errors.New(\"crypto/x509: system root pool is not available on Windows\")\n\t}\n\t...\n\treturn loadSystemRoots()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWindows è·å–ä¸åˆ° system root poolã€‚\u003c/p\u003e\n\u003cp\u003eLinux ä¸­çš„ç³»ç»Ÿå†…ç½® CA è¯ä¹¦åœ¨ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage x509\n\n// Possible certificate files; stop after finding one.\nvar certFiles = []string{\n    \"/etc/ssl/certs/ca-certificates.crt\",                // Debian/Ubuntu/Gentoo etc.\n    \"/etc/pki/tls/certs/ca-bundle.crt\",                  // Fedora/RHEL 6\n    \"/etc/ssl/ca-bundle.pem\",                            // OpenSUSE\n    \"/etc/pki/tls/cacert.pem\",                           // OpenELEC\n    \"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\", // CentOS/RHEL 7\n    \"/etc/ssl/cert.pem\",                                 // Alpine Linux\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e2.3.2.2. è·å– CA è¯ä¹¦\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// transport/roots/provider.go\n\n// A TrustStore contains a pool of certificate that are trusted for a\n// given TLS configuration.\ntype TrustStore struct {\n   roots map[string]*x509.Certificate\n}\n\n// New produces a new trusted root provider from a collection of\n// roots. If there are no roots, the system roots will be used.\nfunc New(rootDefs []*core.Root) (*TrustStore, error) {\n\tvar err error\n\n\tvar store = \u0026#x26;TrustStore{}\n\tvar roots []*x509.Certificate\n\n    ...\n    \n\terr = errors.New(\"transport: no supported root providers found\")\n\tfor _, root := range rootDefs {\n\t\tpfn, ok := Providers[root.Type]\n\t\tif ok {\n\t\t\troots, err = pfn(root.Metadata)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tstore.addCerts(roots)\n\t\t}\n\t}\n\t...\n\treturn store, err\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå½“æˆ‘ä»¬æ·»åŠ ä¸€ä¸ª CA è¯ä¹¦æ¥æºæ—¶ï¼Œç¨‹åºä¼šè°ƒç”¨ \u003ccode\u003eProviders[root.Type]()\u003c/code\u003e è·å– CA è¯ä¹¦ã€‚\u003c/p\u003e\n\u003cp\u003eæ”¯æŒçš„ CA è¯ä¹¦æ¥æºæœ‰ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// Providers is a mapping of supported providers and the functions\n// that can build them.\nvar Providers = map[string]func(map[string]string) ([]*x509.Certificate, error){\n\t\"system\": NewSystem,\n\t\"cfssl\":  NewCFSSL,\n\t\"file\":   TrustPEM,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå…¶ä¸­ \u003cem\u003ecfssl\u003c/em\u003e æºè·å– CA è¯ä¹¦æ–¹æ³•å¦‚ä¸‹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// transport/roots/cfssl.go\n\n// NewCFSSL produces a new CFSSL root.\nfunc NewCFSSL(metadata map[string]string) ([]*x509.Certificate, error) {\n\thost, ok := metadata[\"host\"]\n\tif !ok {\n\t\treturn nil, errors.New(\"transport: CFSSL root provider requires a host\")\n\t}\n\n\tlabel := metadata[\"label\"]\n\tprofile := metadata[\"profile\"]\n    // è¿™é‡Œè·å–ä¸åˆ°è¯ä¹¦ä¼šè¿”å› nilï¼Œä¸ä¼šæŠ¥é”™\n\tcert, err := helpers.LoadClientCertificate(metadata[\"mutual-tls-cert\"], metadata[\"mutual-tls-key\"])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n    // è¿™é‡Œè·å–ä¸åˆ°è¯ä¹¦ä¼šè¿”å› nilï¼Œä¸ä¼šæŠ¥é”™\n\tremoteCAs, err := helpers.LoadPEMCertPool(metadata[\"tls-remote-ca\"])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n    // åˆ›å»º http/https å®¢æˆ·ç«¯\n\tsrv := client.NewServerTLS(host, helpers.CreateTLSConfig(remoteCAs, cert))\n\tdata, err := json.Marshal(info.Req{Label: label, Profile: profile})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n    // è°ƒç”¨ \"info\" API æ¥å£\n\tresp, err := srv.Info(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn helpers.ParseCertificatesPEM([]byte(resp.Certificate))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå®¢æˆ·ç«¯ä¼šè°ƒç”¨ 2.2.4.1 èŠ‚çš„æ¥å£ã€‚\u003c/p\u003e\n\u003ch4\u003e2.3.3. CA Provider\u003c/h4\u003e\n\u003cp\u003eåˆå Cert Providerã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// A CertificateAuthority is capable of signing certificates given\n// certificate signing requests.\ntype CertificateAuthority interface {\n\t// SignCSR submits a PKCS #10 certificate signing request to a\n\t// CA for signing.\n\tSignCSR(csrPEM []byte) (cert []byte, err error)\n\n\t// CACertificate returns the certificate authority's\n\t// certificate.\n\tCACertificate() (cert []byte, err error)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eç”¨äºä¸ CA è¿›è¡Œé€šä¿¡ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// transport/ca/cfssl_provider.go\n\n// SignCSR requests a certificate from a CFSSL signer.\nfunc (cap *CFSSL) SignCSR(csrPEM []byte) (cert []byte, err error) {\n\tp, _ := pem.Decode(csrPEM)\n\tif p == nil || p.Type != \"CERTIFICATE REQUEST\" {\n\t\treturn nil, errors.New(\"transport: invalid PEM-encoded certificate signing request\")\n\t}\n\n\tcsr, err := x509.ParseCertificateRequest(p.Bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// åŸæ¥è¿™ä¸ªåœ°æ–¹ä¸æ”¯æŒ SAN URI\n\thosts := make([]string, len(csr.DNSNames), len(csr.DNSNames)+len(csr.IPAddresses)+len(csr.URIs))\n\tcopy(hosts, csr.DNSNames)\n\n\tfor i := range csr.IPAddresses {\n\t\thosts = append(hosts, csr.IPAddresses[i].String())\n\t}\n\n\tfor i := range csr.URIs {\n\t\thosts = append(hosts, csr.URIs[i].String())\n\t}\n\n\tsreq := \u0026#x26;signer.SignRequest{\n\t\tHosts:   hosts,\n\t\tRequest: string(csrPEM),\n\t\tProfile: cap.Profile,\n\t\tLabel:   cap.Label,\n\t}\n\n\tout, err := json.Marshal(sreq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cap.provider != nil {\n\t\treturn cap.remote.AuthSign(out, nil, cap.provider)\n\t}\n\n\treturn cap.remote.Sign(out)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå‘ CA ä¸­å¿ƒå‘é€ CSR è¯·æ±‚ã€‚\u003c/p\u003e\n\u003ch4\u003e2.3.4. Key Provider\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// transport/kp/key_provider.go\n\n// A KeyProvider provides some mechanism for managing private keys and\n// certificates. It is not required to store the crypto.Signer itself.\ntype KeyProvider interface {\n   // Certificate returns the associated certificate, or nil if\n   // one isn't ready.\n   Certificate() *x509.Certificate\n\n   // Given some metadata about a certificate request, the\n   // provider should be able to generate a new CSR.\n   CertificateRequest(*csr.CertificateRequest) ([]byte, error)\n\n   // Check returns an error if the provider has an invalid setup.\n   Check() error\n\n   // Generate should trigger the creation of a new private\n   // key. This will invalidate any certificates stored in the\n   // key provider.\n   Generate(algo string, size int) error\n\n   // Load causes a private key and certificate associated with\n   // this provider to be loaded into memory and be prepared for\n   // use.\n   Load() error\n\n   // Persistent returns true if the provider keeps state on disk.\n   Persistent() bool\n\n   // Ready returns true if the provider has a key and\n   // certificate.\n   Ready() bool\n\n   // SetCertificatePEM takes a PEM-encoded certificate and\n   // associates it with this key provider.\n   SetCertificatePEM([]byte) error\n\n   // SignalFailure is used to notify the KeyProvider that an\n   // error has occurred obtaining a certificate. If this returns\n   // true, the caller should re-attempt to refresh the\n   // keys. This, for example, can be used to implement failover\n   // key providers that require different keys.\n   SignalFailure(err error) bool\n\n   // SignCSR allows a templated CSR to be signed.\n   SignCSR(csr *x509.CertificateRequest) ([]byte, error)\n\n   // Store should perform whatever actions are necessary such\n   // that a call to Load later will reload the key and\n   // certificate associated with this provider.\n   Store() error\n\n   // X509KeyPair returns a tls.Certficate. The returns\n   // tls.Certificate should have a parsed Leaf certificate.\n   X509KeyPair() (tls.Certificate, error)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå¯ä»¥çœ‹åˆ° Key Provider æ˜¯ç»™ Workload ä»¥ç”Ÿæˆç§é’¥ã€CSRã€è¯·æ±‚è¯ä¹¦ã€æŒä¹…åŒ–çš„èƒ½åŠ›ã€‚\u003c/p\u003e\n\u003cp\u003eæˆ‘ä»¬å¯¹è¯¥ package è¿›è¡Œäº†æ”¹é€ ï¼Œåœ¨ä¸Šå±‚ï¼ˆCapitalizoneï¼‰è¿›è¡Œäº†é‡å†™ï¼Œä»¥é…åˆ SPIFFE ID å…±åŒå·¥ä½œã€‚\u003c/p\u003e\n\u003ch4\u003e2.3.5. ç”Ÿå‘½å‘¨æœŸ\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ecfssl/transport\u003c/code\u003e åŒ…æä¾›äº† mTLS è¿æ¥çš„å°è£…ï¼ŒåŒ…æ‹¬è¯ä¹¦è½®è½¬åŠŸèƒ½ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// transport/client.go\n\n// A Transport is capable of providing transport-layer security using\n// TLS.\ntype Transport struct {\n\t// Before defines how long before the certificate expires the\n\t// transport should start attempting to refresh the\n\t// certificate. For example, if this is 24h, then 24 hours\n\t// before the certificate expires the Transport will start\n\t// attempting to replace it.\n\tBefore time.Duration\n\n\t// Provider contains a key management provider.\n\tProvider kp.KeyProvider\n\n\t// CA contains a mechanism for obtaining signed certificates.\n\tCA ca.CertificateAuthority\n\n\t// TrustStore contains the certificates trusted by this\n\t// transport.\n\tTrustStore *roots.TrustStore\n\n\t// ClientTrustStore contains the certificate authorities to\n\t// use in verifying client authentication certificates.\n\tClientTrustStore *roots.TrustStore\n\n\t// Identity contains information about the entity that will be\n\t// used to construct certificates.\n\tIdentity *core.Identity\n\n\t// Backoff is used to control the behaviour of a Transport\n\t// when it is attempting to automatically update a certificate\n\t// as part of AutoUpdate.\n\tBackoff *backoff.Backoff\n\n\t// RevokeSoftFail, if true, will cause a failure to check\n\t// revocation (such that the revocation status of a\n\t// certificate cannot be checked) to not be treated as an\n\t// error.\n\tRevokeSoftFail bool\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¿™é‡ŒåŒæ—¶å°†æè¿° mTLS é€šä¿¡çš„æ•´ä¸ªæµç¨‹ã€‚\u003c/p\u003e\n\u003ch5\u003e2.3.5.1. è·å–è¯ä¹¦\u003c/h5\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn a TLS handshake, the certificate presented by a remote server is sent alongside the \u003ccode\u003eServerHello\u003c/code\u003e message. At this point in the connection, the remote server has received the \u003ccode\u003eClientHello\u003c/code\u003e message, and that is all the information it needs to decide which certificate to present to the connecting client.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u0026#x3C;img src=\"https://diogomonica.com/content/images/2017/01/begining-tls-handshake-1.png\" width=\"400\" /\u003e\n\u003cp\u003eServerHello é˜¶æ®µä¼šä¼ è¾“è¯ä¹¦ï¼Œè¿™é‡Œæ¶‰åŠåˆ°ä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•çƒ­æ›´æ–°è¯ä¹¦ã€‚\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIt turns out that Go supports passing a callback in a TLS Config that will get executed every time a TLS \u003ccode\u003eClientHello\u003c/code\u003e is sent by a remote peer. This method is conveniently called \u003ccode\u003eGetCertificate\u003c/code\u003e, and it returns the certificate we wish to use for that particular TLS handshake.\u003c/p\u003e\n\u003cp\u003eThe idea of \u003ccode\u003eGetCertificate\u003c/code\u003e is to allow the dynamic  selection of which certificate to provide to a particular remote peer.  This method can be used to support virtual hosts, where one web server  is responsible for multiple domains, and therefore has to choose the  appropriate certificate to return to each remote peer.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eGolang çš„ tls åŒ…æä¾›äº†è·å–è¯ä¹¦çš„å‡½æ•°æ”¯æŒï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e    // GetCertificate returns a Certificate based on the given\n    // ClientHelloInfo. It will only be called if the client supplies SNI\n    // information or if Certificates is empty.\n    //\n    // If GetCertificate is nil or returns nil, then the certificate is\n    // retrieved from NameToCertificate. If NameToCertificate is nil, the\n    // best element of Certificates will be used.\n    GetCertificate func(*ClientHelloInfo) (*Certificate, error) // Go 1.4\n\n    // GetClientCertificate, if not nil, is called when a server requests a\n    // certificate from a client. If set, the contents of Certificates will\n    // be ignored.\n    //\n    // If GetClientCertificate returns an error, the handshake will be\n    // aborted and that error will be returned. Otherwise\n    // GetClientCertificate must return a non-nil Certificate. If\n    // Certificate.Certificate is empty then no certificate will be sent to\n    // the server. If this is unacceptable to the server then it may abort\n    // the handshake.\n    //\n    // GetClientCertificate may be called multiple times for the same\n    // connection if renegotiation occurs or if TLS 1.3 is in use.\n    GetClientCertificate func(*CertificateRequestInfo) (*Certificate, error) // Go 1.8\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ¯æ¬¡ TLS æ¡æ‰‹æ—¶ï¼Œ\u003ccode\u003eGetCertificate\u003c/code\u003e / \u003ccode\u003eGetClientCertificate\u003c/code\u003e æ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼Œæˆ‘ä»¬èƒ½å¤Ÿå®ç°è¿™ä¸ªæ–¹æ³•ï¼ŒåŠ¨æ€æ›´æ–°è¯ä¹¦ã€‚\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://diogomonica.com/2017/01/11/hitless-tls-certificate-rotation-in-go/\"\u003eç¤ºä¾‹ä»£ç \u003c/a\u003eï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype wrappedCertificate struct {\n\tsync.Mutex\n\tcertificate *tls.Certificate\n}\n\nfunc (c *wrappedCertificate) getCertificate(clientHello *tls.ClientHelloInfo) (*tls.Certificate, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\treturn c.certificate, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u0026#x3C;img src=\"https://diogomonica.com/content/images/2017/01/golang-new-certificate-being-served.png\" height=\"400\" /\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOld established connections using the previous certificate will remain  active, but new connections coming in to our TLS server will use the  most recent certificate.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch5\u003e2.3.5.2. è¯ä¹¦è½®è½¬\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// transport/client.go\n\n// AutoUpdate will automatically update the listener. If a non-nil\n// certUpdates chan is provided, it will receive timestamps for\n// reissued certificates. If errChan is non-nil, any errors that occur\n// in the updater will be passed along.\nfunc (tr *Transport) AutoUpdate(certUpdates chan\u0026#x3C;- time.Time, errChan chan\u0026#x3C;- error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Criticalf(\"AutoUpdate panicked: %v\", r)\n\t\t}\n\t}()\n\n\tfor {\n\t\t// Wait until it's time to update the certificate.\n\t\ttarget := time.Now().Add(tr.Lifespan())\n\t\tif PollInterval == 0 {\n\t\t\t\u0026#x3C;-time.After(tr.Lifespan())\n\t\t} else {\n\t\t\tpollWait(target)\n\t\t}\n\n\t\t// Keep trying to update the certificate until it's\n\t\t// ready.\n\t\tfor {\n\t\t\tlog.Debugf(\"attempting to refresh keypair\")\n\t\t\terr := tr.RefreshKeys()\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tdelay := tr.Backoff.Duration()\n\t\t\tlog.Debugf(\"failed to update certificate, will try again in %s\", delay)\n\t\t\tif errChan != nil {\n\t\t\t\terrChan \u0026#x3C;- err\n\t\t\t}\n\n\t\t\t\u0026#x3C;-time.After(delay)\n\t\t}\n\n\t\tlog.Debugf(\"certificate updated\")\n\t\tif certUpdates != nil {\n\t\t\tcertUpdates \u0026#x3C;- time.Now()\n\t\t}\n\n\t\ttr.Backoff.Reset()\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¯¥æ–¹æ³•ä¼šä¿æŒä¸€ä¸ªåç¨‹è¿è¡Œï¼Œæ£€æŸ¥è¯ä¹¦æœ‰æ•ˆæ—¶é—´ï¼Œå®šæ—¶æ›´æ–°è¯ä¹¦ã€‚\u003c/p\u003e\n\u003ch5\u003e2.3.5.3. CA è¯ä¹¦è®¤è¯\u003c/h5\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// transport/client.go\n\n// TLSClientAuthClientConfig returns a new client authentication TLS\n// configuration that can be used for a client using client auth\n// connecting to the named host.\nfunc (tr *Transport) TLSClientAuthClientConfig(host string) (*tls.Config, error) {\n\tcert, err := tr.getCertificate()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026#x26;tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t\tRootCAs:      tr.TrustStore.Pool(),\n\t\tServerName:   host,\n\t\tCipherSuites: core.CipherSuites,\n\t\tMinVersion:   tls.VersionTLS12,\n\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t}, nil\n}\n\n// TLSClientAuthServerConfig returns a new client authentication TLS\n// configuration for servers expecting mutually authenticated\n// clients. The clientAuth parameter should contain the root pool used\n// to authenticate clients.\nfunc (tr *Transport) TLSClientAuthServerConfig() (*tls.Config, error) {\n\tlogger.DEBUG.Print(\"------------------------ è·å–æœåŠ¡å™¨è¯ä¹¦\")\n\tcert, err := tr.getCertificate()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlogger.DEBUG.Print(\"------------------------ OK æœåŠ¡å™¨è¯ä¹¦\")\n\treturn \u0026#x26;tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t\tRootCAs:      tr.TrustStore.Pool(),\n\t\tClientCAs:    tr.ClientTrustStore.Pool(),\n\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\tCipherSuites: core.CipherSuites,\n\t\tMinVersion:   tls.VersionTLS12,\n\t}, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eServer ç«¯å’Œ Client ç«¯çš„åŒºåˆ«åœ¨äºï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eServer ç«¯ \u003ccode\u003etls.Config\u003c/code\u003e éœ€è¦ \u003ccode\u003eClientCAs\u003c/code\u003e å‚æ•°\u003c/li\u003e\n\u003cli\u003eClient ç«¯éœ€è¦ \u003ccode\u003eServerName\u003c/code\u003e å‚æ•°\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eServer ç«¯çš„  \u003ccode\u003eClientCAs\u003c/code\u003e å’Œ Client ç«¯çš„ \u003ccode\u003eRootCAs\u003c/code\u003e éœ€è¦åŒ…å« Root CA å’Œ ICA è¯ä¹¦ã€‚\u003c/p\u003e\n\u003ch5\u003e2.3.5.4. è¯ä¹¦éªŒè¯\u003c/h5\u003e\n\u003cp\u003eé™¤äº†ä¸€èˆ¬çš„è¯ä¹¦æ ¡éªŒä»¥å¤–ï¼ŒIstio è¿˜é€šè¿‡è‡ªå®šä¹‰æ ¡éªŒæ–¹æ³•ï¼Œè¿›è¡Œäº† SPIFFE ID çš„éªŒè¯ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e    // VerifyPeerCertificate, if not nil, is called after normal\n    // certificate verification by either a TLS client or server. It\n    // receives the raw ASN.1 certificates provided by the peer and also\n    // any verified chains that normal processing found. If it returns a\n    // non-nil error, the handshake is aborted and that error results.\n    //\n    // If normal verification fails then the handshake will abort before\n    // considering this callback. If normal verification is disabled by\n    // setting InsecureSkipVerify, or (for a server) when ClientAuth is\n    // RequestClientCert or RequireAnyClientCert, then this callback will\n    // be considered but the verifiedChains argument will always be nil.\n    VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error // Go 1.8\n\n    // VerifyConnection, if not nil, is called after normal certificate\n    // verification and after VerifyPeerCertificate by either a TLS client\n    // or server. If it returns a non-nil error, the handshake is aborted\n    // and that error results.\n    //\n    // If normal verification fails then the handshake will abort before\n    // considering this callback. This callback will run for all connections\n    // regardless of InsecureSkipVerify or ClientAuth settings.\n    VerifyConnection func(ConnectionState) error // Go 1.15\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eVerifyPeerCertificate\u003c/code\u003e é‡Œèƒ½å¤Ÿæä¾› SPIFFE çš„è®¤è¯ï¼Œ\u003ccode\u003eVerifyConnection\u003c/code\u003e èƒ½å¤Ÿé€šè¿‡ SDK æä¾›è‡ªå®šä¹‰è®¤è¯ã€‚\u003c/p\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]\n"])</script></body></html>