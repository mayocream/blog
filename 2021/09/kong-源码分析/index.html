<!doctype html><html lang=ja><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Kong æºç åˆ†æ - Mayo's Blog</title>
<meta name=description content="æœ¬æ–‡æœ€åˆäº 2020 å¹´ 9 æœˆåœ¨å…¬å¸å†…éƒ¨å‘è¡¨ï¼Œç°æ•´ç†å¹¶å¢åŠ éƒ¨åˆ†æ‰¹æ³¨å…¬å¼€å‘å¸ƒã€‚ æœ€å¼€å§‹åŠ å…¥å…¬å¸ Infrastructure å›¢é˜Ÿæ—¶ï¼Œè¿·èŒ«çš„æˆ‘æ¥åˆ°çš„çš„ä¸€ä¸ªä»»åŠ¡å°±æ˜¯å­¦ä¹  Lua å’Œ OpenRest">
<meta name=author content>
<link rel=preconnect href=https://cdn.jsdelivr.net>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Press+Start+2P" rel=stylesheet>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400&family=Noto+Sans+JP:wght@300;400&family=Noto+Sans+SC:wght@300;400&family=Noto+Serif:wght@300;400&family=Noto+Serif+JP:wght@300;400&family=Noto+Serif+SC:wght@300;400&family=Source+Code+Pro:wght@300;400" rel=stylesheet>
<link rel=stylesheet href="/bundle.css?v=1737040591" media=all>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.css>
<link rel=icon href=https://github.com/mayocream.png><meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://mayo.rocks/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><meta property="og:title" content="Kong æºç åˆ†æ">
<meta property="og:description" content="æœ¬æ–‡æœ€åˆäº 2020 å¹´ 9 æœˆåœ¨å…¬å¸å†…éƒ¨å‘è¡¨ï¼Œç°æ•´ç†å¹¶å¢åŠ éƒ¨åˆ†æ‰¹æ³¨å…¬å¼€å‘å¸ƒã€‚ æœ€å¼€å§‹åŠ å…¥å…¬å¸ Infrastructure å›¢é˜Ÿæ—¶ï¼Œè¿·èŒ«çš„æˆ‘æ¥åˆ°çš„çš„ä¸€ä¸ªä»»åŠ¡å°±æ˜¯å­¦ä¹  Lua å’Œ OpenRest">
<meta property="og:type" content="article">
<meta property="og:url" content="https://mayo.rocks/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-21T04:30:00+08:00">
<meta property="article:modified_time" content="2021-09-21T04:30:00+08:00"><meta property="og:site_name" content="Mayo's Blog">
</head>
</html>
<body><script src=https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>const opts={bottom:'32px',right:'unset',left:'32px',time:'0.3s',mixColor:'#fff',backgroundColor:'#fff',buttonColorDark:'#100f2c',buttonColorLight:'#fff',saveInCookies:!0,label:'ğŸŒ“',autoMatchOsTheme:!0};let darkmode;window.matchMedia('only screen and (min-width: 680px)').matches?(darkmode=new Darkmode(opts),darkmode.showWidget()):(localStorage.removeItem('darkmode'),darkmode=new Darkmode(opts)),window.darkmode=darkmode,document.addEventListener('DOMContentLoaded',function(){document.body.style.opacity=1})</script>
<main class=page-content aria-label=Content>
<div class=wrapper><nav class=site-nav>
<a class=page-link href=/posts/>Posts</a>
<a class=page-link href=/about/>About</a>
</nav><header class=post-header>
<a class=site-title href=https://mayo.rocks>Mayo's Blog</a>
<h1 class="post-title baseline-fix typeface-sans" lang=zh-hans itemprop="name headline">Kong æºç åˆ†æ</h1>
</header>
<div class=post-cover aria-label=Cover>
<div class=post-cover-wrapper>
<img src alt>
</div>
<div class=cover-meta></div>
</div>
<div class=post-layout>
<article class="post typeface-sans" lang=zh-hans itemscope itemtype=http://schema.org/BlogPosting>
<div class=post-content itemprop=articleBody>
<p>æœ¬æ–‡æœ€åˆäº 2020 å¹´ 9 æœˆåœ¨å…¬å¸å†…éƒ¨å‘è¡¨ï¼Œç°æ•´ç†å¹¶å¢åŠ éƒ¨åˆ†æ‰¹æ³¨å…¬å¼€å‘å¸ƒã€‚</p>
<p>æœ€å¼€å§‹åŠ å…¥å…¬å¸ Infrastructure å›¢é˜Ÿæ—¶ï¼Œè¿·èŒ«çš„æˆ‘æ¥åˆ°çš„çš„ä¸€ä¸ªä»»åŠ¡å°±æ˜¯å­¦ä¹  Lua å’Œ <a href=https://github.com/openresty/lua-nginx-module>OpenResty</a>ï¼Œå½“æ—¶æ”¶åˆ°äº†ä¸¤æœ¬ä¹¦ç±çš„ PDF æ–‡ä»¶ï¼Œè¦æ±‚å°½å¿«ç†è§£å­¦ä¹ ï¼Œèƒ½å¤ŸæŒæ¡ <a href=https://github.com/Kong/kong>Kong</a>ï¼Œå¹¶ä¸”å…·æœ‰ç ”å‘èƒ½åŠ›ã€‚</p>
<p>å½“æ—¶æˆ‘è¿˜æ²¡æœ‰æ€ä¹ˆæ¥è§¦å¼€æºç¤¾åŒºï¼Œèƒ½åŠ›åªåœç•™åœ¨ Git Cloneï¼Œå¤§æ¦‚èŠ±äº† 2 å‘¨æ—¶é—´ï¼Œæˆ‘å­¦ä¹  Lua åŸºæœ¬è¯­æ³•åï¼Œå¼€å§‹é˜…è¯» Kong é¡¹ç›®çš„æºç ï¼Œå¹¶æ‰¾åˆ°å‡ ä¸ªåˆ‡å…¥ç‚¹æ¢³ç†äº†æºç åˆ†ææ–‡æ¡£ï¼Œä¹Ÿåº”è¯¥æ­£æ˜¯è¿™ä¸ªæˆæœè®©ç»„é•¿è®¤åŒäº†æˆ‘ï¼Œè¿™ä¹‹åæˆ‘è´Ÿè´£å…¬å¸ API Gateway çš„å¼€å‘ï¼Œä»¥åŠç›¸å…³çš„è½åœ°å·¥ä½œã€‚</p>
<p>é‚£ä¹ˆæœ¬æ–‡é’ˆå¯¹ Kong çš„å¯åŠ¨æµç¨‹ã€æ’ä»¶æœºåˆ¶ã€ç¼“å­˜æœºåˆ¶å’Œè¯·æ±‚çš„ç”Ÿå‘½å‘¨æœŸåšäº†è¯¦ç»†çš„é˜è¿°ï¼Œä¸è¿‡ä»æœ‰æ¬ ç¼ºçš„æ˜¯ä»£ç†è½¬å‘åŠŸèƒ½ï¼Œä¾‹å¦‚è´Ÿè½½å‡è¡¡ã€å¥åº·æ£€æŸ¥ã€æœåŠ¡å‘ç°ç­‰ï¼Œä¸è¿‡ä»‹äºå½“æ—¶çš„æˆ‘è¿˜æ˜¯ä¸ªæ‡µæ‡‚çš„æ–°äººï¼Œè¿™é‡Œå°±å…ˆåŸè°…æˆ‘è‡ªå·±äº† ğŸ¾ã€‚</p>
<p>ç»§è¿™ç¯‡æ–‡ç« ä¹‹åï¼Œæˆ‘è¿˜æ’°å†™äº† Kong Ingress Controller æºç åˆ†æï¼Œåç»­è¿˜æœ‰ APISIX çš„æºç åˆ†æå“¦ã€‚</p>
<h2 id=1-æ¦‚è¿°>1. æ¦‚è¿°</h2>
<p>æœ¬æ–‡é’ˆå¯¹çš„æ˜¯ Kong 2.1 ç‰ˆæœ¬ï¼ˆStableï¼‰ã€‚</p>
<p>æˆ‘é˜…è¯»å¹¶ä½œå‡ºä¸­æ–‡æ³¨é‡Šçš„ Commits å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ï¼š
<a href="https://github.com/mayocream/kong/commits?author=huanghan39">https://github.com/mayocream/kong/commits?author=mayocream</a></p>
<p><strong>Kongï¼ˆOpenRestyï¼‰çš„æ‰§è¡Œé˜¶æ®µ</strong>ï¼š</p>
<p>
<figure class=image>
<img src=/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/openresty_phases.png alt loading=lazy>
</figure></p>
<p>Kong çš„æ’ä»¶æœºåˆ¶ä¹Ÿæ˜¯åŸºäº OpenResty çš„ç”Ÿå‘½å‘¨æœŸï¼Œåªä¸è¿‡æ˜¯å…¶åœ¨ä¸Šå±‚åšäº†äº›è®¸å°è£…ã€‚</p>
<p><strong>Kong çš„æ•°æ®åº“å…³è”å…³ç³»</strong>ï¼š</p>
<p>
<figure class=image>
<img src=/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/kong_db.png alt loading=lazy>
</figure></p>
<p>Kong è™½ç„¶æ ‡ç§°è‡ªå·±æ˜¯ Cloud Native é¡¹ç›®<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>ï¼Œä¹Ÿä¸Šæ¦œäº† CNCF <a href=https://landscape.cncf.io/>å…¨æ™¯å›¾</a>ï¼Œä½†æ˜¯å®ƒè¿˜ä¾èµ–äºä¼ ç»Ÿçš„æ•°æ®åº“ PostgreSQLï¼Œå¹¶ä¸”è¿˜è‡ªå®šä¹‰äº†è®¸å¤š functionï¼Œç›¸æ¯”äº APISIX èƒŒåå‚¨å­˜ Etcd è¦å¼±äº†è®¸å¤šã€‚æ¯”èµ· Etcd èƒ½å»ºç«‹ HTTP é•¿è¿æ¥ Watch æ•°æ®å˜åŒ–ï¼ŒKong åªèƒ½ä¾èµ–å®šæ—¶çš„è½®è¯¢ä»æ•°æ®åº“æ›´æ–°çŠ¶æ€ï¼Œæ•°æ®åº“é«˜å¯ç”¨ä¹Ÿç›¸æ¯” Etcd é›†ç¾¤è¦å¤æ‚å¾—å¤šã€‚</p>
<h2 id=2-é…ç½®æ–‡ä»¶>2. é…ç½®æ–‡ä»¶</h2>
<p>Kong åœ¨å¯åŠ¨é˜¶æ®µä¼šè§£æ <a href=https://github.com/kong/kong/tree/master/kong/templates><code>kong/templates</code></a> ç›®å½•ä¸‹çš„ <code>.lua</code> æ¨¡æ¿æ–‡ä»¶ï¼Œæ³¨å…¥ç¯å¢ƒå˜é‡å’Œ <code>kong.conf</code> è¦†ç›–é…ç½®ï¼Œç”Ÿæˆ Nginx å¯åŠ¨çš„é…ç½®æ–‡ä»¶ <code>nginx.conf</code>ã€‚</p>
<p>ç»“æ„å¦‚ä¸‹ï¼š</p>
<pre><code class=language-yaml>pid pids/nginx.pid;
error_log logs/error.log notice;

# injected nginx_main_* directives

env SKYWALKING_URL;

events {
    # injected nginx_events_* directives
    multi_accept on;
    worker_connections 16384;
}

http {
    lua_package_path       './?.lua;./?/init.lua;;;;';
    lua_package_cpath      ';;;';

    lua_shared_dict kong                        5m;
    lua_shared_dict kong_locks                  8m;
	...

    # injected nginx_http_* directives
    client_body_buffer_size 8k;

    init_by_lua_block {
        Kong = require 'kong'
        Kong.init()
    }

    init_worker_by_lua_block {
        Kong.init_worker()
    }

    upstream kong_upstream {
        server 0.0.0.1;

        # injected nginx_upstream_* directives

        balancer_by_lua_block {
            Kong.balancer()
        }
    }

	# Kong Proxy
    server {
        server_name kong;
		...
    }

	# Kong Admin API
    server {
        server_name kong_admin;
        ...
    }


}
</code></pre>
<p>Kong å®šä¹‰äº† <code>NGINX_MAIN_XXX</code>ï¼Œè¯¸å¦‚æ­¤ç±»çš„ç¯å¢ƒå˜é‡ï¼Œåœ¨è§£æé…ç½®é˜¶æ®µä¼šåŠ è½½åˆ° <code>nginx.conf</code> çš„æŒ‡å®šä½ç½®ï¼Œèƒ½å¤Ÿé¿å…ç›´æ¥ä¿®æ”¹æ¨¡æ¿æ–‡ä»¶ã€‚</p>
<p>ä¾‹å¦‚ï¼š</p>
<pre><code class=language-bash># åœ¨ main å—é‡Œå®šä¹‰ env å˜é‡
$ export NGINX_MAIN_ENV SKYWALKING_URL;
# åˆ›å»ºæ–°çš„ lua shared dict
$ export NGINX_HTTP_Lua_SHARED_DICT tracing_buffer 128m;
</code></pre>
<p>Kong <a href=https://docs.konghq.com/2.1.x/configuration/>å®˜æ–¹çš„é…ç½®æ–‡æ¡£</a>å·²ç»éå¸¸è¯¦å°½ï¼Œè§£é‡Šäº†å„ä¸ªå‚æ•°ä»£è¡¨çš„å«ä¹‰ã€‚</p>
<p>è¿™é‡Œè¡¥å……ä¸€ç‚¹ï¼Œé€šå¸¸æˆ‘ä»¬éœ€è¦å®šä¹‰å¤šä¸ª Shared dictï¼Œé…ç½®å†™æ³•éœ€è¦æ”¹æˆè¿™ç§ä¸‘é™‹çš„å½¢å¼ï¼š</p>
<pre><code>nginx_http_lua_shared_dict = cache_buffer_one 128m; lua_shared_dict cache_buffer_two 128m
</code></pre>
<h2 id=3-åˆå§‹åŒ–>3. åˆå§‹åŒ–</h2>
<h3 id=31-æ•°æ®åº“åˆå§‹åŒ–>3.1. æ•°æ®åº“åˆå§‹åŒ–</h3>
<p><code>Kong.init()</code> æ–¹æ³•ä¸­åˆå§‹åŒ–æ•°æ®åº“ç›¸å…³ï¼š</p>
<pre><code class=language-lua>  -- æ•°æ®åº“è¿æ¥ç›¸å…³
  local db = assert(DB.new(config))
  assert(db:init_connector())
  kong.db = db
</code></pre>
<p><code>DB.new()</code> æ–¹æ³•ä¸­ä¾æ¬¡è°ƒç”¨äº† <code>Schema.new()</code>ã€<code>Entity.new()</code>ã€<code>DAO.new()</code> æ–¹æ³•ï¼Œä¸‹é¢ä¸€ä¸ªä¸ªæ¥è¯´æ˜ã€‚</p>
<h4 id=311-schema>3.1.1. Schema</h4>
<p>Kong çš„ Schema æ•°æ®ç»“æ„ä½“ä½äº <code>db/schema/entities</code> ä¸‹ï¼Œå°± <code>routes.lua</code> ä¸ºä¾‹ï¼š</p>
<pre><code class=language-lua>local typedefs = require &quot;kong.db.schema.typedefs&quot;


return {
  name         = &quot;routes&quot;,
  primary_key  = { &quot;id&quot; },
  endpoint_key = &quot;name&quot;,
  workspaceable = true,
  subschema_key = &quot;protocols&quot;,

  fields = {
    { id             = typedefs.uuid, },
    { created_at     = typedefs.auto_timestamp_s },
    { updated_at     = typedefs.auto_timestamp_s },
    { name           = typedefs.name },
    { protocols      = { type     = &quot;set&quot;,
                         len_min  = 1,
                         required = true,
                         elements = typedefs.protocol,
                         mutually_exclusive_subsets = {
                           { &quot;http&quot;, &quot;https&quot; },
                           { &quot;tcp&quot;, &quot;tls&quot; },
                           { &quot;grpc&quot;, &quot;grpcs&quot; },
                         },
                         default = { &quot;http&quot;, &quot;https&quot; }, -- TODO: different default depending on service's scheme
                       }, },
    { methods        = typedefs.methods },
    { hosts          = typedefs.hosts },
    { paths          = typedefs.paths },
    { headers        = typedefs.headers },
    { https_redirect_status_code = { type = &quot;integer&quot;,
                                     one_of = { 426, 301, 302, 307, 308 },
                                     default = 426, required = true,
                                   }, },
    { regex_priority = { type = &quot;integer&quot;, default = 0 }, },
    { strip_path     = { type = &quot;boolean&quot;, default = true }, },
    { path_handling  = { type = &quot;string&quot;, default = &quot;v0&quot;, one_of = { &quot;v0&quot;, &quot;v1&quot; }, }, },
    { preserve_host  = { type = &quot;boolean&quot;, default = false }, },
    { snis = { type = &quot;set&quot;,
               elements = typedefs.sni }, },
    { sources = typedefs.sources },
    { destinations = typedefs.destinations },
    { tags             = typedefs.tags },
    { service = { type = &quot;foreign&quot;, reference = &quot;services&quot; }, },
  },

  entity_checks = {
    { conditional = { if_field = &quot;protocols&quot;,
                      if_match = { elements = { type = &quot;string&quot;, not_one_of = { &quot;grpcs&quot;, &quot;https&quot;, &quot;tls&quot; }}},
                      then_field = &quot;snis&quot;,
                      then_match = { len_eq = 0 },
                      then_err = &quot;'snis' can only be set when 'protocols' is 'grpcs', 'https' or 'tls'&quot;,
                    }},
                  }
}

</code></pre>
<p><code>primary_key</code> æ˜¯åœ¨æ•°æ®åº“ä¸­ä¸»é”®ä¹Ÿæ˜¯å½“ <code>cache_key</code> æœªå®šä¹‰æ—¶çš„é»˜è®¤ <code>cache_key</code>ã€‚</p>
<p>æœ‰ <code>type=foreign</code> çš„æƒ…å†µï¼Œentity åŠ è½½æ—¶ä¼šå½“ä½œ subschema åŠ è½½è¿›æ¥ã€‚</p>
<p>æ’ä»¶ä¸åŒäºå…¶ä»– entityï¼Œæœ‰ç‰¹å®š cache_keyã€‚</p>
<pre><code class=language-lua>  name = &quot;plugins&quot;,
  primary_key = { &quot;id&quot; },
  cache_key = { &quot;name&quot;, &quot;route&quot;, &quot;service&quot;, &quot;consumer&quot; },
</code></pre>
<p>Cache ç›¸å…³æ“ä½œä¸­è°ƒç”¨ <code>Entity.cache_key()</code> è·å–ã€‚</p>
<pre><code class=language-lua>    local cache_key = dao:cache_key(entity)
    local ok, err = cache:safe_set(cache_key, entity)
</code></pre>
<p>å…·ä½“ç”Ÿæˆ <code>cache_key</code> çš„æ–¹æ³•ï¼Œè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºç¼“å­˜ keyã€‚</p>
<pre><code class=language-lua>function DAO:cache_key(key, arg2, arg3, arg4, arg5, ws_id)

  if self.schema.workspaceable then
    ws_id = ws_id or workspaces.get_workspace_id()
  end

  -- Fast path: passing the cache_key/primary_key entries in
  -- order as arguments, this produces the same result as
  -- the generic code below, but building the cache key
  -- becomes a single string.format operation
  if type(key) == &quot;string&quot; then
    return fmt(&quot;%s:%s:%s:%s:%s:%s:%s&quot;, self.schema.name,
               key == nil and &quot;&quot; or key,
               arg2 == nil and &quot;&quot; or arg2,
               arg3 == nil and &quot;&quot; or arg3,
               arg4 == nil and &quot;&quot; or arg4,
               arg5 == nil and &quot;&quot; or arg5,
               ws_id == nil and &quot;&quot; or ws_id)
  end

  -- Generic path: build the cache key from the fields
  -- listed in cache_key or primary_key

  if type(key) ~= &quot;table&quot; then
    error(&quot;key must be a string or an entity table&quot;, 2)
  end

  if key.ws_id then
    ws_id = key.ws_id
  end

  local values = new_tab(7, 0)
  values[1] = self.schema.name
  local source = self.schema.cache_key or self.schema.primary_key

  local i = 2
  for _, name in ipairs(source) do
    local field = self.schema.fields[name]
    local value = key[name]
    if value == null or value == nil then
      value = &quot;&quot;
    elseif field.type == &quot;foreign&quot; then
      -- FIXME extract foreign key, do not assume `id`
      value = value.id
    end
    values[i] = tostring(value)
    i = i + 1
  end
  for n = i, 6 do
    values[n] = &quot;&quot;
  end

  values[7] = ws_id or &quot;&quot;

  return concat(values, &quot;:&quot;)
end
</code></pre>
<p><code>schema/init.lua</code> ä¸­å®šä¹‰äº† schema ç›¸å…³æ“ä½œçš„åŸºæœ¬æ–¹æ³•ï¼š</p>
<pre><code class=language-lua>-- each_field() ç”¨äºéå† schema çš„ fields
-- æ˜¯ schema ç›¸å…³æ“ä½œæœ€é¢‘ç¹çš„
function Schema:each_field(values)
  local i = 1

  local subschema
  if values then
    subschema = get_subschema(self, values)
  end

  return function()
    local item = self.fields[i]
    if not item then
      return nil
    end
    local key = next(item)
    local field = resolve_field(self, key, item[key], subschema)
    i = i + 1
    return key, field
  end
end
</code></pre>
<p><code>Schema.new()</code> æ–¹æ³•ä¸­é€šè¿‡å…ƒç»„è®¾ç½® <code>__index</code> è®©ç»“æ„ä½“ç»§æ‰¿ Schema ä¸‹å®šä¹‰çš„ä¸€ç³»åˆ—æ“ä½œæ–¹æ³•ã€‚</p>
<pre><code class=language-lua>function Schema.new(definition, is_subschema)
  if not definition then
    return nil, validation_errors.SCHEMA_NO_DEFINITION
  end

  if not definition.fields then
    return nil, validation_errors.SCHEMA_NO_FIELDS
  end

  local self = copy(definition)

  -- ç»§æ‰¿ Schema ä¸‹å®šä¹‰çš„ä¸€ç³»åˆ—æ“ä½œæ–¹æ³•
  setmetatable(self, Schema)

  -- entity ç¼“å­˜çš„ cache_keyï¼Œ
  -- å¦‚æœæ²¡æœ‰è¿™ä¸ªå­—æ®µï¼Œåˆ™é»˜è®¤ä½¿ç”¨ schema å®šä¹‰çš„
  -- primary_key æ¥ä½œä¸º cache_key
  -- cache_key æ˜¯ä¸ªæ•°ç»„ï¼Œ
  -- è¿™é‡Œåªæ˜¯åˆ†å¼€å‚¨å­˜
  if self.cache_key then
    self.cache_key_set = {}
    for _, name in ipairs(self.cache_key) do
      self.cache_key_set[name] = true
    end
  end


  -- é€šè¿‡å…ƒç»„ __index æ–¹æ³•è°ƒç”¨ Schema:each_field() æ–¹æ³•
  -- éå† schema çš„ fields table
  for key, field in self:each_field() do
    -- Also give access to fields by name
    self.fields[key] = field
    if field.type == &quot;record&quot; and field.fields then
      allow_record_fields_by_name(field)
    end

    -- å¦‚æœæœ‰å¤–é”®
    -- åˆ™åŠ è½½å¤–é”®å…³è”çš„ schema è¿›æ¥
    if field.type == &quot;foreign&quot; then
      local err
      field.schema, err = get_foreign_schema_for_field(field)
      if not field.schema then
        return nil, err
      end

      if not is_subschema then
        -- Store the inverse relation for implementing constraints
        local constraints = assert(_cache[field.reference]).constraints
        table.insert(constraints, {
          schema     = self,
          field_name = key,
          on_delete  = field.on_delete,
        })
      end
    end
  end

  if self.workspaceable and self.name then
    if not _workspaceable[self.name] then
      _workspaceable[self.name] = true
      table.insert(_workspaceable, { schema = self })
    end
  end

  if self.name then
    -- do not reset the constraints list if a schema in reloaded
    if not _cache[self.name] then
      _cache[self.name] = {
        constraints = {},
      }
    end
    -- but always update the schema object in cache
    _cache[self.name].schema = self
  end

  return self
end
</code></pre>
<p>ç”¨äºä¸‹çº§ç»§æ‰¿çš„å…ƒç»„ï¼Œè™šæ™ƒä¸€æªã€‚</p>
<pre><code class=language-lua>local Schema       = {}
Schema.__index     = Schema
</code></pre>
<h4 id=312-entity>3.1.2. Entity</h4>
<p>Entity åªæ˜¯ç®€å•å¯¹ Schema è¿›è¡Œä¸€å±‚å°è£…ã€‚</p>
<pre><code class=language-lua>-- definition æ˜¯ schema ç»“æ„ä½“
function Entity.new(definition)

  -- åˆå§‹åŒ– Schema å¯¹è±¡
  local self, err = Schema.new(definition)
  if not self then
    return nil, err
  end

  -- éå† schema fields
  for name, field in self:each_field() do
    if field.nilable then
      return nil, entity_errors.NO_NILABLE:format(name)
    end

    if field.abstract then
      goto continue
    end

    if field.type == &quot;map&quot; then
      if field.keys.type ~= &quot;string&quot; then
        return nil, entity_errors.MAP_KEY_STRINGS_ONLY:format(name)
      end

    elseif field.type == &quot;record&quot; then
      make_records_required(field)

    elseif field.type == &quot;function&quot; then
      return nil, entity_errors.NO_FUNCTIONS:format(name)
    end

    ::continue::
  end

  self.new_subschema = Entity.new_subschema

  return self
end

</code></pre>
<p>Entity å¯¹è±¡éšåè¢«åŠ è½½åˆ° <code>DB.new()</code> å‡½æ•°ä¸­ï¼š</p>
<pre><code class=language-lua>local schemas = {}

do
  -- load schemas
  -- core entities are for now the only source of schemas.
  -- TODO: support schemas from plugins entities as well.

  -- è½½å…¥æ ¸å¿ƒ entityï¼Œä¸ºä»€ä¹ˆæ˜¯æ ¸å¿ƒ entity
  -- å› ä¸ºè¿˜æœ‰ plugin è‡ªå®šä¹‰çš„ entity
  -- è¿™äº› entity æ˜¯ Kong è‡ªèº«çš„
  for _, entity_name in ipairs(constants.CORE_ENTITIES) do

    -- åŠ è½½ schemaï¼ˆæ•°æ®ç»“æ„ä½“ï¼‰
    local entity_schema = require(&quot;kong.db.schema.entities.&quot; .. entity_name)

    -- validate core entities schema via metaschema
    local ok, err_t = MetaSchema:validate(entity_schema)
    if not ok then
      return nil, fmt(&quot;schema of entity '%s' is invalid: %s&quot;, entity_name,
                      tostring(errors:schema_violation(err_t)))
    end

    -- åŠ è½½ entity å¯¹è±¡
    local entity, err = Entity.new(entity_schema)
    if not entity then
      return nil, fmt(&quot;schema of entity '%s' is invalid: %s&quot;, entity_name,
                      err)
    end
    schemas[entity_name] = entity

    -- load core entities subschemas
    local subschemas
    ok, subschemas = utils.load_module_if_exists(&quot;kong.db.schema.entities.&quot; .. entity_name .. &quot;_subschemas&quot;)
    if ok then
      for name, subschema in pairs(subschemas) do
        local ok, err = entity:new_subschema(name, subschema)
        if not ok then
          return nil, (&quot;error initializing schema for %s: %s&quot;):format(entity_name, err)
        end
      end
    end
  end
end
</code></pre>
<h4 id=313-dao>3.1.3. DAO</h4>
<p><code>db/dao/init.lua</code> ä¸­å®šä¹‰äº†ä¸€ç³»åˆ—å¯¹æ•°æ®åº“æ“ä½œçš„æ–¹æ³•ï¼Œä¾‹å¦‚ï¼š</p>
<pre><code class=language-lua>function DAO:select(primary_key, options)
function DAO:page(size, offset, options)
function DAO:each(size, options)
function DAO:insert(entity, options)
function DAO:update(primary_key, entity, options)
function DAO:delete(primary_key, options)
...
</code></pre>
<p><code>DAO.new()</code> ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å« db è¿æ¥ä¿¡æ¯ï¼Œentity çš„ tableã€‚</p>
<pre><code class=language-lua>-- schema å‚æ•°æ˜¯ Entity å¯¹è±¡
--  DB ç»“æ„ä½“ï¼š  local self   = {
  --    daos       = daos,       -- each of those has the connector singleton
  --    strategies = strategies,
  --    connector  = connector,
  --    strategy   = strategy,
  --    errors     = errors,
  --    infos      = connector:infos(),
  --    kong_config = kong_config,
  --  }
function _M.new(db, schema, strategy, errors)
  local fk_methods = generate_foreign_key_methods(schema)
  -- ç»§æ‰¿ DAO åŸºç¡€æ–¹æ³•
  local super      = setmetatable(fk_methods, DAO)

  local self = {
    db         = db,
    schema     = schema,
    strategy   = strategy,
    errors     = errors,
    pagination = utils.shallow_copy(defaults.pagination),
    super      = super,
  }

  if schema.dao then
    -- æ’ä»¶è‡ªå®šä¹‰çš„ dao
    local custom_dao = require(schema.dao)
    for name, method in pairs(custom_dao) do
      self[name] = method
    end
  end

  return setmetatable(self, { __index = super })
end
</code></pre>
<p>åœ¨ <code>db\init.lua</code> ä¸­åŠ è½½æ‰€æœ‰ DAO å¯¹è±¡ã€‚</p>
<pre><code class=language-lua>  do
    -- load DAOs

    for _, schema in pairs(schemas) do
      local strategy = strategies[schema.name]
      if not strategy then
        return nil, fmt(&quot;no strategy found for schema '%s'&quot;, schema.name)
      end

      -- å‚¨å­˜ daos
      daos[schema.name] = DAO.new(self, schema, strategy, errors)
    end
  end
</code></pre>
<p>å’Œä¸Šé¢ç»“æ„ä¸€æ ·ï¼Œ<code>DB.new()</code> ä¸­æœ€åä¸º table è®¾ç½®å…ƒç»„ __index æ–¹æ³•ã€‚</p>
<pre><code class=language-lua>  -- è®¾ç½®å…ƒç»„ __index æ–¹æ³•
  -- è®¿é—®ä¸å­˜åœ¨çš„å¯¹è±¡åˆ™å…ˆ
  -- DB.xxx å†è®¿é—® DB.daos.xxx
  return setmetatable(self, DB)


local DB = {}
DB.__index = function(self, k)
  -- rawget ä¸ºä¸è°ƒç”¨å…ƒç»„ __index æ–¹æ³•ï¼Œç›´æ¥è·å–åŸæ•°æ®
  return DB[k] or rawget(self, &quot;daos&quot;)[k]
end
</code></pre>
<p>Kong ä¸­å…¶ä»–åœ°æ–¹è°ƒç”¨æ•°æ®åº“æ–¹æ³•ï¼Œæ“ä½œç¬¦ä¸º <code>kong.db.services:each_fields()</code>ï¼Œå³å®é™…è°ƒç”¨ <code>daos.services</code>ã€<code>entity:each_fields()</code>ï¼ˆå®é™…æ˜¯ <code>Schema:each_fields()</code>ï¼‰ã€‚</p>
<p>DAO ä¸‹é¢è¿˜æœ‰å°è£…çš„æ•°æ®åº“æ“ä½œå±‚ï¼Œä¾‹å¦‚ postgresql ç”Ÿæˆ SQL è¯­å¥çš„æ–¹æ³•ï¼Œè¿™é‡Œå°±ä¸èµ˜è¿°äº†ã€‚</p>
<p>DAO è¿™ä¸€å±‚ä¸€å±‚çš„å°è£…çœ‹å¾—æˆ‘æ˜¯çœŸçš„è„‘å£³ç—›ï¼ŒIDE è¿˜æ²¡æœ‰å¯¹ lua çš„æ™ºèƒ½æç¤ºï¼ŒæŒ‰ä½ Ctrl æ¯›éƒ½æ˜¾ç¤ºä¸å‡ºæ¥ã€‚</p>
<h3 id=32-ç¼“å­˜æ„å»º>3.2. ç¼“å­˜æ„å»º</h3>
<p><code>init_by_lua</code> é˜¶æ®µåˆå§‹åŒ– Master è¿›ç¨‹ï¼Œè¿›è¡Œè§£æé…ç½®æ–‡ä»¶ã€è¿æ¥æ•°æ®åº“ã€æ¸…ç©ºå…±äº«å†…å­˜ã€æ„å»ºè·¯ç”±ç¼“å­˜ç­‰æ“ä½œã€‚</p>
<p><code>reset_kong_shm</code> ä»£ç å—é‡Œæ¸…ç†å…±äº«å†…å­˜ã€‚</p>
<pre><code class=language-lua>    local shms = {
      &quot;kong&quot;,
      &quot;kong_locks&quot;,
      &quot;kong_healthchecks&quot;,
      &quot;kong_process_events&quot;,
      &quot;kong_cluster_events&quot;,
      &quot;kong_rate_limiting_counters&quot;,
      &quot;kong_core_db_cache&quot; .. suffix,
      &quot;kong_core_db_cache_miss&quot; .. suffix,
      &quot;kong_db_cache&quot; .. suffix,
      &quot;kong_db_cache_miss&quot; .. suffix,
      &quot;kong_clustering&quot;,
    }

    for _, shm in ipairs(shms) do
      local dict = ngx.shared[shm]
      -- æ¸…ç©ºå…±äº«å†…å­˜
      if dict then
        dict:flush_all()
        dict:flush_expired(0)
      end
    end
</code></pre>
<h4 id=321-è·¯ç”±ç¼“å­˜>3.2.1. è·¯ç”±ç¼“å­˜</h4>
<pre><code class=language-lua>  else
    -- DB æ¨¡å¼
    local default_ws = db.workspaces:select_by_name(&quot;default&quot;)
    kong.default_workspace = default_ws and default_ws.id

    local ok, err = runloop.build_plugins_iterator(&quot;init&quot;)
    if not ok then
      error(&quot;error building initial plugins: &quot; .. tostring(err))
    end

    -- åˆå§‹åŒ–è·¯ç”±
    -- æ„å»ºè·¯ç”±ç¼“å­˜
    assert(runloop.build_router(&quot;init&quot;))
  end

  db:close()
end
</code></pre>
<p>DB æ¨¡å¼ä¸‹æœ€åä¸€æ­¥ä¼šè°ƒç”¨ <code>runloop.build_router("init")</code> æ„å»ºè·¯ç”±ç¼“å­˜ã€‚</p>
<p>æ„å»ºè·¯ç”±ç¼“å­˜è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­ Kong æ˜¯å¦å·²ç»åˆå§‹åŒ–è¿‡ Cache ç»„ä»¶ï¼Œ<code>init</code> é˜¶æ®µæ²¡æœ‰å®Œæˆåˆå§‹åŒ– Cacheï¼Œåˆ™åˆ›å»ºä¸€ä¸ª Lua table ç¼“å­˜è·¯ç”±ä¿¡æ¯ã€‚<code>build_services_init_cache()</code> æ–¹æ³•ä¼šåˆ†é¡µåŠ è½½æ‰€æœ‰ Service åˆ° table ä¸­ï¼Œå¯¹å–å‡ºæ¥çš„ Servicesï¼Œåˆ¤æ–­å½“å‰ä½¿ç”¨çš„ Nginx æ¨¡å¼ï¼ˆhttp/streamï¼‰æ˜¯å¦å¯¹åº”è·¯ç”±æŒ‡å®šçš„åè®®ï¼Œå¯¹åº”åˆ™å–å‡º Service å¯¹è±¡ï¼Œä¸ Route è¿›è¡Œå…³è”ã€‚æœ€åä¼ é€’ç»™ <code>Router.new()</code> æ–¹æ³•é€šè¿‡ç®—æ³•å»ºç«‹æ ‘å½¢ç»“æ„å»ºç«‹è·¯ç”±ç´¢å¼•ã€‚</p>
<p>Kong åŸºäº Nginx Subsystem æ”¯æŒçš„åè®®å¯¹åº”å…³ç³»ï¼š</p>
<ul>
<li>http/https -> http</li>
<li>grpc/grpcs -> http</li>
<li>tcp/tls -> stream</li>
</ul>
<pre><code class=language-lua>  build_router = function(version)
    local db = kong.db
    -- table å‚¨å­˜æ‰€æœ‰çš„ route-service æ•°æ®
    local routes, i = {}, 0

    local err
    -- The router is initially created on init phase, where kong.core_cache is
    -- still not ready. For those cases, use a plain Lua table as a cache
    -- instead
    -- init é˜¶æ®µ core_cache è¿˜æ²¡æœ‰åˆå§‹åŒ–å®Œæˆ
    -- è¿™é‡Œä½¿ç”¨ table å‚¨å­˜
    local services_init_cache = {}
    if not kong.core_cache and db.strategy ~= &quot;off&quot; then
      -- è·å–æ‰€æœ‰çš„ servicesï¼Œä½¿ç”¨é»˜è®¤çš„åˆ†é¡µå‚æ•°
      services_init_cache, err = build_services_init_cache(db)
      if err then
        services_init_cache = {}
        log(WARN, &quot;could not build services init cache: &quot;, err)
      end
    end

    local counter = 0
    local page_size = db.routes.pagination.page_size
    for route, err in db.routes:each(nil, GLOBAL_QUERY_OPTS) do
      if err then
        return nil, &quot;could not load routes: &quot; .. err
      end

      -- æ£€æŸ¥ router æ•°æ®æ˜¯å¦å·²ç»å˜åŒ–
      -- é€šè¿‡æ£€æŸ¥ router hash æ˜¯å¦ä¸€è‡´åˆ¤æ–­
      -- å¦‚æœå·²ç»å˜åŒ–åˆ™é€€å‡ºå‡½æ•°
      if db.strategy ~= &quot;off&quot; then
        if kong.core_cache and counter &gt; 0 and counter % page_size == 0 then
          local new_version, err = get_router_version()
          if err then
            return nil, &quot;failed to retrieve router version: &quot; .. err
          end

          if new_version ~= version then
            return nil, &quot;router was changed while rebuilding it&quot;
          end
        end
      end

      -- subsystem æ˜¯å¦æ”¯æŒå½“å‰è·¯ç”±çš„åè®®
      if should_process_route(route) then
        -- è·å– route çš„ service
        local service, err = get_service_for_route(db, route, services_init_cache)
        if err then
          return nil, err
        end

        local r = {
          route   = route,
          service = service,
        }

        i = i + 1
        -- å‚¨å­˜æ‰€æœ‰çš„ route-service
        routes[i] = r
      end

      counter = counter + 1
    end

    local new_router, err = Router.new(routes)
    if not new_router then
      return nil, &quot;could not create router: &quot; .. err
    end

    -- router å®ä¾‹
    router = new_router

    if version then
      router_version = version
    end

    -- LEGACY - singletons module is deprecated
    singletons.router = router
    -- /LEGACY

    return true
  end
</code></pre>
<p>æ„å»ºè·¯ç”±ç¼“å­˜è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­ Kong æ˜¯å¦å·²ç»åˆå§‹åŒ–è¿‡ Cache ç»„ä»¶ï¼Œ<code>init</code> é˜¶æ®µæ²¡æœ‰å®Œæˆåˆå§‹åŒ– Cacheï¼Œåˆ™åˆ›å»ºä¸€ä¸ª Lua table ç¼“å­˜ servicesã€‚</p>
<pre><code class=language-lua>  -- ä»¥ [service.id] = service
  -- ç»“æ„å‚¨å­˜åˆ° table ä¸­
  local function build_services_init_cache(db)
    local services_init_cache = {}

    for service, err in db.services:each(nil, GLOBAL_QUERY_OPTS) do
      if err then
        return nil, err
      end

      services_init_cache[service.id] = service
    end

    return services_init_cache
  end
</code></pre>
<p><code>build_services_init_cache(db)</code> æ–¹æ³•ï¼Œè°ƒç”¨ <code>DAO:each()</code> å‡½æ•°ï¼Œä½¿ç”¨é»˜è®¤åˆ†é¡µå‚æ•° <code>page_size=1000</code>ï¼Œè¿›è¡Œåˆ†é¡µè·å–ï¼Œå†è¿”å›å¯è¿­ä»£çš„å•æ¡è®°å½•ã€‚è¿™é‡Œå› ä¸º <code>init_by_lua</code> é˜¶æ®µæ²¡æœ‰åˆå§‹åŒ–ç¼“å­˜ï¼ˆ<code>kong.core_cache</code> ï¼‰ï¼Œæ‰€ä»¥ä½¿ç”¨ Lua table å‚¨å­˜ç¼“å­˜æ•°æ®ã€‚</p>
<pre><code class=language-lua>function DAO:each(size, options)
  if size ~= nil then
    validate_size_type(size)
  end

  -- è·å–åˆ†é¡µæ¡ä»¶ï¼Œæœ‰é»˜è®¤å€¼
  options = get_pagination_options(self, options)

  if size ~= nil then
    local ok, err = validate_size_value(size, options.pagination.max_page_size)
    if not ok then
      local err_t = self.errors:invalid_size(err)
      return nil, tostring(err_t), err_t
    end

  else
    size = options.pagination.page_size
  end

  local ok, errors = validate_options_value(self, options)
  if not ok then
    local err_t = self.errors:invalid_options(errors)
    return nil, tostring(err_t), err_t
  end

  local pager = function(size, offset, options)
    return self.strategy:page(size, offset, options)
  end

  return iteration.by_row(self, pager, size, options)
end
</code></pre>
<p>é»˜è®¤åˆ†é¡µå‚æ•°åœ¨ <code>db/strategies/connector.lua</code> æ–‡ä»¶ä¸­ï¼š</p>
<pre><code class=language-lua>local Connector = {
  defaults = {
    -- é»˜è®¤åˆ†é¡µæ¡ä»¶
    pagination = {
      page_size     = 1000,
      max_page_size = 50000,
    },
  },
}
</code></pre>
<p>æ¥ä¸‹æ¥ä¼šéå†æ‰€æœ‰çš„ Routesï¼Œé€ä¸ªè°ƒç”¨ <code>should_process_route()</code> å’Œ <code>get_service_for_route()</code> æ–¹æ³•ï¼Œå‰è€…ä¼šåˆ¤æ–­ Nginx Subsystem æ˜¯å¦å’Œ Route åè®®ä¸€è‡´ï¼Œåè€…å…ˆåœ¨ç¼“å­˜ä¸­æŸ¥æ‰¾ Serviceï¼Œå¦‚æœç¼“å­˜ä¸­ä¸å­˜åœ¨åˆ™ä»æ•°æ®åº“ä¸­è·å–ã€‚</p>
<pre><code class=language-lua>  local function get_service_for_route(db, route, services_init_cache)
    -- route å…³è”çš„ service å¤–é”®
    local service_pk = route.service
    if not service_pk then
      return nil
    end

    -- æŸ¥æ‰¾ç¼“å­˜ table é‡Œçš„ service
    local id = service_pk.id
    local service = services_init_cache[id]
    if service then
      return service
    end

    local err

    -- kong.core_cache is available, not in init phase
    if kong.core_cache then
      -- é€šè¿‡ mlcache æŸ¥è¯¢ service
      local cache_key = db.services:cache_key(service_pk.id, nil, nil, nil, nil,
                                              route.ws_id)
      -- æŸ¥è¯¢ cache è·å–ï¼Œæ²¡æœ‰è·å–åˆ°åˆ™è°ƒç”¨ load_service_from_db è·å–
      service, err = kong.core_cache:get(cache_key, TTL_ZERO,
                                    load_service_from_db, service_pk)

    else -- init phase, kong.core_cache not available

      -- A new service/route has been inserted while the initial route
      -- was being created, on init (perhaps by a different Kong node).
      -- Load the service individually and update services_init_cache with it
      -- ç›´æ¥æŸ¥è¯¢æ•°æ®åº“è·å– service
      service, err = load_service_from_db(service_pk)
      services_init_cache[id] = service
    end

    if err then
      return nil, &quot;error raised while finding service for route (&quot; .. route.id .. &quot;): &quot; ..
                  err

    elseif not service then
      return nil, &quot;could not find service for route (&quot; .. route.id .. &quot;)&quot;
    end


    -- TODO: this should not be needed as the schema should check it already
    if SUBSYSTEMS[service.protocol] ~= subsystem then
      log(WARN, &quot;service with protocol '&quot;, service.protocol,
                &quot;' cannot be used with '&quot;, subsystem, &quot;' subsystem&quot;)

      return nil
    end

    return service
  end

</code></pre>
<p><code>load_service_from_db()</code> æ–¹æ³•ä¸­åªæ˜¯ç®€å•è°ƒç”¨ <code>DAO:select()</code> æ–¹æ³•ï¼Œå–å‡º Service åŒæ—¶ç¼“å­˜åˆ° <code>services_init_cache</code> table ä¸­ï¼Œä¸æ›´æ–° <code>Kong.core_cache</code> ç»„ä»¶ã€‚</p>
<p>å¯¹æ•°æ®åº“å®ä½“å¯¹è±¡çš„å¤„ç†ä¸­ï¼Œåªæœ‰<code>create</code> ã€<code>update</code>ã€<code>delete</code> ä¼šé€šè¿‡äº‹ä»¶å¹¿æ’­åˆ°å…¶ä»– Worker åŒæ­¥ï¼Œåé¢äº‹ä»¶çš„ä¸€èŠ‚æˆ‘ä»¬ä¼šè¯¦ç»†é˜è¿°ã€‚</p>
<p>æ¥ä¸‹æ¥å°† <code>{router, service}</code> æ•°ç»„ä¼ å…¥ <code>router.iua</code> ä¸­ <code>Router.new()</code> å‡½æ•°å¤„ç†ã€‚</p>
<pre><code class=language-lua>local new_router, err = Router.new(routes)
if not new_router then
    return nil, &quot;could not create router: &quot; .. err
end

-- ç»‘å®š router å®ä¾‹
router = new_router
</code></pre>
<p>å…·ä½“æ„å»ºè·¯ç”±ç´¢å¼•çš„è¿‡ç¨‹åœ¨ <code>router.lua</code> ä¸­çš„ <code>_M.new(routes)</code> å‡½æ•°ï¼Œä½¿ç”¨ <strong><a href=https://github.com/openresty/lua-resty-lrucache>lua-resty-lrucache</a></strong> åŒ…ç¼“å­˜ï¼Œå¯¹è·¯ç”±å’Œ Service ç»„åˆé€šè¿‡ç®—æ³•è¿›è¡Œæ’åºï¼Œæ„å»ºç´¢å¼•ï¼Œå°†è¯¸å¦‚ <code>{cache_key: {route, service}}</code> ç»“æ„å­˜å…¥ç¼“å­˜ä¸­ï¼Œè¿”å› Router å®ä¾‹ã€‚</p>
<p>è·¯ç”±ç´¢å¼• Key çš„æ„å»ºæ–¹æ³•ï¼š</p>
<pre><code class=language-lua>    local cache_key = req_method .. &quot;|&quot; .. req_uri .. &quot;|&quot; .. req_host ..
                      &quot;|&quot; .. ctx.src_ip .. &quot;|&quot; .. ctx.src_port ..
                      &quot;|&quot; .. ctx.dst_ip .. &quot;|&quot; .. ctx.dst_port ..
                      &quot;|&quot; .. ctx.sni
</code></pre>
<p>Router å®ä¾‹ç”± Master è¿›ç¨‹æ„å»ºï¼Œå¹¶ fork åˆ°å„ä¸ª Worker è¿›ç¨‹ä½¿ç”¨ã€‚</p>
<p>Worker æ‰§è¡Œå®Œå…±äº«å†…å­˜çš„æ„å»ºåï¼Œæ³¨å†Œå®šæ—¶ä»»åŠ¡ï¼Œå®šæ—¶é‡å»ºç¼“å­˜ã€‚</p>
<pre><code class=language-lua>      -- å®šæ—¶é‡å»ºè·¯ç”±ç¼“å­˜
      if kong.db.strategy ~= &quot;off&quot; then
        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          -- Don't wait for the semaphore (timeout = 0) when updating via the
          -- timer.
          -- If the semaphore is locked, that means that the rebuild is
          -- already ongoing.
          local ok, err = rebuild_router(ROUTER_ASYNC_OPTS)
          if not ok then
            log(ERR, &quot;could not rebuild router via timer: &quot;, err)
          end
        end)

        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          local ok, err = rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)
          if not ok then
            log(ERR, &quot;could not rebuild plugins iterator via timer: &quot;, err)
          end
        end)
      end
</code></pre>
<h4 id=322-entity-ç¼“å­˜>3.2.2. Entity ç¼“å­˜</h4>
<p>è¿™é‡Œé¦–å…ˆä»‹ç»ä¸€ä¸‹ <strong><a href=https://github.com/thibaultcha/lua-resty-mlcache>lua-resty-mlcache</a></strong> è¿™ä¸ªç¼“å­˜åº“ï¼Œè¯¥åº“åŸºäº <a href=https://github.com/openresty/lua-nginx-module#lua_shared_dict>lua_shared_dict</a> å’Œ <a href=https://github.com/openresty/lua-resty-lrucache>lua-resty-lrucache</a> åšäº†ä¸¤å±‚ç¼“å­˜ï¼ŒWorker ä¼šæœ‰è‡ªå·±çš„è¿›ç¨‹çº§åˆ«çš„ LRU ç¼“å­˜ï¼Œé¦–å…ˆä¼šåœ¨è¿™ä¸€å±‚è¿›è¡ŒæŸ¥è¯¢ï¼Œå…¶æ¬¡ä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œç¼“å­˜ï¼Œæœ€åæä¾› callback ä»æ•°æ®åº“æŸ¥è¯¢ï¼Œä½¿ç”¨ <a href=https://github.com/openresty/lua-resty-lock>lua-resty-lock</a> åº“åˆ›å»ºé”åªå…è®¸å•ä¸ªè¿›ç¨‹æ‰§è¡Œ callbackã€‚</p>
<p>mlcache æ¶æ„å›¾ï¼š</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nginx                                           â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚       â”‚worker     â”‚ â”‚worker     â”‚ â”‚worker     â”‚ â”‚
â”‚ L1    â”‚           â”‚ â”‚           â”‚ â”‚           â”‚ â”‚
â”‚       â”‚ Lua cache â”‚ â”‚ Lua cache â”‚ â”‚ Lua cache â”‚ â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚             â”‚             â”‚             â”‚       â”‚
â”‚             â–¼             â–¼             â–¼       â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚       â”‚                                       â”‚ â”‚
â”‚ L2    â”‚           lua_shared_dict             â”‚ â”‚
â”‚       â”‚                                       â”‚ â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚ mutex               â”‚
â”‚                           â–¼                     â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚                  â”‚     callback     â”‚           â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
  L3                        â”‚   I/O fetch
                            â–¼

                   Database, API, DNS, Disk, any I/O...
</code></pre>
<p><code>Kong.init_worker()</code> ä¸­è¿›è¡Œåˆå§‹åŒ–ç¼“å­˜ï¼š</p>
<pre><code class=language-lua>  -- åˆå§‹åŒ–åŸºäºå…±äº«å†…å­˜çš„ cache
  local cache, err = kong_global.init_cache(kong.configuration, cluster_events, worker_events)
  if not cache then
    stash_init_worker_error(&quot;failed to instantiate 'kong.cache' module: &quot; ..
                            err)
    return
  end
  kong.cache = cache

  local core_cache, err = kong_global.init_core_cache(kong.configuration, cluster_events, worker_events)
  if not core_cache then
    stash_init_worker_error(&quot;failed to instantiate 'kong.core_cache' module: &quot; ..
                            err)
    return
  end
  kong.core_cache = core_cache

  ok, err = runloop.set_init_versions_in_cache()
  if not ok then
    stash_init_worker_error(err) -- 'err' fully formatted
    return
  end
</code></pre>
<p><code>global.init_cache()</code> ç»“æ„å¦‚ä¸‹ï¼š</p>
<pre><code class=language-lua>function _GLOBAL.init_cache(kong_config, cluster_events, worker_events)
  local db_cache_ttl = kong_config.db_cache_ttl
  local db_cache_neg_ttl = kong_config.db_cache_neg_ttl
  local cache_pages = 1
  if kong_config.database == &quot;off&quot; then
    db_cache_ttl = 0
    db_cache_neg_ttl = 0
    cache_pages = 2
  end

  return kong_cache.new {
    shm_name          = &quot;kong_db_cache&quot;,
    cluster_events    = cluster_events,
    worker_events     = worker_events,
    ttl               = db_cache_ttl,
    neg_ttl           = db_cache_neg_ttl or db_cache_ttl,
    resurrect_ttl     = kong_config.resurrect_ttl,
    cache_pages       = cache_pages,
    resty_lock_opts   = {
      exptime = 10,
      timeout = 5,
    },
  }
end
</code></pre>
<p>æœ€ç»ˆä¼šè°ƒç”¨ <code>cache.lua</code> ä¸­ <code>_M.new()</code> è¿›è¡Œå¿…è¦å‚æ•°çš„éªŒè¯ï¼Œæ£€æµ‹å…±äº«å†…å­˜å—æ˜¯å¦å¯ä»¥è®¿é—®ï¼Œå…³è”é›†ç¾¤äº‹ä»¶å’Œ Worker äº‹ä»¶ï¼Œå®šä¹‰åºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„æ–¹æ³•ï¼Œå¯¹ mlcache è¿›è¡Œä¸€å±‚å°è£…ã€‚</p>
<pre><code class=language-lua>function _M.new(opts)
  -- opts validation

  opts = opts or {}

  local mlcaches = {}
  local shm_names = {}

  for i = 1, opts.cache_pages or 1 do
    local channel_name  = (i == 1) and &quot;mlcache&quot;                 or &quot;mlcache_2&quot;
    local shm_name      = (i == 1) and opts.shm_name             or opts.shm_name .. &quot;_2&quot;
    local shm_miss_name = (i == 1) and opts.shm_name .. &quot;_miss&quot;  or opts.shm_name .. &quot;_miss_2&quot;

    if ngx.shared[shm_name] then
      local mlcache, err = resty_mlcache.new(shm_name, shm_name, {
        shm_miss         = shm_miss_name,
        shm_locks        = &quot;kong_locks&quot;,
        shm_set_retries  = 3,
        lru_size         = LRU_SIZE,
        ttl              = max(opts.ttl     or 3600, 0),
        neg_ttl          = max(opts.neg_ttl or 300,  0),
        resurrect_ttl    = opts.resurrect_ttl or 30,
        resty_lock_opts  = opts.resty_lock_opts,
        ipc = { -- è¿›ç¨‹é—´é€šä¿¡çš„å‡½æ•°ç»‘å®š
          register_listeners = function(events)
            for _, event_t in pairs(events) do
              opts.worker_events.register(function(data)
                event_t.handler(data)
              end, channel_name, event_t.channel)
            end
          end,
          broadcast = function(channel, data)
            local ok, err = opts.worker_events.post(channel_name, channel, data)
            if not ok then
              log(ERR, &quot;failed to post event '&quot;, channel_name, &quot;', '&quot;,
                       channel, &quot;': &quot;, err)
            end
          end
        }
      })
      if not mlcache then
        return nil, &quot;failed to instantiate mlcache: &quot; .. err
      end
      mlcaches[i] = mlcache
      shm_names[i] = shm_name
    end
  end

  local curr_mlcache = 1

  if opts.cache_pages == 2 then
    curr_mlcache = ngx.shared.kong:get(&quot;kong:cache:&quot; .. opts.shm_name .. &quot;:curr_mlcache&quot;) or 1
  end

  local self          = {
    cluster_events    = opts.cluster_events,
    mlcache           = mlcaches[curr_mlcache],
    mlcaches          = mlcaches,
    shm_names         = shm_names,
    curr_mlcache      = curr_mlcache,
  }

  local ok, err = self.cluster_events:subscribe(&quot;invalidations&quot;, function(key)
    log(DEBUG, &quot;received invalidate event from cluster for key: '&quot;, key, &quot;'&quot;)
    self:invalidate_local(key)
  end)
  if not ok then
    return nil, &quot;failed to subscribe to invalidations cluster events &quot; ..
                &quot;channel: &quot; .. err
  end

  _init[opts.shm_name] = true

  return setmetatable(self, mt)
end
</code></pre>
<p>åˆå§‹åŒ–å®Œç¼“å­˜æ¨¡å—åï¼ŒWorker ä¼šæ ¹æ®é…ç½®æ–‡ä»¶ä¸­çš„ <code>db_cache_warmup_entities</code> åŠ è½½æŒ‡å®šçš„æ•°æ®åº“èµ„æºåˆ°å†…å­˜è¿›è¡Œç¼“å­˜ï¼Œé»˜è®¤é…ç½®ä¼šç¼“å­˜ <code>services, plugins</code>ã€‚</p>
<p><code>LRU_SIZE</code> å€¼ä¸º 500,000ï¼Œå•ä½æ˜¯ itemï¼Œè®¾ç½®æœ€å¤§èƒ½å‚¨å­˜çš„ item æ•°é‡ï¼Œè¿™ä¸ªå€¼è¡¨ç¤ºå•ä¸ª Worker LRU Cache æœ€å¤§å ç”¨ 500M å†…å­˜ã€‚</p>
<p>Worker ä¼šæ ¹æ®é…ç½®é¡¹åŠ è½½æ•°æ®åº“å®ä½“åˆ°å…±äº«å†…å­˜ç¼“å­˜ã€‚</p>
<pre><code class=language-lua>local function execute_cache_warmup(kong_config)
  if kong_config.database == &quot;off&quot; then
    return true
  end

  -- åªåœ¨ä¸€ä¸ª worker ä¸Šæ‰§è¡Œæ“ä½œ
  -- åŠ è½½æ•°æ®åº“å®ä½“åˆ°å…±äº«å†…å­˜ç¼“å­˜
  if ngx.worker.id() == 0 then
    local ok, err = cache_warmup.execute(kong_config.db_cache_warmup_entities)
    if not ok then
      return nil, err
    end
  end

  return true
end
</code></pre>
<p>è¿™é‡Œåªåœ¨ä¸€ä¸ª Worker è¿›ç¨‹ä¸ŠåŠ è½½æ•°æ®åº“æ•°æ®ï¼ŒéšååŒæ­¥åˆ°å…¶ä»–çš„ Worker ä¸Šã€‚</p>
<p><code>cache_warmup.execute()</code> é‡ŒåšåŸºæœ¬ä¿¡æ¯çš„æ£€æµ‹ï¼Œéšåè°ƒç”¨ <code>cache_warmup_single_entity(dao)</code> æ–¹æ³•ã€‚</p>
<pre><code class=language-lua>-- åŠ è½½æ•°æ®åº“å®ä½“åˆ°ç¼“å­˜ï¼Œä»¥å®ç°æ›´å¿«çš„è®¿é—®é€Ÿåº¦
-- åœ¨ Worker åˆå§‹åŒ–é˜¶æ®µè¿è¡Œ
-- é»˜è®¤åŠ è½½ service, plugins
-- å¤§å°å—é…ç½® mem_cache_size å½±å“
-- Loads entities from the database into the cache, for rapid subsequent
-- access. This function is intented to be used during worker initialization.
function cache_warmup.execute(entities)
  if not kong.cache or not kong.core_cache then
    return true
  end

  for _, entity_name in ipairs(entities) do
    if entity_name == &quot;routes&quot; then
      -- do not spend shm memory by caching individual Routes entries
      -- because the routes are kept in-memory by building the router object
      kong.log.notice(&quot;the 'routes' entry is ignored in the list of &quot;,
                      &quot;'db_cache_warmup_entities' because Kong &quot;,
                      &quot;caches routes in memory separately&quot;)
      goto continue
    end

    local dao = kong.db[entity_name]
    if not (type(dao) == &quot;table&quot; and dao.schema) then
      kong.log.warn(entity_name, &quot; is not a valid entity name, please check &quot;,
                    &quot;the value of 'db_cache_warmup_entities'&quot;)
      goto continue
    end

    local ok, err = cache_warmup_single_entity(dao)
    if not ok then
      if err == &quot;no memory&quot; then
        kong.log.warn(&quot;cache warmup has been stopped because cache &quot;,
                      &quot;memory is exhausted, please consider increasing &quot;,
                      &quot;the value of 'mem_cache_size' (currently at &quot;,
                      kong.configuration.mem_cache_size, &quot;)&quot;)

        return true
      end
      return nil, err
    end

    ::continue::
  end

  return true
end
</code></pre>
<p>ä¸ç¼“å­˜ Routesï¼Œå› ä¸º Route å·²ç»åœ¨ä¸Šä¸€èŠ‚ä¸­æ„å»ºä¸ºè·¯ç”±ç´¢å¼•æ ‘ï¼Œé€šè¿‡ fork åˆ°æ‰€æœ‰çš„ Worker å†…å­˜é‡Œäº†ã€‚</p>
<pre><code class=language-lua>local function cache_warmup_single_entity(dao)
  local entity_name = dao.schema.name

  -- é€‰å®šå‚¨å­˜åœ°æ–¹ cache/core_cache
  local cache_store = constants.ENTITY_CACHE_STORE[entity_name]
  -- cache å…¨å±€å¯¹è±¡
  local cache = kong[cache_store]

  ngx.log(ngx.NOTICE, &quot;Preloading '&quot;, entity_name, &quot;' into the &quot;, cache_store, &quot;...&quot;)

  local start = ngx.now()

  local hosts_array, hosts_set, host_count
  if entity_name == &quot;services&quot; then
    hosts_array = {}
    hosts_set = {}
    host_count = 0
  end

  for entity, err in dao:each(nil, GLOBAL_QUERY_OPTS) do
    if err then
      return nil, err
    end

    if entity_name == &quot;services&quot; then
      if utils.hostname_type(entity.host) == &quot;name&quot;
         and hosts_set[entity.host] == nil then
        host_count = host_count + 1
        hosts_array[host_count] = entity.host
        hosts_set[entity.host] = true
      end
    end

    -- è·å– cache_key
    local cache_key = dao:cache_key(entity)

    -- è°ƒç”¨ mlcache çš„ safe_set æ–¹æ³•ï¼Œ
    -- å†…å­˜ä¸è¶³ä¼šæŠ¥é”™
    local ok, err = cache:safe_set(cache_key, entity)
    if not ok then
      return nil, err
    end
  end

  if entity_name == &quot;services&quot; and host_count &gt; 0 then
    ngx.timer.at(0, warmup_dns, hosts_array, host_count)
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, &quot;finished preloading '&quot;, entity_name,
                      &quot;' into the &quot;, cache_store, &quot; (in &quot;, tostring(elapsed), &quot;ms)&quot;)
  return true
end
</code></pre>
<p><code>cache_warmup_single_entity()</code> ä¼šåŠ è½½è¯¥ dao æ‰€æœ‰çš„æ•°æ®åˆ°å†…å­˜ä¸­ï¼Œ<code>set</code> æ–¹æ³•ä¼šåˆ†å‘äº‹ä»¶åŒæ­¥æ•°æ®åˆ°å…¶ä»–çš„ Worker ä¸Šï¼Œæœ€ç»ˆæ¯ä¸ª Worker éƒ½ä¼šç¼“å­˜ä¸€ä»½ã€‚</p>
<h3 id=33-äº‹ä»¶è®¢é˜…>3.3. äº‹ä»¶è®¢é˜…</h3>
<p><code>Kong.init_worker()</code> ä¸­åˆå§‹åŒ– Worker äº‹ä»¶å’Œé›†ç¾¤äº‹ä»¶ã€‚</p>
<pre><code class=language-lua>  local worker_events, err = kong_global.init_worker_events()
  if not worker_events then
    stash_init_worker_error(&quot;failed to instantiate 'kong.worker_events' &quot; ..
                            &quot;module: &quot; .. err)
    return
  end
  kong.worker_events = worker_events

  local cluster_events, err = kong_global.init_cluster_events(kong.configuration, kong.db)
  if not cluster_events then
    stash_init_worker_error(&quot;failed to instantiate 'kong.cluster_events' &quot; ..
                            &quot;module: &quot; .. err)
    return
  end
  kong.cluster_events = cluster_events
</code></pre>
<p>Worker äº‹ä»¶å†…éƒ¨æ˜¯ä½¿ç”¨ <strong><a href=https://github.com/Kong/lua-resty-worker-events>lua-resty-worker-events</a></strong> åº“å®ç°çš„è¿›ç¨‹é—´äº‹ä»¶å¤„ç†ï¼ŒåŸç†æ˜¯é€šè¿‡å…±äº«å†…å­˜å‚¨å­˜äº‹ä»¶ï¼Œæ¯ç§’æ‹‰å–å…±äº«å†…å­˜ä¸­çš„äº‹ä»¶ï¼Œè¿›è¡Œå¤„ç†ã€‚</p>
<pre><code class=language-lua>function _GLOBAL.init_worker_events()
  -- Note: worker_events will not work correctly if required at the top of the file.
  --       It must be required right here, inside the init function
  local worker_events = require &quot;resty.worker.events&quot;

  local ok, err = worker_events.configure {
    shm = &quot;kong_process_events&quot;, -- defined by &quot;lua_shared_dict&quot;
    timeout = 5,            -- life time of event data in shm
    interval = 1,           -- poll interval (seconds)

    wait_interval = 0.010,  -- wait before retry fetching event data
    wait_max = 0.5,         -- max wait time before discarding event
  }
  if not ok then
    return nil, err
  end

  return worker_events
end
</code></pre>
<p>é›†ç¾¤äº‹ä»¶ï¼ˆå¤šä¸ª Kong ä¹‹é—´çš„é€šä¿¡ï¼‰æ˜¯é€šè¿‡å°†äº‹ä»¶å‚¨å­˜åœ¨æ•°æ®åº“ä¸­ï¼Œå®šæ—¶è½®è¯¢æ•°æ®åº“æŸ¥è¯¢äº‹ä»¶ï¼Œè¿›è¡Œå¤„ç†ã€‚</p>
<pre><code class=language-lua>function _GLOBAL.init_cluster_events(kong_config, db)
  return kong_cluster_events.new({
    db            = db,
    poll_interval = kong_config.db_update_frequency,
    poll_offset   = kong_config.db_update_propagation,
    poll_delay    = kong_config.db_update_propagation,
  })
end
</code></pre>
<p>ä»è¿™é‡Œå¯ä»¥çœ‹åˆ°é›†ç¾¤äº‹ä»¶æ˜¯é€šè¿‡æ•°æ®åº“è¡¨å®ç°çš„ï¼š</p>
<pre><code class=language-lua>function _M:broadcast(channel, data, delay)
  if type(channel) ~= &quot;string&quot; then
    return nil, &quot;channel must be a string&quot;
  end

  if type(data) ~= &quot;string&quot; then
    return nil, &quot;data must be a string&quot;
  end

  if delay and type(delay) ~= &quot;number&quot; then
    return nil, &quot;delay must be a number&quot;

  elseif self.poll_delay &gt; 0 then
    delay = self.poll_delay
  end

  -- insert event row

  --log(DEBUG, &quot;broadcasting on channel: '&quot;, channel, &quot;' data: &quot;, data,
  --           &quot; with delay: &quot;, delay and delay or &quot;none&quot;)

  local ok, err = self.strategy:insert(self.node_id, channel, nil, data, delay)
  if not ok then
    return nil, err
  end

  return true
end


function _M:subscribe(channel, cb, start_polling)
  if type(channel) ~= &quot;string&quot; then
    return error(&quot;channel must be a string&quot;)
  end

  if type(cb) ~= &quot;function&quot; then
    return error(&quot;callback must be a function&quot;)
  end

  if not self.callbacks[channel] then
    self.callbacks[channel] = { cb }

    insert(self.channels, channel)

  else
    insert(self.callbacks[channel], cb)
  end

  if start_polling == nil then
    start_polling = true
  end

  if not self.polling and start_polling and self.use_polling then
    -- start recurring polling timer

    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      return nil, &quot;failed to start polling timer: &quot; .. err
    end

    self.polling = true
  end

  return true
end
</code></pre>
<p>åœ¨ <code>cache.lua</code> ä¸­é›†ç¾¤äº‹ä»¶è®¢é˜… cache å¤±æ•ˆäº‹ä»¶ï¼Œå†…éƒ¨è°ƒç”¨ mlcache çš„ delete æ–¹æ³•ï¼ŒåŒæ­¥åˆ°æ‰€æœ‰çš„ Worker ä¸Šã€‚</p>
<pre><code class=language-lua>  local ok, err = self.cluster_events:subscribe(&quot;invalidations&quot;, function(key)
    log(DEBUG, &quot;received invalidate event from cluster for key: '&quot;, key, &quot;'&quot;)
    self:invalidate_local(key)
  end)


function _M:invalidate_local(key, shadow)
  if type(key) ~= &quot;string&quot; then
    error(&quot;key must be a string&quot;, 2)
  end

  log(DEBUG, &quot;invalidating (local): '&quot;, key, &quot;'&quot;)

  local current_page = self.curr_mlcache or 1
  local delete_page
  if shadow and #self.mlcaches == 2 then
    delete_page = current_page == 1 and 2 or 1
  else
    delete_page = current_page
  end

  local ok, err = self.mlcaches[delete_page]:delete(key)
  if not ok then
    log(ERR, &quot;failed to delete entity from node cache: &quot;, err)
  end
end
</code></pre>
<p>è¿™éƒ¨åˆ†ä¸»è¦æè¿° Kong åˆå§‹åŒ–è¿‡ç¨‹ä¸­çš„äº‹ä»¶ç›¸å…³æ“ä½œï¼Œä¸»è¦æ˜¯åˆå§‹åŒ–äº‹ä»¶è®¢é˜…ï¼Œå…³è”åˆ° mlcache çš„ IPC è¿›ç¨‹é—´é€šä¿¡ï¼Œè®¢é˜… cache çš„å¤±æ•ˆäº‹ä»¶ï¼Œå¹¶å…³è” DAO çš„äº‹ä»¶å‘å¸ƒã€‚</p>
<pre><code class=language-lua>function DB:set_events_handler(events)
  for _, dao in pairs(self.daos) do
    dao.events = events
  end
end
</code></pre>
<h2 id=4-äº‹ä»¶åˆ†å‘>4. äº‹ä»¶åˆ†å‘</h2>
<p>Kong ä¸­ä¼—å¤šéƒ¨åˆ†é€šè¿‡éé˜»å¡çš„ <code>ngx.timer.at()</code> å’Œ <code>ngx.timer.every()</code> å‡½æ•°æ‰§è¡Œå®šæ—¶ä»»åŠ¡ã€‚è¿™ä¸€éƒ¨åˆ†è¾ƒä¸ºåˆ†æ•£ï¼Œä¸»è¦å™è¿° Kong æ‰§è¡Œéé˜»å¡ä¸€æ¬¡æ€§äº‹ä»¶å¤„ç†ï¼Œå’Œå…¸å‹çš„å®šæ—¶ä»»åŠ¡ã€‚</p>
<h3 id=41-å•æ¬¡ä»»åŠ¡>4.1. å•æ¬¡ä»»åŠ¡</h3>
<h4 id=411-dns-è§£æ>4.1.1. DNS è§£æ</h4>
<p>åœ¨ <code>cache_warmup.lua</code> ä¸­ç¼“å­˜ services å¯¹è±¡æ—¶ï¼ŒKong ä¼šéé˜»å¡åœ°è·å– services ä¸­ host å¯¹åº”çš„ ipã€‚</p>
<pre><code class=language-lua>  if entity_name == &quot;services&quot; and host_count &gt; 0 then
    ngx.timer.at(0, warmup_dns, hosts_array, host_count)
  end

local function warmup_dns(premature, hosts, count)
  if premature then
    return
  end

  ngx.log(ngx.NOTICE, &quot;warming up DNS entries ...&quot;)

  local start = ngx.now()

  for i = 1, count do
    kong.dns.toip(hosts[i])
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, &quot;finished warming up DNS entries&quot;,
                      &quot;' into the cache (in &quot;, tostring(elapsed), &quot;ms)&quot;)
end
</code></pre>
<p>Kong å†…éƒ¨ dns æ¨¡å—ä½¿ç”¨ <strong><a href=https://github.com/Kong/lua-resty-dns-client>lua-resty-dns-client</a></strong>ï¼Œè¿™ä¸ªåº“ä¹Ÿæ˜¯ç”± Kong å¼€æºçš„ï¼Œç‰¹è‰²æœ‰ <code>toip</code> å‡½æ•°ä¼šæ ¹æ® dns è¿”å› ip çš„æƒé‡é…ç½®åŠ æƒè½®è¯¢çš„æƒé‡ï¼Œå‚¨å­˜ dns æŸ¥è¯¢çš„ç»“æœåœ¨å†…å­˜ä¸­ã€‚</p>
<p><code>warmup_dns()</code> å†…è°ƒç”¨ <code>kong.dns.toip()</code> æ–¹æ³•ï¼š</p>
<pre><code class=language-lua>local function warmup_dns(premature, hosts, count)
  if premature then
    return
  end

  ngx.log(ngx.NOTICE, &quot;warming up DNS entries ...&quot;)

  local start = ngx.now()

  for i = 1, count do
    kong.dns.toip(hosts[i])
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, &quot;finished warming up DNS entries&quot;,
                      &quot;' into the cache (in &quot;, tostring(elapsed), &quot;ms)&quot;)
end
</code></pre>
<h3 id=42-å®šæ—¶ä»»åŠ¡>4.2. å®šæ—¶ä»»åŠ¡</h3>
<h4 id=421-é›†ç¾¤ä»»åŠ¡>4.2.1. é›†ç¾¤ä»»åŠ¡</h4>
<p><code>cluster_events/init.lua</code> ä¸­é›†ç¾¤äº‹æƒ…è®¢é˜…å‡½æ•°é‡Œå¯ç”¨å®šæ—¶å™¨è½®è¯¢æ•°æ®åº“é›†ç¾¤äº‹ä»¶è¡¨ã€‚</p>
<pre><code class=language-lua>function _M:subscribe(channel, cb, start_polling)
  if type(channel) ~= &quot;string&quot; then
    return error(&quot;channel must be a string&quot;)
  end

  if type(cb) ~= &quot;function&quot; then
    return error(&quot;callback must be a function&quot;)
  end

  if not self.callbacks[channel] then
    self.callbacks[channel] = { cb }

    insert(self.channels, channel)

  else
    insert(self.callbacks[channel], cb)
  end

  if start_polling == nil then
    start_polling = true
  end

  if not self.polling and start_polling and self.use_polling then
    -- start recurring polling timer

    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      return nil, &quot;failed to start polling timer: &quot; .. err
    end

    self.polling = true
  end

  return true
end
</code></pre>
<p>è¿™é‡Œå› ä¸ºè¦åœ¨æ¯æ¬¡å¾ªç¯è°ƒç”¨æ—¶è¿›è¡Œé”çš„åˆ¤æ–­ï¼Œæ‰€ä»¥æ²¡æœ‰ä½¿ç”¨ <code>ngx.timer.every()</code> å‡½æ•°ï¼Œè€Œæ˜¯ç”¨æ— é™å¾ªç¯è°ƒç”¨ <code>ngx.timer.at()</code>ã€‚</p>
<pre><code class=language-lua>poll_handler = function(premature, self)
  if premature or not self.polling then
    -- set self.polling to false to stop a polling loop
    return
  end

  if not get_lock(self) then
    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      log(CRIT, &quot;failed to start recurring polling timer: &quot;, err)
    end

    return
  end

  -- single worker

  local pok, perr, err = pcall(poll, self)
  if not pok then
    log(ERR, &quot;poll() threw an error: &quot;, perr)

  elseif not perr then
    log(ERR, &quot;failed to poll: &quot;, err)
  end

  -- unlock

  self.shm:delete(POLL_RUNNING_LOCK_KEY)

  local ok, err = timer_at(self.poll_interval, poll_handler, self)
  if not ok then
    log(CRIT, &quot;failed to start recurring polling timer: &quot;, err)
  end
end
</code></pre>
<p>é”é€šè¿‡å…±äº«å†…å­˜äº‹ä»¶ï¼Œä¿è¯åªæœ‰ä¸€ä¸ª Worker æ‰§è¡Œå•æ¬¡ä»»åŠ¡ã€‚</p>
<pre><code class=language-lua>local function get_lock(self)
  -- check if a poll is not currently running, to ensure we don't start
  -- another poll while a worker is still stuck in its own polling (in
  -- case it is being slow)
  -- we still add an exptime to this lock in case something goes horribly
  -- wrong, to ensure other workers can poll new events
  -- a poll cannot take more than max(poll_interval * 5, 10) -- 10s min
  local ok, err = self.shm:safe_add(POLL_RUNNING_LOCK_KEY, true,
                                    max(self.poll_interval * 5, 10))
  if not ok then
    if err ~= &quot;exists&quot; then
      log(ERR, &quot;failed to acquire poll_running lock: &quot;, err)
    end
    -- else
    --   log(DEBUG, &quot;failed to acquire poll_running lock: &quot;,
    --              &quot;a worker still holds the lock&quot;)

    return false
  end

  if self.poll_interval &gt; 0.001 then
    -- check if interval of `poll_interval` has elapsed already, to ensure
    -- we do not run the poll when a previous poll was quickly executed, but
    -- another worker got the timer trigger a bit too late.
    ok, err = self.shm:safe_add(POLL_INTERVAL_LOCK_KEY, true,
                                self.poll_interval - 0.001)
    if not ok then
      if err ~= &quot;exists&quot; then
        log(ERR, &quot;failed to acquire poll_interval lock: &quot;, err)
      end
      -- else
      --   log(DEBUG, &quot;failed to acquire poll_interval lock: &quot;,
      --              &quot;not enough time elapsed since last poll&quot;)

      self.shm:delete(POLL_RUNNING_LOCK_KEY)

      return false
    end
  end

  return true
end
</code></pre>
<h4 id=422-æ•°æ®åº“-ttl>4.2.2. æ•°æ®åº“ TTL</h4>
<p>ä¸ºç»™ PostgreSQL åŠ ä¸Š TTLï¼ŒKong åœ¨ <code>init_worker</code> é˜¶æ®µè°ƒç”¨æ•°æ®åº“å±‚ <code>db/strategies/postgres/connector.lua</code> ä¸­ <code>init_worker()</code> å‡½æ•°ã€‚</p>
<pre><code class=language-lua>-- ä»¥ä¸‹çœç•¥éƒ¨åˆ†å†…å®¹ï¼Œåªå±•ç¤ºå…³é”®éƒ¨åˆ†
function _mt:init_worker(strategies)
  if ngx.worker.id() == 0 then

      cleanup_statements[i] = concat {
        &quot;  DELETE FROM &quot;,
        self:escape_identifier(table_name),
        &quot; WHERE &quot;,
        column_name,
        &quot; &lt; CURRENT_TIMESTAMP AT TIME ZONE 'UTC';&quot;
      }

    local cleanup_statement = concat(cleanup_statements, &quot;\n&quot;)

    return timer_every(60, function(premature)

      local ok, err, _, num_queries = self:query(cleanup_statement)
      if not ok then
        if num_queries then
          for i = num_queries + 1, cleanup_statements_count do
            local statement = cleanup_statements[i]
            local ok, err = self:query(statement)
            if not ok then
              if err then
                log(WARN, &quot;unable to clean expired rows from table '&quot;,
                          sorted_strategies[i], &quot;' on PostgreSQL database (&quot;,
                          err, &quot;)&quot;)
              else
                log(WARN, &quot;unable to clean expired rows from table '&quot;,
                          sorted_strategies[i], &quot;' on PostgreSQL database&quot;)
              end
            end
          end

        else
          log(ERR, &quot;unable to clean expired rows from PostgreSQL database (&quot;, err, &quot;)&quot;)
        end
      end
    end)
  end

  return true
end
</code></pre>
<p>æ•°æ®åº“åˆå§‹åŒ–æ—¶æ–°å¢ä¸€ä¸ª <code>timer</code>ï¼Œåœ¨åç¨‹ä¸­è°ƒç”¨å›è°ƒå‡½æ•°ï¼Œåˆ é™¤ TTL è¿‡æœŸçš„ rowsã€‚</p>
<h4 id=423-æ›´æ–°è·¯ç”±ç´¢å¼•>4.2.3. æ›´æ–°è·¯ç”±ç´¢å¼•</h4>
<p><code>kong.init_worker()</code> ä¼šæ·»åŠ å®šæ—¶ä»»åŠ¡ï¼Œå®šæ—¶æ›´æ–°ç¼“å­˜ã€‚</p>
<pre><code class=language-lua>      -- å®šæ—¶é‡å»ºè·¯ç”±ç¼“å­˜
      if kong.db.strategy ~= &quot;off&quot; then
        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          -- Don't wait for the semaphore (timeout = 0) when updating via the
          -- timer.
          -- If the semaphore is locked, that means that the rebuild is
          -- already ongoing.
          local ok, err = rebuild_router(ROUTER_ASYNC_OPTS)
          if not ok then
            log(ERR, &quot;could not rebuild router via timer: &quot;, err)
          end
        end)

        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          local ok, err = rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)
          if not ok then
            log(ERR, &quot;could not rebuild plugins iterator via timer: &quot;, err)
          end
        end)
      end
</code></pre>
<p>å®é™…è°ƒç”¨é¡ºåºæ˜¯å¼€ä¸€ä¸ª cosocket åç¨‹ï¼Œåˆ¤æ–­ routes æ˜¯å¦æœ‰å˜åŒ–ï¼Œå˜åŒ–åˆ™é‡æ„è·¯ç”±ç¼“å­˜ã€‚</p>
<pre><code class=language-lua>  rebuild_router = function(opts)
    return rebuild(&quot;router&quot;, update_router, router_version, opts)
  end

local function rebuild(name, callback, version, opts)
  local current_version, err = kong.core_cache:get(name .. &quot;:version&quot;, TTL_ZERO,
                                                   utils.uuid)
  if err then
    return nil, &quot;failed to retrieve &quot; .. name .. &quot; version: &quot; .. err
  end

  if current_version == version then
    return true
  end

  -- å¼€ä¸€ä¸ª cosocket åç¨‹è°ƒç”¨ callback
  return concurrency.with_coroutine_mutex(opts, callback)
end

  update_router = function()
    -- we might not need to rebuild the router (if we were not
    -- the first request in this process to enter this code path)
    -- check again and rebuild only if necessary
    local version, err = get_router_version()
    if err then
      return nil, &quot;failed to retrieve router version: &quot; .. err
    end

    if version == router_version then
      return true
    end

    local ok, err = build_router(version)
    if not ok then
      return nil, --[[ 'err' fully formatted ]] err
    end

    return true
  end
</code></pre>
<p>æœ€ç»ˆè¿˜ä¼šè°ƒç”¨åˆ° <code>build_router()</code> æ–¹æ³•ï¼Œæˆ‘ä»¬å·²ç»åœ¨ 1.2.1 ä¸­æè¿°è¿‡ã€‚</p>
<h2 id=5-äº‹ä»¶å¤„ç†>5. äº‹ä»¶å¤„ç†</h2>
<p>Worker é—´çš„äº‹ä»¶å¤„ç†ä½¿ç”¨ <code>lua-resty-worker-events</code> åº“ã€‚</p>
<p>äº‹ä»¶è®¢é˜…å‡½æ•°ï¼š<code>events.register(callback, source, event1, event2, ...)</code>ï¼Œcallback æ–¹æ³• <code>callback = function(data, event, source, pid)</code>ã€‚</p>
<p>äº‹ä»¶å‘å¸ƒå‡½æ•°ï¼š<code>success, err = events.post(source, event, data, unique)</code></p>
<h3 id=51-æ•°æ®åº“äº‹ä»¶>5.1. æ•°æ®åº“äº‹ä»¶</h3>
<p><code>db/dao/init.lua</code> ä¸­å®šä¹‰äº† DAO ç›¸å…³çš„æ“ä½œæ–¹æ³•ï¼Œæˆ‘å·²ç»åœ¨ 1.1.3 ä¸­ç®€å•é˜è¿°è¿‡äº†ã€‚</p>
<p>æ•°æ®åº“ç›¸å…³å®ä½“çš„ CRUDï¼ˆå…¶å®æ²¡æœ‰Rï¼‰äº‹ä»¶æœ€åä¼šè°ƒç”¨ <code>DAO:post_crud_event()</code> æ–¹æ³•å¹¿æ’­äº‹ä»¶ã€‚</p>
<pre><code class=language-lua>function DAO:post_crud_event(operation, entity, old_entity, options)
  if options and options.no_broadcast_crud_event then
    return
  end

  if self.events then
    local entity_without_nulls
    if entity then
      entity_without_nulls = remove_nulls(utils.deep_copy(entity, false))
    end

    local old_entity_without_nulls
    if old_entity then
      old_entity_without_nulls = remove_nulls(utils.deep_copy(old_entity, false))
    end

    local ok, err = self.events.post_local(&quot;dao:crud&quot;, operation, {
      operation  = operation,
      schema     = self.schema,
      entity     = entity_without_nulls,
      old_entity = old_entity_without_nulls,
    })
    if not ok then
      log(ERR, &quot;[db] failed to propagate CRUD operation: &quot;, err)
    end
  end
end
</code></pre>
<p>åœ¨ <code>dao:crud</code> é€šé“å‘å¸ƒäº†ä¸€ä¸ªäº‹ä»¶ï¼Œoperation ç±»å‹æœ‰ createã€updateã€deleteã€‚</p>
<p><code>runloop/handler.lua</code> ä¸­ <code>register_events()</code> ä¼šåœ¨ <code>kong.init_worker()</code> ä¸­è¢«è°ƒç”¨ï¼Œæ­¤æ—¶ä¼šè®¢é˜…æ•°æ®åº“ç›¸å…³äº‹ä»¶ï¼Œæ·»åŠ å¤„ç†å‡½æ•°ã€‚</p>
<pre><code class=language-lua>  worker_events.register(function(data)
    if not data.schema then
      log(ERR, &quot;[events] missing schema in crud subscriber&quot;)
      return
    end

    if not data.entity then
      log(ERR, &quot;[events] missing entity in crud subscriber&quot;)
      return
    end

    -- invalidate this entity anywhere it is cached if it has a
    -- caching key
    -- å¦‚æœ entity æœ‰ cache_key åˆ™è®©å®ƒå¤±æ•ˆ
    -- åŸºæœ¬ä¸Šä¹Ÿåªæœ‰ entity schema å®šä¹‰å‡ºé”™çš„æƒ…å†µä¸‹æ‰ä¸ä¼šæœ‰ cache_key

    local cache_key = db[data.schema.name]:cache_key(data.entity)
    local cache_obj = kong[constants.ENTITY_CACHE_STORE[data.schema.name]]

    if cache_key then
      cache_obj:invalidate(cache_key)
    end

    -- if we had an update, but the cache key was part of what was updated,
    -- we need to invalidate the previous entity as well

    if data.old_entity then
      local old_cache_key = db[data.schema.name]:cache_key(data.old_entity)
      if old_cache_key and cache_key ~= old_cache_key then
        cache_obj:invalidate(old_cache_key)
      end
    end

    if not data.operation then
      log(ERR, &quot;[events] missing operation in crud subscriber&quot;)
      return
    end

    -- public worker events propagation

    -- è·å– schema åå­—
    local entity_channel           = data.schema.table or data.schema.name
    local entity_operation_channel = fmt(&quot;%s:%s&quot;, entity_channel,
      data.operation)

    -- crud:routes
    local ok, err = worker_events.post_local(&quot;crud&quot;, entity_channel, data)
    if not ok then
      log(ERR, &quot;[events] could not broadcast crud event: &quot;, err)
      return
    end

    -- crud:routes:create
    ok, err = worker_events.post_local(&quot;crud&quot;, entity_operation_channel, data)
    if not ok then
      log(ERR, &quot;[events] could not broadcast crud event: &quot;, err)
      return
    end
  end, &quot;dao:crud&quot;)
</code></pre>
<p>CRUDï¼ˆæ²¡æœ‰ Rï¼‰äº‹ä»¶å¤„ç†æµç¨‹ï¼šè°ƒç”¨ <code>cache:invalidate()</code> æ–¹æ³•ï¼Œæ–¹æ³•å†…éƒ¨å‘å¸ƒäº†ä¸€ä¸ª worker çº§äº‹ä»¶ï¼Œé€šçŸ¥ worker è¿›ç¨‹åˆ é™¤è¯¥æ•°æ®ï¼Œè¿˜ä¼šå‘å¸ƒä¸€ä¸ªé›†ç¾¤äº‹ä»¶ï¼Œåœ¨é›†ç¾¤é—´åŒæ­¥åˆ é™¤æ•°æ®ã€‚</p>
<pre><code class=language-lua>  -- ä¿®æ”¹äº† Routes åä¼šæ¸…ç©º router:version ç¼“å­˜ï¼Œ
  -- ä¼šå¯¼è‡´é‡æ–°æ„å»ºè·¯ç”±è¡¨ï¼Œè¯¦æƒ…æŸ¥çœ‹ 2.2.3
  worker_events.register(function()
    log(DEBUG, &quot;[events] Route updated, invalidating router&quot;)
    core_cache:invalidate(&quot;router:version&quot;)
  end, &quot;crud&quot;, &quot;routes&quot;)

...å…¶ä»–å¯¹è±¡åŒç†
</code></pre>
<h2 id=6-æ’ä»¶åŠ è½½>6. æ’ä»¶åŠ è½½</h2>
<h3 id=61-æ’ä»¶è¯»å–>6.1. æ’ä»¶è¯»å–</h3>
<p><code>init</code> é˜¶æ®µä¼šåŠ è½½é…ç½®æ–‡ä»¶ä¸­ <code>plugins=bundled,skywalking-intergrator</code> çš„æ’ä»¶åˆ—è¡¨ï¼Œè°ƒç”¨ Lua <code>require</code> åŠ è½½å¯¹åº”çš„åŒ…ã€‚ï¼ˆæ‰€æœ‰çš„æ’ä»¶åŒ…éƒ½è¦æ±‚åœ¨ <code>kong.plugins</code> ä¸‹ï¼‰</p>
<pre><code class=language-lua>function Plugins:load_plugin_schemas(plugin_set)
  self.handlers = nil

  local go_plugins_cnt = 0
  local handlers = {}
  local errs

  -- load installed plugins
  for plugin in pairs(plugin_set) do
    local handler, err = load_plugin(self, plugin)

    if handler then
      if type(handler.is) == &quot;function&quot; and handler:is(BasePlugin) then
        -- Backwards-compatibility for 0.x and 1.x plugins inheriting from the
        -- BasePlugin class.
        -- TODO: deprecate &amp; remove
        handler = handler()
      end

      if handler._go then
        go_plugins_cnt = go_plugins_cnt + 1
      end

      handlers[plugin] = handler

    else
      errs = errs or {}
      table.insert(errs, &quot;on plugin '&quot; .. plugin .. &quot;': &quot; .. tostring(err))
    end
  end

  if errs then
    return nil, &quot;error loading plugin schemas: &quot; .. table.concat(errs, &quot;; &quot;)
  end

  reports.add_immutable_value(&quot;go_plugins_cnt&quot;, go_plugins_cnt)

  self.handlers = handlers

  return true
end
</code></pre>
<p>æ‰€æœ‰æ’ä»¶çš„ Handler å‡½æ•°ä¼šè¢«å‚¨å­˜åœ¨ <code>kong.db.plugins.handlers</code>ï¼Œæ•°æ®æ ¼å¼ä¸º <code>{plugin_name: handler}</code>ã€‚</p>
<p>æ‰€æœ‰çš„æ’ä»¶ä¼šå‚¨å­˜åˆ° Worker è¿›ç¨‹ä¸Šï¼Œå‘¨æœŸæ€§è¿›è¡ŒåŒæ­¥æ›´æ–°ã€‚</p>
<p>æˆ‘æ•´ç†äº†æ’ä»¶è¡¨åŠ è½½åˆ° Lua table çš„ç»“æ„ï¼Œè¾“å‡ºæˆ YAMLï¼Œæ–¹ä¾¿ç†è§£ï¼š</p>
<pre><code class=language-yaml>map:
  plugin_name: true

combos:
  plugin_name:
    # both: {}
    both:
      route_id: service_id
    # routes: {}
    routes:
      route_id: true
    # services: {}
    services:
      service_id: true
    0: true # å…¨å±€æ’ä»¶
    1: true # è·¯ç”±æ’ä»¶
    2: true # Service æ’ä»¶
    3: true # è·¯ç”±+Service
    4: true # Consumer æ’ä»¶
    5: true # è·¯ç”±+Consumer æ’ä»¶
    6: true # è·¯ç”±+Service+Consumer æ’ä»¶

loaded:
  plugin_name:
    handler:
      phase_name: func()
</code></pre>
<h3 id=62-æ’ä»¶è°ƒç”¨>6.2. æ’ä»¶è°ƒç”¨</h3>
<p>æ’ä»¶ä¸ç›´æ¥å’Œè·¯ç”±è¿›è¡Œç»‘å®šï¼Œæ’ä»¶æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œå’Œ Kong çš„ç”Ÿå‘½å‘¨æœŸåŸºæœ¬ç›¸åŒã€‚åœ¨ Kong ç”Ÿå‘½å‘¨æœŸçš„å„ä¸ªé˜¶æ®µä¼šè°ƒç”¨æ’ä»¶çš„å¯¹åº”æ–¹æ³•ã€‚</p>
<p>æ’ä»¶åªåœ¨è°ƒç”¨é˜¶æ®µè¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦å…³è”å½“å‰ Routeã€Serviceã€å’Œ Consumerï¼Œæœ‰åˆ™ä»æ•°æ®åº“è¯»å–æ’ä»¶å…³è”çš„é…ç½®é¡¹ï¼ˆæ’ä»¶ Entityï¼‰ï¼Œå¹¶ä½¿ç”¨ <code>kong.core_cache</code> è¿›è¡Œç¼“å­˜ã€‚</p>
<pre><code class=language-lua>local function load_configuration_through_combos(ctx, combos, plugin)
  local plugin_configuration
  local name = plugin.name

  local route    = ctx.route
  local service  = ctx.service
  local consumer = ctx.authenticated_consumer

  if route and plugin.no_route then
    route = nil
  end
  if service and plugin.no_service then
    service = nil
  end
  if consumer and plugin.no_consumer then
    consumer = nil
  end

  local    route_id = route    and    route.id or nil
  local  service_id = service  and  service.id or nil
  local consumer_id = consumer and consumer.id or nil

  if kong.db.strategy == &quot;off&quot; then
	...
  else
    if route_id and service_id and consumer_id and combos[COMBO_RSC]
      and combos.both[route_id] == service_id
    then
      plugin_configuration = load_configuration(ctx, name, route_id, service_id,
                                                consumer_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    if consumer_id and combos[COMBO_C] then
      plugin_configuration = load_configuration(ctx, name, nil, nil, consumer_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    if route_id and combos[COMBO_R] and combos.routes[route_id] then
      plugin_configuration = load_configuration(ctx, name, route_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    ...

    if combos[COMBO_GLOBAL] then
      return load_configuration(ctx, name)
    end
  end
end
</code></pre>
<p>è¿™é‡Œä¼šæŸ¥è¯¢å½“å‰ Serviceã€Route å’Œ Consumer æ˜¯å¦ä¸æŸä¸ªæ’ä»¶é…å¯¹ï¼ŒæˆåŠŸåˆ™åŠ è½½å¯¹åº”çš„é…ç½®é¡¹ï¼š</p>
<pre><code class=language-lua>--- Load the configuration for a plugin entry.
-- Given a Route, Service, Consumer and a plugin name, retrieve the plugin's
-- configuration if it exists. Results are cached in ngx.dict
-- @param[type=string] name Name of the plugin being tested for configuration.
-- @param[type=string] route_id Id of the route being proxied.
-- @param[type=string] service_id Id of the service being proxied.
-- @param[type=string] consumer_id Id of the donsumer making the request (if any).
-- @treturn table Plugin configuration, if retrieved.
local function load_configuration(ctx,
                                  name,
                                  route_id,
                                  service_id,
                                  consumer_id)
  local ws_id = workspaces.get_workspace_id() or kong.default_workspace
  local key = kong.db.plugins:cache_key(name,
                                        route_id,
                                        service_id,
                                        consumer_id,
                                        nil,
                                        ws_id)
  local plugin, err = kong.core_cache:get(key,
                                          nil,
                                          load_plugin_from_db,
                                          key)
  if err then
    ctx.delay_response = false
    ngx.log(ngx.ERR, tostring(err))
    return ngx.exit(ngx.ERROR)
  end

  if not plugin or not plugin.enabled then
    return
  end

  local cfg = plugin.config or {}

  if not cfg.__key__ then
    cfg.__key__ = key
    cfg.__seq__ = next_seq
    next_seq = next_seq + 1
  end

  cfg.route_id    = plugin.route and plugin.route.id
  cfg.service_id  = plugin.service and plugin.service.id
  cfg.consumer_id = plugin.consumer and plugin.consumer.id

  return cfg
end
</code></pre>
<p>æ’ä»¶çš„è°ƒç”¨æœ‰ä¸¤ç§æ–¹å¼ï¼š</p>
<ol>
<li>åŒæ­¥è°ƒç”¨</li>
<li>å¼‚æ­¥è°ƒç”¨</li>
</ol>
<p>é™¤äº† <code>access_by_lua</code> é˜¶æ®µï¼Œéƒ½æ˜¯ä½¿ç”¨åŒæ­¥è°ƒç”¨ï¼š</p>
<pre><code class=language-lua>local function execute_plugins_iterator(plugins_iterator, phase, ctx)
  local old_ws = ctx and ctx.workspace
  for plugin, configuration in plugins_iterator:iterate(phase, ctx) do
    if ctx then
      if plugin.handler._go then
        ctx.ran_go_plugin = true
      end

      kong_global.set_named_ctx(kong, &quot;plugin&quot;, plugin.handler)
    end

    kong_global.set_namespaced_log(kong, plugin.name)
    -- è¿™é‡Œæ˜¯åŒæ­¥è°ƒç”¨
    plugin.handler[phase](plugin.handler, configuration)
    kong_global.reset_log(kong)

    if ctx then
      ctx.workspace = old_ws
    end
  end
end
</code></pre>
<p>è€Œåœ¨ <code>access_by_lua</code> é˜¶æ®µï¼Œä½¿ç”¨åç¨‹å¼‚æ­¥è°ƒç”¨ï¼š</p>
<pre><code class=language-lua>  for plugin, plugin_conf in plugins_iterator:iterate(&quot;access&quot;, ctx) do
    if plugin.handler._go then
      ctx.ran_go_plugin = true
    end

    if not ctx.delayed_response then
      kong_global.set_named_ctx(kong, &quot;plugin&quot;, plugin.handler)
      kong_global.set_namespaced_log(kong, plugin.name)

      -- ä½¿ç”¨ Lua coroutine å¼€å¯åç¨‹å¼‚æ­¥è°ƒç”¨æ’ä»¶å‡½æ•°
      local err = coroutine.wrap(plugin.handler.access)(plugin.handler, plugin_conf)
      if err then
        kong.log.err(err)
        ctx.delayed_response = {
          status_code = 500,
          content     = { message  = &quot;An unexpected error occurred&quot; },
        }
      end

      kong_global.reset_log(kong)
    end
    ctx.workspace = old_ws
  end
</code></pre>
<h2 id=7-ç¼“å­˜æœºåˆ¶>7. ç¼“å­˜æœºåˆ¶</h2>
<p>æœ¬èŠ‚æ ¹æ®æˆ‘å¯¹ Kong æºç çš„åˆ†æï¼Œåšä¸€ä¸ªç¼“å­˜æœºåˆ¶çš„å°å›é¡¾ã€‚</p>
<p>Kong é’ˆå¯¹ç¼“å­˜æœ‰è¿™äº›æ“ä½œï¼š</p>
<ul>
<li>åˆå§‹åŒ–ç¼“å­˜å—</li>
<li>é¢„è½½åŠ è½½æ•°æ®åº“å†…å®¹åˆ°ç¼“å­˜</li>
<li>è®¿é—®æ—¶æ‰åŠ è½½çš„æ•°æ®å†…å®¹æ·»åŠ åˆ°ç¼“å­˜</li>
<li>timer å®šæ—¶æ›´æ–°ç¼“å­˜</li>
<li>æ•°æ®åº“ CRUD æ“ä½œåˆ é™¤ç¼“å­˜</li>
<li>é›†ç¾¤/Worker é—´åŒæ­¥ç¼“å­˜</li>
</ul>
<p>ç¼“å­˜åŠ è½½å†…å®¹ï¼š</p>
<p>é»˜è®¤é…ç½®ä¸‹ï¼ŒKong å°†è·¯ç”±è¡¨å’Œ Routes å…¨é‡åŠ è½½åˆ°æ¯ä¸ª Worker çš„å†…å­˜ï¼ŒServices å’Œ Plugins å…¨é‡åŠ è½½åˆ°æ¯ä¸ª Worker çš„å†…å­˜å’Œå…±äº«å†…å­˜ä¸­ã€‚Upstreams å’Œ Targets æ ¹æ®è´Ÿè½½å‡è¡¡å™¨çš„è§£æåŠæ—¶ä»æ•°æ®åº“è·å–ï¼ŒåŠ è½½åˆ°å†…å­˜å’Œå…±äº«å†…å­˜ä¸­ã€‚</p>
<p>ä¸Šè¿° Entity åŠ è½½åœ¨ç”± mlcache åº“åˆ›å»ºçš„ L1+L2 ä¸¤çº§ç¼“å­˜ <code>core_cache</code> ä¸­ã€‚</p>
<p>è€Œ consumers åŠ è½½åˆ°åŒä¸º mlcache åˆ›å»ºçš„ä¸åŒåçš„ <code>cache</code> ä¸­ã€‚</p>
<h2 id=8-è¯·æ±‚ç”Ÿå‘½å‘¨æœŸ>8. è¯·æ±‚ç”Ÿå‘½å‘¨æœŸ</h2>
<p>æœ¬èŠ‚è®²è¿°ä¸€ä¸ªè¯·æ±‚ç»è¿‡ Kong å¤„ç†çš„æµç¨‹ã€‚</p>
<h3 id=81-ssl_certificate_by_lua-é˜¶æ®µ>8.1. ssl_certificate_by_lua é˜¶æ®µ</h3>
<pre><code class=language-lua>local function execute()
  local sn, err = server_name()
  if err then
    log(ERR, &quot;could not retrieve SNI: &quot;, err)
    return ngx.exit(ngx.ERROR)
  end

  local cert_and_key, err = find_certificate(sn)
  if err then
    log(ERR, err)
    return ngx.exit(ngx.ERROR)
  end

  if cert_and_key == default_cert_and_key then
    -- use (already set) fallback certificate
    return
  end

  -- set the certificate for this connection

  local ok, err = clear_certs()
  if not ok then
    log(ERR, &quot;could not clear existing (default) certificates: &quot;, err)
    return ngx.exit(ngx.ERROR)
  end

  ok, err = set_cert(cert_and_key.cert)
  if not ok then
    log(ERR, &quot;could not set configured certificate: &quot;, err)
    return ngx.exit(ngx.ERROR)
  end

  ok, err = set_priv_key(cert_and_key.key)
  if not ok then
    log(ERR, &quot;could not set configured private key: &quot;, err)
    return ngx.exit(ngx.ERROR)
  end
end
</code></pre>
<p>æ ¹æ® Server Name æŸ¥æ‰¾å¯¹åº” SSL è¯ä¹¦ Cert å’Œç§é’¥å¹¶è®¾ç½®åœ¨ Nginx ä¸Šã€‚</p>
<h3 id=82-rewrite_by_lua-é˜¶æ®µ>8.2. rewrite_by_lua é˜¶æ®µ</h3>
<pre><code class=language-lua>  local ctx = ngx.ctx
  if not ctx.KONG_PROCESSING_START then
    ctx.KONG_PROCESSING_START = ngx.req.start_time() * 1000
  end

  if not ctx.KONG_REWRITE_START then
    ctx.KONG_REWRITE_START = get_now_ms()
  end

  kong_global.set_phase(kong, PHASES.rewrite)
  kong_resty_ctx.stash_ref()

  local is_https = var.https == &quot;on&quot;
  if not is_https then
    log_init_worker_errors(ctx)
  end

  runloop.rewrite.before(ctx)

...

  rewrite = {
    before = function(ctx)
      ctx.host_port = HOST_PORTS[var.server_port] or var.server_port

      -- special handling for proxy-authorization and te headers in case
      -- the plugin(s) want to specify them (store the original)
      ctx.http_proxy_authorization = var.http_proxy_authorization
      ctx.http_te                  = var.http_te
    end,
  },
</code></pre>
<p>åˆå§‹åŒ– <code>kong.ctx</code> ç”Ÿå‘½å‘¨æœŸ Contextï¼Œä¸º Context æ·»åŠ è¯·æ±‚ä¿¡æ¯ã€‚</p>
<h3 id=83-access_by_lua-é˜¶æ®µ>8.3. access_by_lua é˜¶æ®µ</h3>
<h4 id=831-è·¯ç”±åŒ¹é…>8.3.1. è·¯ç”±åŒ¹é…</h4>
<p><code>runloop.access.before</code> ä¼šè¿›è¡Œè°ƒç”¨ <code>Router</code> å®ä¾‹è¿›è¡Œè·¯ç”±åŒ¹é…ã€‚é¦–å…ˆä¼šè°ƒç”¨ <code>get_updated_router()</code> åˆ¤æ–­æ˜¯å¦æœ‰è·¯ç”±æ›´æ–°ï¼Œæ²¡æœ‰åˆ™è¿”å›å½“å‰ <code>Router</code> å®ä¾‹ã€‚</p>
<pre><code class=language-lua>      -- routing request
      local router = get_updated_router()
	  -- è°ƒç”¨ Router.exec() æŸ¥æ‰¾åŒ¹é…çš„è·¯ç”±
      local match_t = router.exec()
      if not match_t then
        return kong.response.exit(404, { message = &quot;no Route matched with those values&quot; })
      end
</code></pre>
<p><code>Router.exec()</code> æ–¹æ³•æœ€ç»ˆä¼šè°ƒç”¨ <code>Router.find_route()</code> æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æ¥æ”¶è¯·æ±‚å¤´å­—æ®µï¼Œå¹¶ç”Ÿæˆè·¯ç”± Cache Keyï¼ŒæŸ¥æ‰¾å¯¹åº”çš„é¡¹ç›®ã€‚</p>
<pre><code class=language-lua>  local function find_route(req_method, req_uri, req_host, req_scheme,
                            src_ip, src_port,
                            dst_ip, dst_port,
                            sni, req_headers)

    req_method = req_method or &quot;&quot;
    req_uri = req_uri or &quot;&quot;
    req_host = req_host or &quot;&quot;
    req_headers = req_headers or EMPTY_T

    ctx.req_method     = req_method
    ctx.req_uri        = req_uri
    ctx.req_host       = req_host
    ctx.req_headers    = req_headers
    ctx.src_ip         = src_ip or &quot;&quot;
    ctx.src_port       = src_port or &quot;&quot;
    ctx.dst_ip         = dst_ip or &quot;&quot;
    ctx.dst_port       = dst_port or &quot;&quot;
    ctx.sni            = sni or &quot;&quot;

    local cache_key = req_method .. &quot;|&quot; .. req_uri .. &quot;|&quot; .. req_host ..
                      &quot;|&quot; .. ctx.src_ip .. &quot;|&quot; .. ctx.src_port ..
                      &quot;|&quot; .. ctx.dst_ip .. &quot;|&quot; .. ctx.dst_port ..
                      &quot;|&quot; .. ctx.sni

    do
      local match_t = cache:get(cache_key)
      if match_t and hits.header_name == nil then
        return match_t
      end
    end
</code></pre>
<p>å¦‚æœ LRU ç¼“å­˜ä¸­æœ‰åŒ¹é…è·¯ç”±ï¼Œåˆ™ç›´æ¥è¿”å›ã€‚</p>
<p>å¦åˆ™ç»§ç»­åŒ¹é…è·¯ç”±ï¼Œç”ŸæˆåŒ¹é…é¡¹ç›®ï¼Œå¹¶å­˜å…¥ç¼“å­˜ä¸­ã€‚</p>
<pre><code class=language-lua>              ...
              local match_t     = {
                  route           = matched_route.route,
                  service         = matched_route.service,
                  headers         = matched_route.headers,
                  upstream_url_t  = upstream_url_t,
                  upstream_scheme = upstream_url_t.scheme,
                  upstream_uri    = upstream_uri,
                  upstream_host   = upstream_host,
                  prefix          = request_prefix,
                  matches         = {
                    uri_captures  = matches.uri_captures,
                    uri           = matches.uri,
                    host          = matches.host,
                    headers       = matches.headers,
                    method        = matches.method,
                    src_ip        = matches.src_ip,
                    src_port      = matches.src_port,
                    dst_ip        = matches.dst_ip,
                    dst_port      = matches.dst_port,
                    sni           = matches.sni,
                  }
                }

                if band(matched_route.match_rules, MATCH_RULES.HEADER) == 0 then
                  cache:set(cache_key, match_t)
                end
                ...
</code></pre>
<p>åŒ¹é…æˆåŠŸåä¼šå°†å…³è”çš„ Route å’Œ Service å†™å…¥ <code>ngx.ctx</code> ï¼Œåœ¨æ¥ä¸‹æ¥çš„ç”Ÿå‘½å‘¨æœŸä¸­å…±äº«ã€‚</p>
<h4 id=832-è¯·æ±‚è°ƒåº¦>8.3.2. è¯·æ±‚è°ƒåº¦</h4>
<p><code>runloop.access.after</code> ä¸­æ ¹æ® Routeã€Service ç­‰æ¡ä»¶è§£æå‡ºåç«¯è¦è¯·æ±‚çš„ IPã€Portã€Schema ç­‰å‚æ•°ã€‚</p>
<pre><code class=language-lua>-- looks up a balancer for the target.
-- @param target the table with the target details
-- @param no_create (optional) if true, do not attempt to create
-- (for thorough testing purposes)
-- @return balancer if found, `false` if not found, or nil+error on error
local function get_balancer(target, no_create)
  -- NOTE: only called upon first lookup, so `cache_only` limitations
  -- do not apply here
  local hostname = target.host


  -- first go and find the upstream object, from cache or the db
  local upstream, err = get_upstream_by_name(hostname)
  if upstream == false then
    return false -- no upstream by this name
  end
  if err then
    return nil, err -- there was an error
  end

  local balancer = balancers[upstream.id]
  if not balancer then
    if no_create then
      return nil, &quot;balancer not found&quot;
    else
      log(ERR, &quot;balancer not found for &quot;, upstream.name, &quot;, will create it&quot;)
      return create_balancer(upstream), upstream
    end
  end

  return balancer, upstream
end
</code></pre>
<p><code>get_balancer()</code> æ ¹æ® Service çš„ Host è¿”å›æœ€ç»ˆè¯·æ±‚çš„ Targetï¼Œå’Œè´Ÿè½½å‡è¡¡å™¨ã€‚</p>
<pre><code class=language-lua>  local ip, port, hostname, handle
  if balancer then
    -- have to invoke the ring-balancer
    local hstate = run_hook(&quot;balancer:get_peer:pre&quot;, target.host)
    ip, port, hostname, handle = balancer:getPeer(dns_cache_only,
                                          target.balancer_handle,
                                          hash_value)
    run_hook(&quot;balancer:get_peer:post&quot;, hstate)
    if not ip and
      (port == &quot;No peers are available&quot; or port == &quot;Balancer is unhealthy&quot;) then
      return nil, &quot;failure to get a peer from the ring-balancer&quot;, 503
    end
    hostname = hostname or ip
    target.hash_value = hash_value
    target.balancer_handle = handle

  else
    -- have to do a regular DNS lookup
    local try_list
    local hstate = run_hook(&quot;balancer:to_ip:pre&quot;, target.host)
    ip, port, try_list = toip(target.host, target.port, dns_cache_only)
    run_hook(&quot;balancer:to_ip:post&quot;, hstate)
    hostname = target.host
    if not ip then
      log(ERR, &quot;DNS resolution failed: &quot;, port, &quot;. Tried: &quot;, tostring(try_list))
      if port == &quot;dns server error: 3 name error&quot; or
         port == &quot;dns client error: 101 empty record received&quot; then
        return nil, &quot;name resolution failed&quot;, 503
      end
    end
  end
</code></pre>
<p>è°ƒç”¨è´Ÿè½½å‡è¡¡å™¨çš„ç­–ç•¥è·å– Target çš„ IPï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨ DNS æŸ¥è¯¢è·å– IP åœ°å€ï¼Œè¿™ä¸€æ­¥åœ¨ 2.1.1 ä¸­å·²ç»æå‰è¿›è¡Œäº† DNS é¢„ç¼“å­˜ï¼Œè¿™é‡Œå¯ä»¥ä»ç¼“å­˜ä¸­è¯»å–ã€‚</p>
<p>å¦‚æœ Service Host ç›´æ¥æ˜¯ IP åœ°å€ï¼Œåˆ™ä¸æ‰§è¡Œè´Ÿè½½å‡è¡¡ç­–ç•¥ã€‚</p>
<pre><code class=language-lua>  -- ip åˆ™ç›´æ¥è¿”å›
  if target.type ~= &quot;name&quot; then
    -- it's an ip address (v4 or v6), so nothing we can do...
    target.ip = target.host
    target.port = target.port or 80 -- TODO: remove this fallback value
    target.hostname = target.host
    return true
  end
</code></pre>
<h3 id=84-balancer_by_lua-é˜¶æ®µ>8.4. balancer_by_lua é˜¶æ®µ</h3>
<p>ä½¿ç”¨ <code>ngx.balancer.set_more_tries()</code> è®¾ç½®é”™è¯¯é‡è¯•æ¬¡æ•°ï¼Œä½¿ç”¨ <code>ngx.balancer.get_last_failure()</code> è·å–ä¸Šä¸€æ¬¡è¯·æ±‚é”™è¯¯è¯¦æƒ…ï¼Œåœ¨é”™è¯¯å¤„ç†ä¸­è¿›è¡Œå¯¹ä¸Šæ¸¸èŠ‚ç‚¹è¿›è¡Œè¢«åŠ¨å¥åº·æ£€æŸ¥ã€‚</p>
<pre><code class=language-lua>  if balancer_data.try_count &gt; 1 then
    -- only call balancer on retry, first one is done in `runloop.access.after`
    -- which runs in the ACCESS context and hence has less limitations than
    -- this BALANCER context where the retries are executed

    -- record failure data
    local previous_try = tries[balancer_data.try_count - 1]
    previous_try.state, previous_try.code = get_last_failure()

    -- Report HTTP status for health checks
    local balancer = balancer_data.balancer
    if balancer then
      if previous_try.state == &quot;failed&quot; then
        if previous_try.code == 504 then
          balancer.report_timeout(balancer_data.balancer_handle)
        else
          balancer.report_tcp_failure(balancer_data.balancer_handle)
        end

      else
        balancer.report_http_status(balancer_data.balancer_handle,
                                    previous_try.code)
      end
    end

    local ok, err, errcode = balancer_execute(balancer_data)
    if not ok then
      ngx_log(ngx_ERR, &quot;failed to retry the dns/balancer resolver for &quot;,
              tostring(balancer_data.host), &quot;' with: &quot;, tostring(err))

      ctx.KONG_BALANCER_ENDED_AT = get_now_ms()
      ctx.KONG_BALANCER_TIME = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_BALANCER_START
      ctx.KONG_PROXY_LATENCY = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_PROCESSING_START

      return ngx.exit(errcode)
    end

  else
    -- first try, so set the max number of retries
    local retries = balancer_data.retries
    if retries &gt; 0 then
      set_more_tries(retries)
    end
  end
</code></pre>
<p>è¯·æ±‚åˆ°æœ€ç»ˆè§£æçš„åç«¯æœåŠ¡ï¼Œä½¿ç”¨ <code>ngx.balancer.set_current_peer()</code> æ–¹æ³•è®¾ç½®è®¿é—®çš„åœ°å€ã€‚</p>
<pre><code class=language-lua>  -- set the targets as resolved
  ngx_log(ngx_DEBUG, &quot;setting address (try &quot;, balancer_data.try_count, &quot;): &quot;,
                     balancer_data.ip, &quot;:&quot;, balancer_data.port)
  -- æœ€ç»ˆè°ƒåº¦çš„åœ°å€
  local ok, err = set_current_peer(balancer_data.ip, balancer_data.port, pool_opts)
  if not ok then
    ngx_log(ngx_ERR, &quot;failed to set the current peer (address: &quot;,
            tostring(balancer_data.ip), &quot; port: &quot;, tostring(balancer_data.port),
            &quot;): &quot;, tostring(err))

    ctx.KONG_BALANCER_ENDED_AT = get_now_ms()
    ctx.KONG_BALANCER_TIME = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_BALANCER_START
    ctx.KONG_PROXY_LATENCY = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_PROCESSING_START

    return ngx.exit(500)
  end
</code></pre>
<h3 id=85-header_filter_by_lua-é˜¶æ®µ>8.5. header_filter_by_lua é˜¶æ®µ</h3>
<p>æ­¤é˜¶æ®µåœ¨ Kong æ¥æ”¶å®Œä¸Šæ¸¸æœåŠ¡è¿”å›çš„ Header å­—æ®µåæ‰§è¡Œã€‚</p>
<pre><code class=language-lua>      local upstream_status_header = constants.HEADERS.UPSTREAM_STATUS
      if singletons.configuration.enabled_headers[upstream_status_header] then
        header[upstream_status_header] = tonumber(sub(var.upstream_status or &quot;&quot;, -3))
        if not header[upstream_status_header] then
          log(ERR, &quot;failed to set &quot;, upstream_status_header, &quot; header&quot;)
        end
      end

      local hash_cookie = ctx.balancer_data.hash_cookie
      if not hash_cookie then
        return
      end

      local cookie = ck:new()
      local ok, err = cookie:set(hash_cookie)
</code></pre>
<p><code>runloop.header_filter.before</code> ä¸­åœ¨è¿”å›ç»“æœçš„ header é‡ŒåŠ å…¥èŠ‚ç‚¹çŠ¶æ€ï¼Œä»¥åŠåˆ¤æ–­æ˜¯å¦éœ€è¦åŠ å…¥è´Ÿè½½å‡è¡¡å™¨ä¸€è‡´æ€§ç­–ç•¥çš„ Cookieã€‚</p>
<h3 id=86-body_filter_by_lua-é˜¶æ®µ>8.6. body_filter_by_lua é˜¶æ®µ</h3>
<p>æ­¤é˜¶æ®µåœ¨æ¥æ”¶ä¸Šæ¸¸æœåŠ¡è¿”å›çš„ Body æ•°æ®æ—¶æ‰§è¡Œï¼Œæ ¹æ®æ•°æ®å¤§å°åˆ’åˆ† chunksï¼Œæ­¤é˜¶æ®µä¼šè¢«æ‰§è¡Œå¤šæ¬¡ã€‚</p>
<p>åœ¨ Openresty çš„ç”Ÿå‘½å‘¨æœŸé‡Œï¼Œ<code>body_filter_by_lua</code> ä¸­ä½¿ç”¨ <code>ngx.arg[1]</code> è¯»å– chunkï¼Œä½¿ç”¨ <code>ngx.arg[2]</code> æ ‡è®° EOFã€‚</p>
<pre><code class=language-lua>  -- è·å–åˆ°äº†æ‰€æœ‰çš„ body
  if kong.ctx.core.response_body then
    arg[1] = kong.ctx.core.response_body
    arg[2] = true
  end

  if not arg[2] then
    return
  end

  -- è·å–åˆ°æ‰€æœ‰çš„ body å
  -- å†ç»Ÿè®¡æ‰§è¡Œæ—¶é—´
  ctx.KONG_BODY_FILTER_ENDED_AT = get_now_ms()
  ctx.KONG_BODY_FILTER_TIME = ctx.KONG_BODY_FILTER_ENDED_AT - ctx.KONG_BODY_FILTER_START

  if ctx.KONG_PROXIED then
    -- time spent receiving the response (header_filter + body_filter)
    -- we could use $upstream_response_time but we need to distinguish the waiting time
    -- from the receiving time in our logging plugins (especially ALF serializer).
    ctx.KONG_RECEIVE_TIME = ctx.KONG_BODY_FILTER_ENDED_AT - (ctx.KONG_HEADER_FILTER_START or
                                                             ctx.KONG_BALANCER_ENDED_AT or
                                                             ctx.KONG_BALANCER_START or
                                                             ctx.KONG_ACCESS_ENDED_AT)
</code></pre>
<h3 id=87-log_by_lua-é˜¶æ®µ>8.7. log_by_lua é˜¶æ®µ</h3>
<p>è°ƒç”¨ Lua çš„åƒåœ¾å›æ”¶å™¨ç»Ÿè®¡ Kong å ç”¨å†…å­˜æƒ…å†µï¼š</p>
<pre><code class=language-lua>local update_lua_mem
do
  local pid = ngx.worker.pid
  local kong_shm = ngx.shared.kong

  local Lua_MEM_SAMPLE_RATE = 10 -- seconds
  local last = ngx.time()

  local collectgarbage = collectgarbage

  update_lua_mem = function(force)
    local time = ngx.time()

    if force or time - last &gt;= Lua_MEM_SAMPLE_RATE then
      local count = collectgarbage(&quot;count&quot;)

      local ok, err = kong_shm:safe_set(&quot;kong:mem:&quot; .. pid(), count)
      if not ok then
        log(ERR, &quot;could not record Lua VM allocated memory: &quot;, err)
      end

      last = ngx.time()
    end
  end
end
</code></pre>
<p>æ ¹æ®å“åº”ç»“æœè°ƒç”¨è´Ÿè½½å‡è¡¡å™¨è°ƒæ•´ä¸Šæ¸¸èŠ‚ç‚¹çš„æƒé‡ï¼š</p>
<pre><code class=language-lua>      -- If response was produced by an upstream (ie, not by a Kong plugin)
      -- Report HTTP status for health checks
      local balancer_data = ctx.balancer_data
      if balancer_data and balancer_data.balancer_handle then
        local status = ngx.status
        if status == 504 then
          balancer_data.balancer.report_timeout(balancer_data.balancer_handle)
        else
          balancer_data.balancer.report_http_status(
            balancer_data.balancer_handle, status)
        end
        -- release the handle, so the balancer can update its statistics
        balancer_data.balancer_handle:release()
      end
</code></pre>
<h2 id=9-admin-api>9. Admin API</h2>
<p>Kong Admin API å…¥å£ï¼š</p>
<pre><code class=language-lua>function Kong.admin_content(options)
  local ctx = ngx.ctx
  if not ctx.workspace then
    ctx.workspace = kong.default_workspace
  end

  return serve_content(&quot;kong.api&quot;, options)
end
</code></pre>
<pre><code class=language-lua>local function serve_content(module, options)

  -- CORS è·¨åŸŸç›¸å…³
  header[&quot;Access-Control-Allow-Origin&quot;] = options.allow_origin or &quot;*&quot;

  -- å¯åŠ¨ lapis
  lapis.serve(module)
end
</code></pre>
<p>å…³äº <a href=https://leafo.net/lapis/>Lapis</a>ï¼š</p>
<blockquote>
<p>Lapis is a framework for building web applications using <a href=https://moonscript.org>MoonScript</a> or <a href=https://lua.org>Lua</a> that runs inside of a customized version of <a href=https://nginx.org>Nginx</a> called <a href=https://openresty.org>OpenResty</a>.</p>
</blockquote>
<pre><code class=language-lua># api/init.lua
-- åŠ è½½å›ºå®šè·¯ç”±
-- Load core routes
for _, v in ipairs({&quot;kong&quot;, &quot;health&quot;, &quot;cache&quot;, &quot;config&quot;, &quot;clustering&quot;}) do
  local routes = require(&quot;kong.api.routes.&quot; .. v)
  api_helpers.attach_routes(app, routes)
end

  local routes = {}

  -- DAO Routes
  for _, dao in pairs(singletons.db.daos) do
    if dao.schema.generate_admin_api ~= false and not dao.schema.legacy then
      routes = Endpoints.new(dao.schema, routes)
    end
  end
</code></pre>
<p>åˆå§‹åŒ–æ„å»ºè·¯ç”±ï¼š</p>
<pre><code class=language-lua># api/endpoints.lua
-- åˆ›å»ºåŸºç¡€è·¯ç”±
-- Generates admin api endpoint functions
--
-- Examples:
--
-- /routes
-- /routes/:routes
-- /routes/:routes/service
-- /services/:services/routes
--
-- and
--
-- /services
-- /services/:services
-- /services/:services/routes/:routes
local function generate_endpoints(schema, endpoints)
  -- list è·¯ç”±
  -- e.g. /routes
  generate_collection_endpoints(endpoints, schema)

  -- å•ä½“è·¯ç”±
  -- e.g. /routes/:routes
  generate_entity_endpoints(endpoints, schema)

  -- åˆ¤æ–­æ˜¯å¦æœ‰å…³è”å¯¹è±¡
  -- ä¾‹å¦‚ route å…³è” services
  for foreign_field_name, foreign_field in schema:each_field() do
    -- å¤–é”®
    if foreign_field.type == &quot;foreign&quot; and not foreign_field.schema.legacy then
      -- e.g. /routes/:routes/service
      generate_entity_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name, true)

      -- e.g. /services/:services/routes
      generate_collection_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name)

      -- e.g. /services/:services/routes/:routes
      generate_entity_endpoints(endpoints, foreign_field.schema, schema, foreign_field_name)
    end
  end

  return endpoints
end

-- Generates admin api collection endpoint functions
--
-- Examples:
--
-- /routes
-- /services/:services/routes
--
-- and
--
-- /services
local function generate_collection_endpoints(endpoints, schema, foreign_schema, foreign_field_name)
  local collection_path

  -- å¤–é”®å…³è”
  if foreign_schema then
    collection_path = fmt(&quot;/%s/:%s/%s&quot;, foreign_schema.admin_api_name or
                                        foreign_schema.name,
                                        foreign_schema.name,
                                        schema.admin_api_nested_name or
                                        schema.admin_api_name or
                                        schema.name)

  else
    -- æ²¡æœ‰å¤–é”®å…³è”
    collection_path = fmt(&quot;/%s&quot;, schema.admin_api_name or
                                 schema.name)
  end

  endpoints[collection_path] = {
    schema  = schema,
    methods = {
      --OPTIONS = method_not_allowed,
      --HEAD    = method_not_allowed,
      GET     = get_collection_endpoint(schema, foreign_schema, foreign_field_name),
      POST    = post_collection_endpoint(schema, foreign_schema, foreign_field_name),
      --PUT     = method_not_allowed,
      --PATCH   = method_not_allowed,
      --DELETE  = method_not_allowed,
    },
  }
end
</code></pre>
<p>åªå…³æ³¨ POST è¯·æ±‚å¤„ç†çš„éƒ¨åˆ†ï¼š</p>
<pre><code class=language-lua>local function post_collection_endpoint(schema, foreign_schema, foreign_field_name, method)
  return function(self, db, helpers, post_process)
    if foreign_schema then
      local foreign_entity, _, err_t = select_entity(self, db, foreign_schema)
      if err_t then
        return handle_error(err_t)
      end

      if not foreign_entity then
        return not_found()
      end

      self.args.post[foreign_field_name] = foreign_schema:extract_pk_values(foreign_entity)
    end

    -- å¤„ç†è¯·æ±‚ï¼Œå‚æ•°æ ¡éªŒï¼Œæ’å…¥æ•°æ®
    local entity, _, err_t = insert_entity(self, db, schema, method)
    if err_t then
      return handle_error(err_t)
    end

    -- å›è°ƒå‡½æ•°
    if post_process then
      entity, _, err_t = post_process(entity)
      if err_t then
        return handle_error(err_t)
      end
    end

    return created(entity)
  end
end
</code></pre>
<p>Admin API ä»…ä»…æ˜¯ä¸€å±‚ API å°è£…ï¼Œä¸è´Ÿè´£èƒŒåçš„äº‹ä»¶å¤„ç†å’Œæ•°æ®åŒæ­¥ï¼ŒèƒŒåçš„äº‹ä»¶å¤„ç†åœ¨æ–‡ç« äº‹ä»¶å¤„ç†éƒ¨åˆ†é˜è¿°è¿‡äº†ã€‚</p>
<h2 id=10-æ’ä»¶å¼€å‘>10. æ’ä»¶å¼€å‘</h2>
<p>ç®€å•ä»‹ç»ä¸€ä¸‹æ’ä»¶å¼€å‘èƒ½ç”¨ä¸Šçš„ä¸€äº›å° Trickã€‚</p>
<h3 id=101-å¤šå±‚-schema-åµŒå¥—>10.1. å¤šå±‚ Schema åµŒå¥—</h3>
<p>çœ‹ç€å¾ˆæ¶å¿ƒå§ï¼Œä½†è¿™æ˜¯å¤šå±‚ Schema åµŒå¥—çš„æ ·å­ã€‚</p>
<pre><code class=language-lua>local schema = {
    name = plugin_name,
    fields = {
        { consumer = typedefs.no_consumer },
        { protocols = typedefs.protocols_http },
        { config = {
          type = &quot;record&quot;,
          fields = { {
            rules = {
              type = &quot;array&quot;,
              elements = {
                type = &quot;record&quot;,
                fields = { {
                  match = {
                    type = &quot;array&quot;,
                    elements = {
                      type = &quot;record&quot;,
                      fields = {
                        { vars = { type = &quot;array&quot;, elements = {
                            type = &quot;array&quot;,
                            elements = { type = &quot;string&quot; }
                        } } }
                      }
                    }
                  }
                } }
              }
            }
          } },
        } }
    }
}
</code></pre>
<h3 id=102-è‡ªå®šä¹‰-schema-æ ¡éªŒå™¨>10.2. è‡ªå®šä¹‰ Schema æ ¡éªŒå™¨</h3>
<pre><code class=language-lua>local expr = require(&quot;resty.expr.v1&quot;)

local schema_validator = function(conf)
    if conf.rules then
        for _, rule in ipairs(conf.rules) do
            if rule.match and type(rule.match) == &quot;table&quot; then
                for _, m in pairs(rule.match) do
                    local ok, err = expr.new(m.vars)
                    if not ok then
                        return false, &quot;failed to validate the 'vars' expression: &quot; .. err
                    end
                end
            end
        end
    end

    return true
end
</code></pre>
<h3 id=103-æ—¥å¿—æ‰“å°-table>10.3. æ—¥å¿—æ‰“å° Table</h3>
<pre><code class=language-lua>kong.log.inspect.on()
kong.log.debug(&quot;Lua table: &quot;, t)
</code></pre>
<h3 id=104-è‡ªå®šä¹‰æ—¥å¿—è¾“å‡º>10.4. è‡ªå®šä¹‰æ—¥å¿—è¾“å‡º</h3>
<p>2.3.0 ç‰ˆæœ¬ä»¥ä¸Šå¯ç”¨ã€‚</p>
<pre><code class=language-lua>local entry = {
    entries = ctx.log_entries,
    id = self.transaction_id,
    action = action_name,
}

kong.log.set_serialize_value(&quot;waf&quot;, entry)
</code></pre>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p><a href=https://github.com/Kong/kong>ğŸ¦ The Cloud-Native API Gateway</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<div class=post-meta>
<time datetime=" 2021-09-21" itemprop=datePublished>Sep 21, 2021</time>
</div>
</footer>
</article>
<script src=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.min.js></script>
<aside class=typeface-sans lang=zh-hans>
<nav class=toc></nav>
</aside>
<script>tocbot.init({tocSelector:'.toc',contentSelector:'article',headingSelector:'h1, h2, h3, h4, h5',hasInnerContainers:!0,collapseDepth:"3",positionFixedSelector:".toc",headingsOffset:10})</script>
</div><script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/filter-highlight-all/prism-filter-highlight-all.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script>Prism.plugins.filterHighlightAll.add(function(a){return a.language!=="mermaid"})</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.init({startOnLoad:!0},"pre code.language-mermaid",function(){const a=document.querySelectorAll('code.language-mermaid');for(const c of a){c.style.backgroundColor='initial';const b=c.parentNode;b.style.border='none',b.style.textAlign='center',window.darkmode&&!window.darkmode.isActivated()&&(b.style.backgroundColor='initial')}})</script>
</div>
</main><footer class=site-footer>
<div class=wrapper>
<div class=social-links>
<a class="social-link social-github" href=https://github.com/mayocream><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5C9.34 21.58 9.5 21.27 9.5 21 9.5 20.77 9.5 20.14 9.5 19.31 6.73 19.91 6.14 17.97 6.14 17.97c-.46-1.16-1.11-1.47-1.11-1.47C4.12 15.88 5.1 15.9 5.1 15.9 6.1 15.97 6.63 16.93 6.63 16.93 7.5 18.45 8.97 18 9.54 17.76 9.63 17.11 9.89 16.67 10.17 16.42c-2.22-.25-4.55-1.11-4.55-4.92.0-1.11.38-2 1.03-2.71C6.55 8.54 6.2 7.5 6.75 6.15c0 0 .84-.27 2.75 1.02C10.29 6.95 11.15 6.84 12 6.84s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02C17.8 7.5 17.45 8.54 17.35 8.79 18 9.5 18.38 10.39 18.38 11.5c0 3.82-2.34 4.66-4.57 4.91C14.17 16.72 14.5 17.33 14.5 18.26c0 1.34.0 2.42.0 2.74.0.27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg>
</a>
<a class="social-link social-rss" href=/index.xml target=_blank><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M6.18 15.64a2.18 2.18.0 012.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18.0 012.18-2.18M4 4.44A15.56 15.56.0 0119.56 20H16.73A12.73 12.73.0 004 7.27V4.44M4 10.1A9.9 9.9.0 0113.9 20H11.07A7.07 7.07.0 004 12.93V10.1z"/></svg>
</a>
</div>
<div class=credits>
Theme KAGAMI by Kamikat
</div>
</div>
</footer><script>(function(a){for(var a=Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')),b=0,c;b!=a.length;b++)c=a[b],c.innerHTML=c.innerHTML.replace(/[\u2000-\u206eâ¸€-\u2e7eâº€-\u2efeâ¼€-\u2fdeâ¿°-\u2ffe\u3000-ã€¾\u3040-ã‚ã‚ -ãƒ¾\u3100-\u312e\u3130-ã†ã†-ã†ã† -\u31beã‡€-\u31eeã‡°-ã‡¾ãˆ€-ã‹¾ãŒ€-ã¾ã€-\u4dbeä¸€-\u9ffe\ua960-\ua97eê°€-\ud7ae\ud7b0-\ud7feï¤€-\ufafeï¸°-ï¹\uff00-ï¿®]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud82c[\udc00-\udcfe]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e]/g,function(a){return'<span class="baseline-fix-block">'+a+'<'+'/span>'}),c.classList.remove('baseline-fix')})(Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')))</script>
<script type=text/javascript>const resize=function(){this.width=.5*(this.naturalWidth||this.width)};Array.prototype.forEach.call(document.querySelectorAll('.half-size, .retina2x'),function(a){a.naturalWidth?resize.call(a):a.onload=resize})</script>
<script src=https://cdn.jsdelivr.net/npm/twemoji@13.1.0/dist/twemoji.min.js></script>
<script>twemoji.parse(document.body,{folder:'svg',ext:'.svg'})</script>
</body>