<!doctype html><html lang=zh-hans><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Dkron æºç åˆ†æ - Mayo's Blog</title>
<meta name=description content="æœ¬æ–‡äº 2021.05.21 å‘è¡¨äºæ•å¸å†…éƒ¨ï¼Œç°åšéƒ¨åˆ†ä¿®è®¢ä¸æ‰¹æ³¨å…¬å¼€å‘è¡¨ã€‚ Dkron æ˜¯åŸºäº Google ç™½çš®ä¹¦ç†è®ºç¼–å†™çš„åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿï¼Œå†…éƒ¨æŠ€æœ¯åˆ©ç”¨åˆ°äº† Serfï¼ˆGossipï¼‰è¿›">
<meta name=author content>
<link rel=preconnect href=https://cdn.jsdelivr.net>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Press+Start+2P" rel=stylesheet>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400&family=Noto+Sans+JP:wght@300;400&family=Noto+Sans+SC:wght@300;400&family=Noto+Serif:wght@300;400&family=Noto+Serif+JP:wght@300;400&family=Noto+Serif+SC:wght@300;400&family=Source+Code+Pro:wght@300;400" rel=stylesheet>
<link rel=stylesheet href="/bundle.css?v=1633052487" media=all>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.css>
<link rel=icon href=https://unavatar.io/twitter/Freeze_Mayo><meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://shoujo.ink/2021/09/dkron-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-JKVXF5HSKT','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="Dkron æºç åˆ†æ">
<meta property="og:description" content="æœ¬æ–‡äº 2021.05.21 å‘è¡¨äºæ•å¸å†…éƒ¨ï¼Œç°åšéƒ¨åˆ†ä¿®è®¢ä¸æ‰¹æ³¨å…¬å¼€å‘è¡¨ã€‚ Dkron æ˜¯åŸºäº Google ç™½çš®ä¹¦ç†è®ºç¼–å†™çš„åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿï¼Œå†…éƒ¨æŠ€æœ¯åˆ©ç”¨åˆ°äº† Serfï¼ˆGossipï¼‰è¿›">
<meta property="og:type" content="article">
<meta property="og:url" content="https://shoujo.ink/2021/09/dkron-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-23T02:16:00+08:00">
<meta property="article:modified_time" content="2021-09-23T02:16:00+08:00"><meta property="og:site_name" content="Mayo's Blog">
</head>
</html>
<body><script src=https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>const opts={bottom:'32px',right:'unset',left:'32px',time:'0.3s',mixColor:'#fff',backgroundColor:'#fff',buttonColorDark:'#100f2c',buttonColorLight:'#fff',saveInCookies:!0,label:'ğŸŒ“',autoMatchOsTheme:!0};let darkmode;window.matchMedia('only screen and (min-width: 680px)').matches?(darkmode=new Darkmode(opts),darkmode.showWidget()):(localStorage.removeItem('darkmode'),darkmode=new Darkmode(opts)),window.darkmode=darkmode,document.addEventListener('DOMContentLoaded',function(){document.body.style.opacity=1})</script>
<main class=page-content aria-label=Content>
<div class=wrapper><nav class=site-nav>
<a class=page-link href=/posts/>Posts</a>
<a class=page-link href=/about/>About</a>
</nav><header class=post-header>
<a class=site-title href=https://shoujo.ink>Mayo's Blog</a>
<h1 class="post-title baseline-fix typeface-sans" lang=zh-hans itemprop="name headline">Dkron æºç åˆ†æ</h1>
</header>
<div class=post-cover aria-label=Cover>
<div class=post-cover-wrapper>
<img src alt>
</div>
<div class=cover-meta></div>
</div>
<div class=post-layout>
<article class="post typeface-sans" lang=zh-hans itemscope itemtype=http://schema.org/BlogPosting>
<div class=post-content itemprop=articleBody>
<blockquote>
<p>æœ¬æ–‡äº 2021.05.21 å‘è¡¨äºæ•å¸å†…éƒ¨ï¼Œç°åšéƒ¨åˆ†ä¿®è®¢ä¸æ‰¹æ³¨å…¬å¼€å‘è¡¨ã€‚</p>
</blockquote>
<p><a href=https://github.com/distribworks/dkron>Dkron</a> æ˜¯åŸºäº Google ç™½çš®ä¹¦ç†è®ºç¼–å†™çš„åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿï¼Œå†…éƒ¨æŠ€æœ¯åˆ©ç”¨åˆ°äº† <a href=https://www.serf.io/>Serf</a>ï¼ˆGossipï¼‰è¿›è¡Œç—…æ¯’å¼æ¶ˆæ¯æ‰©æ•£ï¼Œ<a href=https://github.com/hashicorp/raft>Raft</a> è¿›è¡Œåˆ†å¸ƒå¼æ•°æ®å¼ºä¸€è‡´æ€§åŒæ­¥ï¼Œè®¾è®¡ä¸Šé‡‡ç”¨ Server / Agent æ¨¡å¼ï¼Œåªæœ‰ä¸€ä¸ªä¸­å¿ƒè°ƒåº¦ä¸»èŠ‚ç‚¹ï¼Œå…¶ä»–èŠ‚ç‚¹ä½œä¸ºå·¥ä½œèŠ‚ç‚¹ï¼Œé€šè¿‡ <a href=https://github.com/hashicorp/go-plugin>go-plugin</a> æ’ä»¶æœºåˆ¶å®šä¹‰å¤šç§ç±»å‹ã€å¯è‡ªç”±æ‰©å±•çš„ä»»åŠ¡å¤„ç†å™¨ï¼Œä½¿ç”¨ <a href=https://grpc.io/>GRPC</a> çš„åŒå‘æµä¼ è¾“è¿›è¡Œä»»åŠ¡åˆ†å‘ä¸çŠ¶æ€ä¸ŠæŠ¥ï¼ŒåŒæ—¶ä½¿ç”¨ <a href=https://pkg.go.dev/net/rpc>net/rpc</a> è¿›è¡Œè·¨è¿›ç¨‹è°ƒç”¨ï¼Œè¿˜ä½¿ç”¨é«˜æ€§èƒ½ KV å‚¨å­˜ <a href=https://github.com/tidwall/buntdb>buntdb</a> çš„ in-memory æ¨¡å¼ç¼“å­˜ä¸ç»“æ„åŒ–å‚¨å­˜ä»»åŠ¡å…ƒæ•°æ®ã€‚</p>
<p>Dkron å¯è°“æ˜¯ç«™åœ¨äº†å·¨äººçš„è‚©è†€ä¸Šï¼Œåˆ©ç”¨äº†è¯¸å¤šä¼˜ç§€å¼€æºç»„ä»¶ï¼Œæ±²å–äº†ä¼˜ç§€è®¾è®¡æ€æƒ³å®ç°çš„äº§å“ï¼ˆå®˜æ–¹è¿˜è¿è¥äº†å•†ä¸šç‰ˆæœ¬ï¼‰ã€‚</p>
<p>æˆ‘åœ¨å°†å…¶å¼•å…¥å…¬å¸è½åœ°é€”ä¸­ï¼Œå¯¹å…¶è¿›è¡Œäº†ä»£ç å®¡è®¡ï¼Œæœ¬æ–‡ä¾¿æ˜¯è½åœ°è¿‡ç¨‹ä¸­çš„äº§ç‰©ä¹‹ä¸€ï¼ˆå­¦ä¹ ç¬”è®°ï¼‰ã€‚ç”±äº Dkron æ¶‰åŠåˆ°çš„å¼€æºç»„ä»¶è¾ƒå¤šï¼Œå…‰æ˜¯ Goosip ä¸ Raft åè®®å°±å¤Ÿå¤æ‚äº†ï¼Œæˆ‘æŠ±ç€å­¦ä¹ çš„å¿ƒæ€è¿›è¡Œå·¥ä½œï¼Œé€æ¸å¯¹è¿™äº›å¼€æºç»„ä»¶æœ‰äº†è®¤çŸ¥ï¼Œé˜…è¯»ä»£ç ä¹ŸçŸ¥é“å…·ä½“çš„ç”¨æ³•æ˜¯ä»€ä¹ˆæ ·å­ï¼Œæœ‰ä¸€å®šçš„æ”¶è·ã€‚</p>
<p>æœ¬æ–‡åŸºäº 2021.05.19 <a href=https://github.com/distribworks/dkron>dkron</a> æœ€æ–° master åˆ†æ”¯ï¼ˆå¯¹åº” v3.1.6 ç‰ˆæœ¬ï¼‰ä»£ç é˜…è¯»ï¼Œ è¯¦ç»†æºç ç¬”è®°äº <a href=https://github.com/mayocream/dkron>mayocream/dkron</a> review åˆ†æ”¯ã€‚</p>
<h2 id=1-æ¶æ„è®¾è®¡>1. æ¶æ„è®¾è®¡</h2>
<h3 id=11-æ¦‚è¿°>1.1. æ¦‚è¿°</h3>
<p>å¼•ç”¨ Dkron å®˜ç½‘çš„è¡¨è¿°ï¼š</p>
<blockquote>
<p>Dkron æ˜¯åˆ†å¸ƒå¼çš„ Cron æœåŠ¡ï¼Œä»¥ Golang ç¼–å†™ï¼Œå¹¶åˆ©ç”¨ Raft åè®®å’Œ Serf æä¾›å¯å®¹é”™æ€§ï¼Œå¯é æ€§å’Œå¯ä¼¸ç¼©æ€§ï¼ŒåŒæ—¶æ˜“äºä½¿ç”¨ä¸å®‰è£…ã€‚</p>
</blockquote>
<h3 id=12-è®¾è®¡æ€è·¯>1.2. è®¾è®¡æ€è·¯</h3>
<p>Dkron å‚è€ƒ Google çš„<a href="https://queue.acm.org/detail.cfm?id=2745840">åˆ†å¸ƒå¼ Cron ç³»ç»Ÿç™½çš®ä¹¦</a>ï¼Œå®ç°äº†ä¸ Google å†…éƒ¨ä»»åŠ¡ç³»ç»Ÿâ€œç›¸åŒâ€çš„åŠŸèƒ½ã€‚</p>
<h4 id=121-å¯é æ€§>1.2.1. å¯é æ€§</h4>
<blockquote>
<p>Running these jobs is facilitated by keeping a file containing timestamps of the last launch for all registered Cron jobs.</p>
</blockquote>
<p>Dkron çš„ Job æ•°æ®ç»“æ„åŒ…å«äº†ä»»åŠ¡æœ€åä¸€æ¬¡æ‰§è¡Œçš„æ—¶é—´æˆ³ï¼š</p>
<pre><code class=language-protobuf>message Job {
  ...
  // æœ€åä¸€æ¬¡æ‰§è¡ŒæˆåŠŸ/å¤±è´¥æ—¶é—´æˆ³
  NullableTime last_success = 25;
  NullableTime last_error = 26;
  // ä¸‹ä¸€æ¬¡æ‰§è¡Œæ—¶é—´æˆ³
  google.protobuf.Timestamp next = 23;
  ...
}
</code></pre>
<blockquote>
<p>To make matters more complicated, failure to launch is acceptable for some Cron jobs but not for others. A garbage collection Cron job scheduled to run every five minutes may be able to skip one launch, but a payroll job scheduled to run once a month probably should not.</p>
</blockquote>
<p>ä¸€äº›ä»»åŠ¡è®¾è®¡ä¸Šä¸æ˜¯å¹‚ç­‰çš„ï¼Œç®€å•åœ°é”™è¯¯é‡è¯•ä¼šå¯¼è‡´ä¸¥é‡çš„é—®é¢˜ï¼Œä»»åŠ¡æ‰€æœ‰è€…åº”æœ‰ä»»åŠ¡æ‰§è¡Œã€é‡è¯•ç­‰æ“ä½œçš„æ§åˆ¶æƒã€‚</p>
<p>Dkron èƒ½å¤Ÿè®©ç”¨æˆ·æ§åˆ¶ Job çš„æ‰§è¡Œã€é‡è¯•æ¬¡æ•°ï¼š</p>
<pre><code class=language-protobuf>message Job {
  ...
  // å¯ç”¨/ç¦ç”¨
  bool disabled = 11;
  // é”™è¯¯å°è¯•æ¬¡æ•°
  uint32 retries = 13;
  // æ˜¯å¦å…è®¸åŒæ—¶è°ƒåº¦
  string concurrency = 16;
  ...
}
</code></pre>
<h4 id=122-å¯ä¼¸ç¼©æ€§>1.2.2. å¯ä¼¸ç¼©æ€§</h4>
<blockquote>
<p>If you want to run a service, simply specify which data center it should run in and what it requires â€” the data center scheduling system (which itself should be reliable) takes care of figuring out which machine or machines to deploy it on, as well as handling machine deaths. Launching a job in a data center then effectively turns into sending one or more RPCs to the data center scheduler.</p>
</blockquote>
<p>å®šæ—¶ä»»åŠ¡åˆ†å¸ƒå¼åœ°è¿è¡Œï¼Œè®¾è®¡ä¸Šè¦èƒ½å¤Ÿé¿å…é›†ç¾¤ä¸­ä¸€å°æœºå™¨å®•æœºå½±å“ã€‚</p>
<p>Dkron åœ¨ä»»åŠ¡è°ƒåº¦å’Œé›†ç¾¤é€šä¿¡ä¸Šå®šä¹‰äº†â€œæ•°æ®ä¸­å¿ƒâ€ï¼Œæ‰€æœ‰çš„ Dkron å®ä¾‹å¯ä»¥é€šè¿‡ Gossip ç»„å»ºé›†ç¾¤ã€‚<em>ä½† Dkron ç›®å‰åªæ”¯æŒåŒä¸€æ•°æ®ä¸­å¿ƒä¸‹è¿›è¡Œä»»åŠ¡è°ƒåº¦ï¼Œä¸æ”¯æŒè·¨æ•°æ®ä¸­å¿ƒè°ƒåº¦ä»»åŠ¡ã€‚</em></p>
<p>Dkron ä»»åŠ¡è°ƒåº¦ç¨‹åºå’Œæ‰§è¡ŒèŠ‚ç‚¹é€šè¿‡ RPC é€šä¿¡ã€‚</p>
<h4 id=123-çŠ¶æ€å‚¨å­˜>1.2.3. çŠ¶æ€å‚¨å­˜</h4>
<blockquote>
<p>We have two options: store data externally in a generally available distributed storage, or store a small amount of state as part of the Cron service itself. When designing the distributed Cron, we opted for the second option.</p>
</blockquote>
<p>ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€åœ¨ Dkron è¢«è§†ä¸ºæ˜¯ä¸ Server ä¸€ä½“çš„ï¼ŒDkron é€šè¿‡ Raft FSM åœ¨è°ƒåº¦é›†ç¾¤ Server ä¹‹é—´åŒæ­¥ Job å’Œ Job æ‰§è¡Œå†å²çš„æ•°æ®ã€‚<em>ç¤¾åŒºç‰ˆæœ¬æ•°æ®å‚¨å­˜åœ¨å†…å­˜ KV (Buntdb) ä¸­ï¼ŒPro ç‰ˆæœ¬æ”¯æŒ etcd å‚¨å­˜ã€‚</em></p>
<p>æŒä¹…åŒ–æ•°æ®é€šè¿‡ Raft Snapshot å®ç°ã€‚</p>
<h4 id=124-ä»»åŠ¡è°ƒåº¦>1.2.4. ä»»åŠ¡è°ƒåº¦</h4>
<h5 id=é›†ç¾¤>é›†ç¾¤</h5>
<p>
<figure class=image>
<img src=/2021/09/dkron-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/image-20210521145533658.png alt loading=lazy>
</figure></p>
<p>Dkron ä¸­æœåŠ¡å™¨èŠ‚ç‚¹åˆ†ä¸º Server / Agentï¼ŒServer é›†ç¾¤è´Ÿè´£ Job çš„æ•°æ®å­˜å‚¨ï¼ŒServer ä¸­é€‰ä¸¾å‡ºçš„ Leader è´Ÿè´£ä»»åŠ¡è°ƒåº¦ã€‚<em>Server åŒæ—¶ä¹Ÿæ˜¯ Agentï¼Œå¯ä»¥æ‰§è¡Œ Jobã€‚</em></p>
<p>Dkron é€šè¿‡ Gossip ç»„å»ºé›†ç¾¤ï¼Œé€šè¿‡ Raft é€‰ä¸¾ Leaderï¼ŒLeader æ‹…å½“ Schedulerï¼Œé€šè¿‡ GRPC ä¸‹å‘ Job åˆ° Gossip é›†ç¾¤çš„ Peers èŠ‚ç‚¹æ‰§è¡Œã€‚å½“ Leader èŠ‚ç‚¹å®•æœºï¼Œä¼šåœ¨ Server é›†ç¾¤ä¸­é€‰ä¸¾å‡ºæ–°çš„ Leaderã€‚</p>
<h5 id=ä»»åŠ¡æ‰§è¡Œ>ä»»åŠ¡æ‰§è¡Œ</h5>
<p>
<figure class=image>
<img src=/2021/09/dkron-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/image-20210521150603300.png alt loading=lazy>
</figure></p>
<p>Dkron Job æ‰§è¡Œä¸­ Agent ä¸ Server GRPC åŒå‘æµé€šä¿¡ï¼ŒAgent æŒç»­å‘é€ä»»åŠ¡æ‰§è¡Œæƒ…å†µï¼ŒServer è®°å½•ä»»åŠ¡å¼€å§‹å’Œä»»åŠ¡ç»“æŸæ—¶çš„æ‰§è¡ŒçŠ¶æ€ï¼Œé€šè¿‡ Raft Apply åŒæ­¥åˆ° Server é›†ç¾¤ã€‚</p>
<h2 id=2-æºç åˆ†æ>2. æºç åˆ†æ</h2>
<h3 id=21-åŸºæœ¬æ¦‚è¿°>2.1. åŸºæœ¬æ¦‚è¿°</h3>
<h4 id=211-ä¸»è¦æœºåˆ¶>2.1.1. ä¸»è¦æœºåˆ¶</h4>
<p>
<figure class=image>
<img src=/2021/09/dkron-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/image-20210521151256884.png alt loading=lazy>
</figure></p>
<p>Dkron ä¸»è¦åŸºäºä¸‰å¤§æœºåˆ¶å®ç°åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦ï¼š</p>
<ol>
<li>é€šè¿‡ Gossip åº“ Serf å®ç°èŠ‚ç‚¹å‘ç°ã€é›†ç¾¤ç»„å»ºï¼Œç›‘å¬ Gossip Member å˜åŒ–äº‹ä»¶ï¼Œå‘ç° Server/Agent çš„ Peer é€šä¿¡åœ°å€åŠæ´»è·ƒçŠ¶æ€ï¼›</li>
<li>é€šè¿‡ Raft å®ç° Server é›†ç¾¤ Leader é€‰ä¸¾ï¼Œå®ç° FSM æ¥å£ï¼Œé€šè¿‡ Raft Log å®ç° Server é›†ç¾¤æ•°æ®åŒæ­¥ã€æ•°æ®å¿«ç…§ã€æ•°æ®æœ€ç»ˆä¸€è‡´æ€§ï¼›</li>
<li>åˆ©ç”¨ go-plugin å®ç°æ’ä»¶æœºåˆ¶ï¼ŒåŸºäº GRPC é€šä¿¡ Agent å®æ—¶è¿”å›ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€ã€‚</li>
</ol>
<h4 id=212-ç›®å½•ç»“æ„>2.1.2. ç›®å½•ç»“æ„</h4>
<pre><code class=language-bash>$ tree -A -L 1
.
# è‡ªå¸¦çš„æ’ä»¶ /Processor çš„ main åŒ…
â”œâ”€â”€ builtin
# CLI
â”œâ”€â”€ cmd
# ä¸»è¦åŠŸèƒ½å®ç°
â”œâ”€â”€ dkron
â”œâ”€â”€ Dockerfile
# å°è£… cron
â”œâ”€â”€ extcron
â”œâ”€â”€ go.mod
â”œâ”€â”€ main.go
# ç”Ÿæˆçš„ pb.go ä»¥åŠé€šä¿¡é€»è¾‘
â”œâ”€â”€ plugin
# å®šä¹‰ Job ä»¥åŠé€šä¿¡åè®®
â”œâ”€â”€ proto
</code></pre>
<h3 id=22-ç»„å»ºé›†ç¾¤>2.2. ç»„å»ºé›†ç¾¤</h3>
<h4 id=221-èŠ‚ç‚¹å‘ç°>2.2.1. èŠ‚ç‚¹å‘ç°</h4>
<p>Dkron ä½¿ç”¨ <a href=hashicorp/go-discover>hashicorp/go-discover</a> è¿›è¡ŒèŠ‚ç‚¹ IP çš„è‡ªåŠ¨å‘ç°ï¼Œæ–¹ä¾¿é€šè¿‡äº‘å‚å•†æ¥å£ã€K8s è¿›è¡Œåˆå§‹åŒ–æœåŠ¡å‘ç°ã€‚<em>ç”¨äºå‘ç° Peer èŠ‚ç‚¹ï¼Œè¿›è¡Œ Bootstrap æˆ–è€… Join é›†ç¾¤ã€‚</em></p>
<pre><code class=language-go>// dkron/retry_join.go
func (r *retryJoiner) retryJoin(logger *logrus.Entry) error {
    ...
	// ä½¿ç”¨ go-discovery å‘é€šè¿‡ä¸åŒçš„åŸºç¡€è®¾æ–½è‡ªåŠ¨å‘ç° IP
	// Copy the default providers, and then add the non-default
	providers := make(map[string]discover.Provider)
	for k, v := range discover.Providers {
		providers[k] = v
	}

	// å°è¯• In-Cluster æ–¹å¼ä» &quot;/var/run/secrets/kubernetes.io/serviceaccount&quot;
	//	è·å– kubeconfig
	//	ref: https://github.com/kubernetes/client-go/tree/master/examples/in-cluster-client-configuration
	//	è·å– PodIP åˆ—è¡¨
	providers[&quot;k8s&quot;] = &amp;discoverk8s.Provider{}

	disco, err := discover.New(
		discover.WithUserAgent(UserAgent()),
		discover.WithProviders(providers),
	)
	if err != nil {
		return err
	}

	attempt := 0
	for {
		var addrs []string
		var err error

		for _, addr := range r.addrs {
			switch {
				// ä½¿ç”¨ go-discovery å‘ç° IP
			case strings.Contains(addr, &quot;provider=&quot;):
				servers, err := disco.Addrs(addr, log.New(logger.Logger.Writer(), &quot;&quot;, log.LstdFlags|log.Lshortfile))
				if err != nil {
                    ...
				} else {
					addrs = append(addrs, servers...)
				}

			default:
				ipAddr, err := ParseSingleIPTemplate(addr)
				if err != nil {
					logger.WithField(&quot;addr&quot;, addr).WithError(err).Error(&quot;agent: Error parsing retry-join ip template&quot;)
					continue
				}
				addrs = append(addrs, ipAddr)
			}
		}

		if len(addrs) &gt; 0 {
			// Serf åŠ å…¥é›†ç¾¤
			n, err := r.join(addrs)
			if err == nil {
				logger.Infof(&quot;agent: Join %s completed. Synced with %d initial agents&quot;, r.cluster, n)
				return nil
			}
		}

		attempt++
	}
}
</code></pre>
<p>åœ¨ K8s éƒ¨ç½²æ–¹å¼ä¸­ç¨‹åºé€šè¿‡åˆ›å»º go-clientï¼Œè¯·æ±‚ K8s API Server ç­›é€‰è·å–ä¸€æ‰¹ Dkron çš„ Pod IPã€‚</p>
<h4 id=222-gossip-é›†ç¾¤>2.2.2. Gossip é›†ç¾¤</h4>
<p>Dkron ä½¿ç”¨ <a href=https://github.com/hashicorp/serf>hashicorp/serf</a> åº“ï¼ˆGossip å°è£…ï¼‰çš„ Member äº‹ä»¶ Handlerï¼Œç›‘å¬é›†ç¾¤æˆå‘˜å˜åŒ–äº‹ä»¶ï¼Œè¿›è¡Œé›†ç¾¤ Peers çš„ç®¡ç†ã€‚</p>
<p>é»˜è®¤ä½¿ç”¨ <code>8946</code> ç«¯å£è¿›è¡Œ Gossip é›†ç¾¤çš„ Peers é€šä¿¡ã€‚</p>
<pre><code class=language-go>// dkron/agent.go
// setupSerf is used to create the agent we use
func (a *Agent) setupSerf() (*serf.Serf, error) {
    ...
	serfConfig := serf.DefaultConfig()
	serfConfig.Init()

	// metadata
	serfConfig.Tags = a.config.Tags
	serfConfig.Tags[&quot;role&quot;] = &quot;dkron&quot;
	// é»˜è®¤ &quot;dc1&quot;
	serfConfig.Tags[&quot;dc&quot;] = a.config.Datacenter
	// é»˜è®¤ &quot;global&quot;
	serfConfig.Tags[&quot;region&quot;] = a.config.Region
	serfConfig.Tags[&quot;version&quot;] = Version
	if a.config.Server {
		serfConfig.Tags[&quot;server&quot;] = strconv.FormatBool(a.config.Server)
	}
	if a.config.Bootstrap {
		serfConfig.Tags[&quot;bootstrap&quot;] = &quot;1&quot;
	}
	if a.config.BootstrapExpect != 0 {
		serfConfig.Tags[&quot;expect&quot;] = fmt.Sprintf(&quot;%d&quot;, a.config.BootstrapExpect)
	}

	// gossip é»˜è®¤è¿æ¥ç¯å¢ƒ/è¿æ¥å‚æ•°
	switch config.Profile {
	case &quot;lan&quot;:
		serfConfig.MemberlistConfig = memberlist.DefaultLANConfig()
	case &quot;wan&quot;:
		serfConfig.MemberlistConfig = memberlist.DefaultWANConfig()
	case &quot;local&quot;:
		serfConfig.MemberlistConfig = memberlist.DefaultLocalConfig()
	default:
		return nil, fmt.Errorf(&quot;unknown profile: %s&quot;, config.Profile)
	}

	serfConfig.MemberlistConfig.BindAddr = bindIP
	serfConfig.MemberlistConfig.BindPort = bindPort
	serfConfig.MemberlistConfig.AdvertiseAddr = advertiseIP
	serfConfig.MemberlistConfig.AdvertisePort = advertisePort
	serfConfig.MemberlistConfig.SecretKey = encryptKey
	serfConfig.NodeName = config.NodeName
	serfConfig.Tags = config.Tags

	if err != nil {
		a.logger.Fatal(err)
	}

	// Create a channel to listen for events from Serf
	a.eventCh = make(chan serf.Event, 2048)
	serfConfig.EventCh = a.eventCh

	// Start Serf
	a.logger.Info(&quot;agent: Dkron agent starting&quot;)

	// Create serf first
	return serf.Create(serfConfig)
}
</code></pre>
<p><a href=https://github.com/hashicorp/memberlist>hashicorp/memberlist</a> æä¾›ä¸‰ä¸ªé»˜è®¤é…ç½®ï¼Œå±€åŸŸç½‘ç»œçš„é…ç½® DefaultLANConfigã€å¤–ç½‘ DefaultWANConfigã€æœ¬åœ° DefaultLocalConfigï¼Œåä¸¤è€…éƒ½æ˜¯åœ¨ DefaultLANConfig åŸºç¡€ä¸Šä¿®æ”¹ï¼ŒåŒºåˆ«æ˜¯æ ¹æ®ç½‘é€Ÿï¼Œè°ƒæ•´äº†Gossip intervalã€TCP è¶…æ—¶æ—¶é—´ç­‰ã€‚</p>
<pre><code class=language-go>// dkron/retry_join.go
func (r *retryJoiner) retryJoin(logger *logrus.Entry) error {
	...
		if len(addrs) &gt; 0 {
			// Serf åŠ å…¥é›†ç¾¤
			n, err := r.join(addrs)
			if err == nil {
				logger.Infof(&quot;agent: Join %s completed. Synced with %d initial agents&quot;, r.cluster, n)
				return nil
			}
		}

		attempt++
		time.Sleep(r.interval)
	...
}

</code></pre>
<p>ç¨‹åºå¯åŠ¨ååå¤å°è¯•åŠ å…¥ Gossip é›†ç¾¤ã€‚</p>
<h4 id=223-ç«¯å£å¤ç”¨>2.2.3. ç«¯å£å¤ç”¨</h4>
<p>Dkron é»˜è®¤ä½¿ç”¨ <code>6868</code> ç«¯å£ä½œä¸º Dkron çš„ Peers RPC é€šä¿¡ç«¯å£ã€‚</p>
<p>é»˜è®¤ä¼šæŒ‚è½½ GRPC Server ç”¨äºæœåŠ¡è°ƒç”¨ã€‚åœ¨èŠ‚ç‚¹ä¸º Server æ—¶åŒæ—¶å¼€å¯ Raft åè®®ï¼Œå¤ç”¨ç«¯å£ã€‚</p>
<pre><code class=language-go>// StartServer launch a new dkron server process
// å¯åŠ¨ Server
func (a *Agent) StartServer() {
    ...
	// åˆ›å»ºç«¯å£å¤ç”¨ cmux
	// Create a cmux object.
	tcpm := cmux.New(a.listener)
	var grpcl, raftl net.Listener

	// If TLS config present listen to TLS
	if a.TLSConfig != nil {
		...
        // é»˜è®¤ä¸å¯ç”¨ TLS
	} else {
		// å®ç° raft.StreamLayer
		a.raftLayer = NewRaftLayer(a.logger)

		// cmux match grpc é€šä¿¡
		grpcl = tcpm.MatchWithWriters(cmux.HTTP2MatchHeaderFieldSendSettings(&quot;content-type&quot;, &quot;application/grpc&quot;))

		// raft TCP é€šä¿¡
		raftl = tcpm.Match(cmux.Any())
	}

	// åˆ›å»º GRPC Server
	if a.GRPCServer == nil {
		a.GRPCServer = NewGRPCServer(a, a.logger)
	}

	// å¯åŠ¨ GRPC Server
	if err := a.GRPCServer.Serve(grpcl); err != nil {
		a.logger.WithError(err).Fatal(&quot;agent: RPC server failed to start&quot;)
	}

	// ç»‘å®š net Listener
	if err := a.raftLayer.Open(raftl); err != nil {
		a.logger.Fatal(err)
	}

	// å¯åŠ¨ Raft
	if err := a.setupRaft(); err != nil {
		a.logger.WithError(err).Fatal(&quot;agent: Raft layer failed to start&quot;)
	}

	// Start serving everything
	go func() {
		// æ­£å¼å¼€å§‹ listen
		if err := tcpm.Serve(); err != nil {
			a.logger.Fatal(err)
		}
	}()
   ...
}
</code></pre>
<p>ä½¿ç”¨ <a href=https://github.com/soheilhy/cmux>soheilhy/cmux</a> åŒ…è¿›è¡Œç«¯å£å¤ç”¨ï¼Œè¯»å–å­—èŠ‚æµå‰ N å­—èŠ‚ï¼ˆMatch è§„åˆ™ï¼‰åŒ¹é… HTTP/2 GRPC è¯·æ±‚ã€‚</p>
<h3 id=23-raft-åè®®>2.3. Raft åè®®</h3>
<p>Dkron ä½¿ç”¨çš„æ˜¯ <a href=https://github.com/hashicorp/raft>hashicorp/raft</a> å®ç°çš„ Raft åè®®ã€‚</p>
<h4 id=231-é›†ç¾¤åˆå§‹åŒ–>2.3.1. é›†ç¾¤åˆå§‹åŒ–</h4>
<h5 id=åˆ›å»º-raft>åˆ›å»º Raft</h5>
<p>Dkron å¯ä»¥æŒ‡å®šä¸€å°èŠ‚ç‚¹ Bootstrapï¼Œä¹Ÿå¯ä»¥è®¾ç½® <code>bootstrap-expect</code> ç­‰å¾…é›†ç¾¤ Peers æ•°é‡è¾¾åˆ°æŒ‡å®šä¸ªæ•°ï¼Œå†è¿›è¡Œ Raft é›†ç¾¤ Bootstrapã€‚</p>
<pre><code class=language-go>// åˆå§‹åŒ– Raft
func (a *Agent) setupRaft() error {
	if a.config.BootstrapExpect &gt; 0 {
		if a.config.BootstrapExpect == 1 {
			// è¿›è¡Œ bootstrap
			a.config.Bootstrap = true
		}
	}

	// åˆ›å»º raft transport
	// ï¼ˆRaft èŠ‚ç‚¹é—´çš„é€šä¿¡é€šé“ï¼‰ï¼ŒèŠ‚ç‚¹ä¹‹é—´éœ€è¦é€šè¿‡è¿™ä¸ªé€šé“æ¥è¿›è¡Œæ—¥å¿—åŒæ­¥ã€é¢†å¯¼è€…é€‰ä¸¾ç­‰ç­‰
	// æ–¹æ³•å†…éƒ¨å¯åŠ¨åç¨‹ listen listener
	transport := raft.NewNetworkTransport(a.raftLayer, 3, raftTimeout, logger)
	a.raftTransport = transport

	config := raft.DefaultConfig()

	// Raft performance
	// é»˜è®¤å€¼ä¸º 1
	raftMultiplier := a.config.RaftMultiplier
	if raftMultiplier &lt; 1 || raftMultiplier &gt; 10 {
		return fmt.Errorf(&quot;raft-multiplier cannot be %d. Must be between 1 and 10&quot;, raftMultiplier)
	}
	config.HeartbeatTimeout = config.HeartbeatTimeout * time.Duration(raftMultiplier)
	config.ElectionTimeout = config.ElectionTimeout * time.Duration(raftMultiplier)
	config.LeaderLeaseTimeout = config.LeaderLeaseTimeout * time.Duration(a.config.RaftMultiplier)

	config.LogOutput = logger
	config.LocalID = raft.ServerID(a.config.NodeName)

	// Build an all in-memory setup for dev mode, otherwise prepare a full
	// disk-based setup.
	var logStore raft.LogStore
	var stableStore raft.StableStore
	var snapshots raft.SnapshotStore
	if a.config.DevMode {
		...
	} else {
		var err error

		// ï¼ˆå¿«ç…§å­˜å‚¨ï¼Œç”¨æ¥å­˜å‚¨èŠ‚ç‚¹çš„å¿«ç…§ä¿¡æ¯ï¼‰ï¼Œä¹Ÿå°±æ˜¯å‹ç¼©åçš„æ—¥å¿—æ•°æ®
		snapshots, err = raft.NewFileSnapshotStore(filepath.Join(a.config.DataDir, &quot;raft&quot;), 3, logger)

		// Create the BoltDB backend
		s, err := raftboltdb.NewBoltStore(filepath.Join(a.config.DataDir, &quot;raft&quot;, &quot;raft.db&quot;))

		a.raftStore = s
		// ï¼ˆç¨³å®šå­˜å‚¨ï¼Œç”¨æ¥å­˜å‚¨ Raft é›†ç¾¤çš„èŠ‚ç‚¹ä¿¡æ¯ç­‰ï¼‰ï¼Œæ¯”å¦‚ï¼Œå½“å‰ä»»æœŸç¼–å·ã€æœ€æ–°æŠ•ç¥¨æ—¶çš„ä»»æœŸç¼–å·ç­‰
		stableStore = s

		// 512 size å†…å­˜ç¼“å­˜
		cacheStore, err := raft.NewLogCache(raftLogCacheSize, s)
		if err != nil {
			s.Close()
			return err
		}
		// ç”¨æ¥å­˜å‚¨ Raft çš„æ—¥å¿—
		logStore = cacheStore
        ...
	}

    ...
	//	å‚æ•°: å®ç°äº† Storage çš„ DB, é»˜è®¤ nil, logger 
	// åˆ›å»ºå®ç° raft FSM æ¥å£
	// raft åªæ˜¯å®šä¹‰äº†ä¸€ä¸ªæ¥å£ï¼Œæœ€ç»ˆäº¤ç»™åº”ç”¨å±‚å®ç°ã€‚åº”ç”¨å±‚æ”¶åˆ° Log åæŒ‰ ä¸šåŠ¡éœ€æ±‚ è¿˜åŸä¸º åº”ç”¨æ•°æ®ä¿å­˜èµ·æ¥
	//	Raft å¯åŠ¨æ—¶ ä¾¿ Raft.runFSM èµ·ä¸€ä¸ªgoroutine ä» fsmMutateCh channel æ¶ˆè´¹log ==&gt; FSM.Apply
	fsm := newFSM(a.Store, a.ProAppliers, a.logger)
	// åˆ›å»º raft èŠ‚ç‚¹
	rft, err := raft.NewRaft(config, fsm, logStore, stableStore, snapshots, transport)
	if err != nil {
		return fmt.Errorf(&quot;new raft: %s&quot;, err)
	}
	// é€‰ä¸¾ leader ä¿¡å· chan
	a.leaderCh = rft.LeaderCh()
	a.raft = rft

	return nil
}
</code></pre>
<p>é»˜è®¤ä½¿ç”¨ <code>/dkron/raft</code> ç›®å½•å‚¨å­˜ Raft Log å’Œå¿«ç…§ã€‚ä½¿ç”¨ <a href=https://github.com/hashicorp/raft-boltdb>hashicorp/raft-boltdb</a> ä½œä¸º Raft Log å’Œ stable å‚¨å­˜ï¼Œå¿«ç…§ä½¿ç”¨æ–‡ä»¶å‚¨å­˜ã€‚</p>
<blockquote>
<p>çº¿ä¸Šä½¿ç”¨æƒ…å†µï¼šServer è¿è¡Œ 7 å¤©æ¯ 30s æ‰§è¡Œ 5 ä¸ª Job ï¼Œ<code>raft.db</code> å¤§å°ä¸º 25Mï¼Œå†…å­˜å ç”¨åœ¨ 200M å·¦å³ã€‚</p>
</blockquote>
<p>æ•°æ®é‡ä¸å¤§åº”è¯¥ä¸ç”¨è€ƒè™‘å¤§é‡ç£ç›˜å’Œå†…å­˜å ç”¨ã€‚</p>
<h5 id=åˆ›å»ºé›†ç¾¤>åˆ›å»ºé›†ç¾¤</h5>
<p>å¦‚æœæ˜¯åˆå§‹åŒ–é›†ç¾¤ï¼ŒæŒ‡å®š <code>bootstrap-expect</code> å‚æ•°ï¼Œåˆ™ä¼šç›‘å¬ Gossip é›†ç¾¤æˆå‘˜å˜åŒ–ï¼Œç­‰å¾… Peers æ•°é‡è¾¾åˆ°é¢„æœŸæ—¶ï¼Œè¿›è¡Œ Raft çš„ Bootstrap æ“ä½œã€‚</p>
<p>å¦‚æœå·²å­˜åœ¨ Raft é›†ç¾¤ï¼Œåˆ™æ–°çš„ Server åŠ å…¥ Raft é›†ç¾¤çš„æˆå‘˜ä¸­ã€‚</p>
<pre><code class=language-go>// dkron/agent.go
// å¤„ç† Serf äº‹ä»¶
func (a *Agent) eventLoop() {
    // åªè¯»çš„ Shutdown channel
	serfShutdownCh := a.serf.ShutdownCh()
	for {
		select {
			// Serf event äº‹ä»¶å¤„ç†
		case e := &lt;-a.eventCh:
			// æœ‰ä¸‰ç§äº‹ä»¶ MemberEvent/UserEvent/Query
			// è¿™é‡Œåªå¤„ç† MemberEvent, åªä½¿ç”¨ Serf åšé›†ç¾¤ member çš„ç®¡ç†
			// å®é™…è¿è¡Œæ—¶ä¸»è¦çš„ MemberEvent äº‹ä»¶æœ‰ update/failed/join
			// æ²¡æœ‰ä½¿ç”¨åˆ°è‡ªå®šä¹‰ event ä»¥åŠ query å‘½ä»¤

			// Log all member events
			if me, ok := e.(serf.MemberEvent); ok {
				for _, member := range me.Members {
					a.logger.WithFields(logrus.Fields{
						&quot;node&quot;:   a.config.NodeName,
						&quot;member&quot;: member.Name,
						&quot;event&quot;:  e.EventType(),
					}).Debug(&quot;agent: Member event&quot;)
				}

				// serfEventHandler is used to handle events from the serf cluster
				switch e.EventType() {
				case serf.EventMemberJoin:
					a.nodeJoin(me)
					a.localMemberEvent(me)
				case serf.EventMemberLeave, serf.EventMemberFailed:
					a.nodeFailed(me)
					a.localMemberEvent(me)
				case serf.EventMemberReap:
					a.localMemberEvent(me)
				case serf.EventMemberUpdate, serf.EventUser, serf.EventQuery: // Ignore
				default:
					a.logger.WithField(&quot;event&quot;, e.String()).Warn(&quot;agent: Unhandled serf event&quot;)
				}
			}

		case &lt;-serfShutdownCh:
			a.logger.Warn(&quot;agent: Serf shutdown detected, quitting&quot;)
			return
		}
	}
}
</code></pre>
<p>Serf çš„äº‹ä»¶æœ‰ä¸‰ç§ç±»å‹ï¼šMemberEvent / UserEvent / Queryï¼ŒDkron åªå¤„ç† MemberEventï¼Œåªä½¿ç”¨ Serf åšé›†ç¾¤ Peers çš„ç®¡ç†ï¼Œæ²¡æœ‰ä½¿ç”¨åˆ°è‡ªå®šä¹‰ event ä»¥åŠ query å‘½ä»¤ã€‚å®é™…è¿è¡Œæ—¶ä¸»è¦çš„ MemberEvent äº‹ä»¶æœ‰ <code>member-update</code> / <code>member-failed</code> / <code>member-join</code> / <code>member-reap</code>ã€‚</p>
<pre><code class=language-go>// dkron/serf.go
// maybeBootstrap is used to handle bootstrapping when a new server joins
func (a *Agent) maybeBootstrap() {
	...
	// å­˜åœ¨ raft commit æ—¥å¿—, ä¸éœ€è¦ bootstrap
	if index != 0 {
		a.config.BootstrapExpect = 0
		return
	}

	// Scan for all the known servers
	members := a.serf.Members()
	var servers []ServerParts
	voters := 0
	for _, member := range members {
		valid, p := isServer(member)
		if !valid {
			// è·³è¿‡é dkron server çš„ member
			continue
		}
		if p.Region != a.config.Region {
			continue
		}
		...
		if valid {
			voters++
		}
		servers = append(servers, *p)
	}

	// Skip if we haven't met the minimum expect count
	if voters &lt; a.config.BootstrapExpect {
		return
	}

    ...
	for _, server := range servers {
		addr := server.Addr.String()
		addrs = append(addrs, addr)
		id := raft.ServerID(server.ID)
		suffrage := raft.Voter // å…è®¸ä»²è£çš„è§’è‰²
		peer := raft.Server{
			ID:       id,
			Address:  raft.ServerAddress(addr),
			Suffrage: suffrage,
		}
		configuration.Servers = append(configuration.Servers, peer)
	}

	// raft é›†ç¾¤åˆå§‹åŒ–
	future := a.raft.BootstrapCluster(configuration)
	if err := future.Error(); err != nil {
		a.logger.WithError(err).Error(&quot;agent: failed to bootstrap cluster&quot;)
	}

	// Bootstrapping complete, or failed for some reason, don't enter this again
	a.config.BootstrapExpect = 0
}
</code></pre>
<p>Raft é›†ç¾¤åˆå§‹åŒ–çš„æ¡ä»¶ï¼š</p>
<ol>
<li>æ²¡æœ‰ Commit æ—¥å¿—ï¼›</li>
<li>Server é›†ç¾¤è¾¾åˆ° expect çš„æ•°é‡ï¼›</li>
<li>å±äºåŒä¸€ region</li>
</ol>
<h5 id=åŠ å…¥èŠ‚ç‚¹>åŠ å…¥èŠ‚ç‚¹</h5>
<p>è‹¥ Raft é›†ç¾¤å·²å­˜åœ¨ï¼Œåˆ™ Leader èŠ‚ç‚¹æ¥æ”¶åˆ° Serf Member åŠ å…¥ Gossip é›†ç¾¤çš„äº‹ä»¶æ—¶ï¼Œè¿›è¡Œ Raft èŠ‚ç‚¹ Join çš„é€»è¾‘ï¼š</p>
<pre><code class=language-go>// dkron/serf.go
func (a *Agent) localMemberEvent(me serf.MemberEvent) {
	// åªæœ‰ Leader è¿›è¡Œæ“ä½œ
	if !a.config.Server || !a.IsLeader() {
		return
	}

	for _, m := range me.Members {
		select {
            // åŠ å…¥é‡æ–°åŒæ­¥çš„ chan
		case a.reconcileCh &lt;- m:
		default:
		}
	}
}

// reconcileCh è§¦å‘ reconcile æ‰§è¡Œ
func (a *Agent) reconcile() error {
	members := a.serf.Members()
	for _, member := range members {
		if err := a.reconcileMember(member); err != nil {
			return err
		}
	}
	return nil
}
</code></pre>
<pre><code class=language-go>// dkron/leader.go
func (a *Agent) reconcileMember(member serf.Member) error {
	// åˆ¤æ–­æ˜¯å¦åœ¨ä¸€ä¸ª region, æ˜¯å¦æ˜¯ Server
	valid, parts := isServer(member)
	if !valid || parts.Region != a.config.Region {
		return nil
	}

	var err error
	switch member.Status {
	case serf.StatusAlive:
		err = a.addRaftPeer(member, parts)
	case serf.StatusLeft:
		err = a.removeRaftPeer(member, parts)
	}
	if err != nil {
		return err
	}
	return nil
}
</code></pre>
<pre><code class=language-go>// dkron/leader.go
func (a *Agent) addRaftPeer(m serf.Member, parts *ServerParts) error {
   ...
	// è·å– raft peers
	for _, server := range configFuture.Configuration().Servers {

		// è¦åŠ å…¥çš„ server å·²å­˜åœ¨äº raft peers ä¸­, å…ˆç§»é™¤å†æ·»åŠ 
		if server.Address == raft.ServerAddress(addr) || server.ID == raft.ServerID(parts.ID) {
            ...
			future := a.raft.RemoveServer(server.ID, 0, 0)
			...
		}
	}

	// æ·»åŠ ä¸€ä¸ª raft peer
	switch {
	case minRaftProtocol &gt;= 3:
		addFuture := a.raft.AddVoter(raft.ServerID(parts.ID), raft.ServerAddress(addr), 0, 0)
		if err := addFuture.Error(); err != nil {
			a.logger.WithError(err).Error(&quot;dkron: failed to add raft peer&quot;)
			return err
		}
	}

	return nil
}
</code></pre>
<h4 id=232-fsm>2.3.2. FSM</h4>
<h5 id=å†…å­˜-db>å†…å­˜ DB</h5>
<p>Dkron ä½¿ç”¨å†…å­˜ KV <a href=https://github.com/tidwall/buntdb>tidwall/buntdb</a> å‚¨å­˜ Job åŠæ‰§è¡Œå†å²è®°å½•ã€‚</p>
<pre><code class=language-go>// dkron/storage.go
// Storage is the interface that should be used by any
// storage engine implemented for dkron. It contains the
// minumum set of operations that are needed to have a working
// dkron store.
type Storage interface {
	SetJob(job *Job, copyDependentJobs bool) error
	DeleteJob(name string) (*Job, error)
	SetExecution(execution *Execution) (string, error)
	SetExecutionDone(execution *Execution) (bool, error)
	GetJobs(options *JobOptions) ([]*Job, error)
	GetJob(name string, options *JobOptions) (*Job, error)
	GetExecutions(jobName string, opts *ExecutionOptions) ([]*Execution, error)
	GetExecutionGroup(execution *Execution, opts *ExecutionOptions) ([]*Execution, error)
	GetGroupedExecutions(jobName string, opts *ExecutionOptions) (map[int64][]*Execution, []int64, error)
	Shutdown() error
	Snapshot(w io.WriteCloser) error
	Restore(r io.ReadCloser) error
}
</code></pre>
<p><code>store</code> å®ç°äº† Storage æ¥å£ï¼Œä½¿ç”¨çš„æ˜¯ buntdbï¼š</p>
<pre><code class=language-go>// dkron/store.go
// NewStore creates a new Storage instance.
// åˆ›å»ºåŸºäºå†…å­˜çš„ buntdb
func NewStore(logger *logrus.Entry) (*Store, error) {
	db, err := buntdb.Open(&quot;:memory:&quot;)
	db.CreateIndex(&quot;name&quot;, jobsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;name&quot;))
	db.CreateIndex(&quot;started_at&quot;, executionsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;started_at&quot;))
	db.CreateIndex(&quot;finished_at&quot;, executionsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;finished_at&quot;))
	db.CreateIndex(&quot;attempt&quot;, executionsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;attempt&quot;))
	db.CreateIndex(&quot;displayname&quot;, jobsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;displayname&quot;))
	db.CreateIndex(&quot;schedule&quot;, jobsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;schedule&quot;))
	db.CreateIndex(&quot;success_count&quot;, jobsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;success_count&quot;))
	db.CreateIndex(&quot;error_count&quot;, jobsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;error_count&quot;))
	db.CreateIndex(&quot;last_success&quot;, jobsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;last_success&quot;))
	db.CreateIndex(&quot;last_error&quot;, jobsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;last_error&quot;))
	db.CreateIndex(&quot;next&quot;, jobsPrefix+&quot;:*&quot;, buntdb.IndexJSON(&quot;next&quot;))
	if err != nil {
		return nil, err
	}

	store := &amp;Store{
		db:     db,
		lock:   &amp;sync.Mutex{},
		logger: logger,
	}

	return store, nil
}
</code></pre>
<p>å®˜æ–¹çš„ Pro ç‰ˆæœ¬å®ç°çš„ etcd å‚¨å­˜ï¼Œå¯èƒ½æ˜¯å®ç°äº† Storage çš„å¦ä¸€ä¸ªå®ä¾‹ï¼Œæˆ–è€…æ˜¯åœ¨ Raft FSM è¿›è¡Œäº†é¢å¤–çš„å¤„ç†æ‰§è¡Œå¤–éƒ¨æ•°æ®åº“åŒæ­¥ã€‚</p>
<h5 id=å®ç°-fsm-æ¥å£>å®ç° FSM æ¥å£</h5>
<p>Raft FSM æ¥å£ï¼š</p>
<pre><code class=language-go>// FSM provides an interface that can be implemented by
// clients to make use of the replicated log.
type FSM interface {
	// Apply log is invoked once a log entry is committed.
	// It returns a value which will be made available in the
	// ApplyFuture returned by Raft.Apply method if that
	// method was called on the same Raft node as the FSM.
	Apply(*Log) interface{}

	// Snapshot is used to support log compaction. This call should
	// return an FSMSnapshot which can be used to save a point-in-time
	// snapshot of the FSM. Apply and Snapshot are not called in multiple
	// threads, but Apply will be called concurrently with Persist. This means
	// the FSM should be implemented in a fashion that allows for concurrent
	// updates while a snapshot is happening.
	Snapshot() (FSMSnapshot, error)

	// Restore is used to restore an FSM from a snapshot. It is not called
	// concurrently with any other command. The FSM must discard all previous
	// state.
	Restore(io.ReadCloser) error
}
</code></pre>
<p><code>Apply</code> å‡½æ•°ä¼šåœ¨ä» Log è½½å…¥ä¸€æ¡æ•°æ®çš„æ—¶å€™è¢«è°ƒç”¨ã€‚<em>Leader ä¼šè°ƒç”¨ Apply è¿›è¡Œæ•°æ®åŒæ­¥ã€‚</em></p>
<pre><code class=language-go>// dkron/fsm.go
type dkronFSM struct {
	store Storage

	// proAppliers holds the set of pro only LogAppliers
	proAppliers LogAppliers
	logger      *logrus.Entry
}

// åˆ›å»º/åŒæ­¥ä¸€æ¡ Log åˆ° state
func (d *dkronFSM) Apply(l *raft.Log) interface{} {
	buf := l.Data
	msgType := MessageType(buf[0])

	switch msgType {
	case SetJobType:
		return d.applySetJob(buf[1:])
	case DeleteJobType:
		return d.applyDeleteJob(buf[1:])
	case ExecutionDoneType:
		return d.applyExecutionDone(buf[1:])
	case SetExecutionType:
		return d.applySetExecution(buf[1:])
	}

	// Dkron Pro ç‰ˆæœ¬é¢å¤–çš„æ“ä½œ, å¯èƒ½åœ¨æ­¤å¤„æ‰§è¡Œå¤–éƒ¨æ•°æ®åº“åŒæ­¥
	if applier, ok := d.proAppliers[msgType]; ok {
		return applier(buf[1:], l.Index)
	}

	return nil
}
</code></pre>
<p>å®ç°çš„å¿«ç…§å’Œæ¢å¤æ–¹æ³•ï¼Œä½¿ç”¨ buntdb çš„ load/saveï¼š</p>
<pre><code class=language-go>// dkron/fsm.go
// FSM çš„å¿«ç…§å’Œæ¢å¤æ–¹æ³•ï¼Œä½¿ç”¨ buntdb çš„ load/save æ–¹æ³•ã€‚

// Snapshot returns a snapshot of the key-value store. We wrap
// the things we need in dkronSnapshot and then send that over to Persist.
// Persist encodes the needed data from dkronSnapshot and transport it to
// Restore where the necessary data is replicated into the finite state machine.
// This allows the consensus algorithm to truncate the replicated log.
func (d *dkronFSM) Snapshot() (raft.FSMSnapshot, error) {
	return &amp;dkronSnapshot{store: d.store}, nil
}

// Restore stores the key-value store to a previous state.
func (d *dkronFSM) Restore(r io.ReadCloser) error {
	defer r.Close()
	return d.store.Restore(r)
}

type dkronSnapshot struct {
	store Storage
}

func (d *dkronSnapshot) Persist(sink raft.SnapshotSink) error {
	if err := d.store.Snapshot(sink); err != nil {
		sink.Cancel()
		return err
	}

	// Close the sink.
	if err := sink.Close(); err != nil {
		return err
	}

	return nil
}

func (d *dkronSnapshot) Release() {}
</code></pre>
<h5 id=æ•°æ®æ ¼å¼>æ•°æ®æ ¼å¼</h5>
<p>é€šè¿‡ Raft Log (Bytes) å‚¨å­˜çš„æ•°æ®æ ¼å¼ä¸ºï¼š</p>
<pre><code class=language-go>// dkron/grpc.go
// Proto è½¬æ¢æˆ Bytes
func Encode(t MessageType, msg interface{}) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteByte(uint8(t))
	m, err := pb.Marshal(msg.(pb.Message))
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(m)
	return buf.Bytes(), err
}
</code></pre>
<p>é¦–ä¸ªå­—èŠ‚æ ‡è®° Message çš„ç±»å‹ï¼Œåç»­ä¸º Protobuf åºåˆ—åŒ–åçš„ç»“æœã€‚</p>
<h3 id=24-æ’ä»¶æœºåˆ¶>2.4. æ’ä»¶æœºåˆ¶</h3>
<h4 id=241-æ¦‚è¿°>2.4.1. æ¦‚è¿°</h4>
<p>æ’ä»¶æœºåˆ¶ä¼˜å…ˆäºä»»åŠ¡è°ƒåº¦æœ¬èº«è¿›è¡Œåˆ†æï¼Œå› ä¸ºä»»åŠ¡è°ƒåº¦ä¾èµ–äºæ’ä»¶çš„é€šä¿¡æœºåˆ¶ã€‚</p>
<p>Dkron æ’ä»¶ä½¿ç”¨ <a href=https://github.com/hashicorp/go-plugin>hashicorp/go-plugin</a> å®ç°ï¼Œç®€è€Œæ¦‚ä¹‹ï¼Œé€šè¿‡ä¸¤ç§ RPC æ–¹å¼ï¼ˆnetrpc / GRPCï¼‰å®¢æˆ·ç«¯ä¸æ’ä»¶ç›‘å¬çš„ç«¯å£è¿›è¡Œé€šä¿¡ï¼Œæ’ä»¶ä¸ä¸»ç¨‹åºåˆ†ç¦»ï¼Œä½œä¸ºæ’ä»¶æœºåˆ¶ã€‚</p>
<p>å¼•ç”¨ go-plugin é¡¹ç›®çš„è¯´æ˜ï¼š</p>
<blockquote>
<p>Shared libraries have one major advantage over our system which is much higher performance. In real world scenarios across our various tools, we&rsquo;ve never required any more performance out of our plugin system and it has seen very high throughput, so this isn&rsquo;t a concern for us at the moment.</p>
</blockquote>
<p>Golang å‡ºçš„åŸºäºé“¾æ¥åº“ï¼ˆ.soï¼‰çš„æ’ä»¶æœºåˆ¶è¿˜ä¸æˆç†Ÿï¼Œå¹¶ä¸” go-plugin å·²ç»åœ¨å¤§é‡è½¯ä»¶ä¸­è¿ç”¨å¤šå¹´ï¼Œå¯¹æ¯”èµ·æ¥å‰è€…æ²¡æœ‰ä¼˜åŠ¿ï¼Œgo-plugin çš„è€ƒé‡åœ¨äºæ€§èƒ½å¯¹äºæ’ä»¶æœºåˆ¶æ¥è¯´ä¸æ˜¯é¦–è¦çš„ã€‚</p>
<p>è¿™é‡Œè¯´ä¸€å¥ï¼Œå…¶ä»– Golang çš„ HTTP æœåŠ¡å™¨ä¾‹å¦‚ Traefikã€Caddy çš„æ’ä»¶æœºåˆ¶éƒ½æ˜¯éœ€è¦ä¿®æ”¹æºä»£ç ï¼Œè‡ªè¡Œå¢åŠ åŒ…å®ç° Golang Interfaceï¼Œé‡æ–°è¿›è¡Œç¼–è¯‘å®ç°çš„ï¼Œè¿™ç§ä¾µå…¥æ€§æ›´å¤§ï¼Œä½†æ˜¯æ€§èƒ½æ›´å¥½ã€‚</p>
<p>Golang å®˜æ–¹çš„æ’ä»¶æœºåˆ¶åˆ°ç›®å‰è¿˜ä¸æ”¯æŒ Windowsï¼Œé«˜æ€§èƒ½çš„ WASM Golang è¿è¡Œæ—¶åº“ï¼ˆç”¨ä½œ WASM æ’ä»¶æœºåˆ¶ï¼‰ <a href=https://github.com/wasmerio/wasmer-go>wasmerio/wasmer-go</a> ç›®å‰ä¹Ÿä¸æ”¯æŒ Windowsã€‚</p>
<h4 id=242-åŠ è½½æ’ä»¶>2.4.2. åŠ è½½æ’ä»¶</h4>
<p>Dkron é»˜è®¤ä¼šåœ¨ä¸€äº›ç›®å½•æŸ¥æ‰¾æ’ä»¶çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class=language-go>// cmd/plugins.go
func (p *Plugins) DiscoverPlugins() error {
	p.Processors = make(map[string]dkplugin.Processor)
	p.Executors = make(map[string]dkplugin.Executor)

	// Look in /etc/dkron/plugins
	// åŒ¹é…ç›®å½•ä¸‹çš„æ–‡ä»¶åˆ—è¡¨
	processors, err := plugin.Discover(&quot;dkron-processor-*&quot;, filepath.Join(&quot;/etc&quot;, &quot;dkron&quot;, &quot;plugins&quot;))
	if err != nil {
		return err
	}

	// Look in /etc/dkron/plugins
	executors, err := plugin.Discover(&quot;dkron-executor-*&quot;, filepath.Join(&quot;/etc&quot;, &quot;dkron&quot;, &quot;plugins&quot;))
	if err != nil {
		return err
	}

	exePath, err := osext.Executable()
	if err != nil {
		logrus.WithError(err).Error(&quot;Error loading exe directory&quot;)
	} else {
		// ä»å½“å‰ agent æ‰§è¡Œç›®å½•æŸ¥æ‰¾ï¼ŒåŒç›®å½•çš„å¯æ‰§è¡Œæ–‡ä»¶
		// é»˜è®¤æ‰§è¡Œç›®å½•ä¸º /opt/local/dkron/
		// è‹¥æˆ‘ä»¬éœ€è¦æ·»åŠ è‡ªå®šä¹‰æ’ä»¶, å°†ç¼–è¯‘åçš„äºŒè¿›åˆ¶æ–‡ä»¶æ”¾å…¥åŒç›®å½•å³å¯
		p, err := plugin.Discover(&quot;dkron-processor-*&quot;, filepath.Dir(exePath))
		if err != nil {
			return err
		}
		processors = append(processors, p...)
		e, err := plugin.Discover(&quot;dkron-executor-*&quot;, filepath.Dir(exePath))
		if err != nil {
			return err
		}
		executors = append(executors, e...)
	}

	// pluginFactory
	// åˆ›å»ºè¿è¡Œæ—¶
	for _, file := range processors {
		// æ–‡ä»¶åæŒ‰ &quot;-&quot; åˆ†éš”ï¼Œå–æœ€åä¸€ä¸ªå…ƒç´ 
		// é—®é¢˜ç‚¹: æ’ä»¶åä¸æ”¯æŒå¸¦ &quot;-&quot;
		pluginName, ok := getPluginName(file)
		if !ok {
			continue
		}

		raw, err := p.pluginFactory(file, dkplugin.ProcessorPluginName)
		if err != nil {
			return err
		}
		p.Processors[pluginName] = raw.(dkplugin.Processor)
	}

	...

	return nil
}
</code></pre>
<h4 id=243-æ’ä»¶å®ç°>2.4.3. æ’ä»¶å®ç°</h4>
<p>Dkron å°è£…çš„ Plugin ç»“æ„, è§„å®šå¯ä»¥æœ‰ processor æˆ– executor ä¸¤ä¸ªæ’ä»¶ã€‚</p>
<pre><code class=language-go>// PluginMap should be used by clients for the map of plugins.
// Dkron å°è£…çš„ Plugin ç»“æ„, è§„å®šå¯ä»¥æœ‰ processor æˆ– executor ä¸¤ä¸ªæ’ä»¶
var PluginMap = map[string]plugin.Plugin{
	&quot;processor&quot;: &amp;ProcessorPlugin{},
	&quot;executor&quot;:  &amp;ExecutorPlugin{},
}
</code></pre>
<h5 id=æ„å»ºæ’ä»¶>æ„å»ºæ’ä»¶</h5>
<pre><code class=language-go>// cmd/plugins.go
// åˆ›å»º Plugin Client
func (p *Plugins) pluginFactory(path string, pluginType string) (interface{}, error) {
	var config plugin.ClientConfig
	// å¯æ‰§è¡Œæ–‡ä»¶
	config.Cmd = exec.Command(path)
    
	// handshake é…ç½®æ˜¯ client ä¸ server çº¦å®šçš„ TOKEN,
	//	ä¸é€šè¿‡ç¯å¢ƒå˜é‡åŒ…å«åŒæ ·çš„ TOKEN åˆ™æ— æ³•å¯åŠ¨ plugin ç¨‹åº.
	//	å…·ä½“æŸ¥çœ‹ go-plugin é¡¹ç›® https://github.com/mayocream/go-plugin/blob/044aadd925bf9f027cb301b2af9bc6b60775dd22/server.go#L248
	config.HandshakeConfig = dkplugin.Handshake
    
	// go-plugin åŒ…ä¼šåœ¨ NewClient çš„æ—¶å€™å‚¨å­˜ Client çš„æŒ‡é’ˆ,
	//	èƒ½å¤Ÿè°ƒç”¨ cleanClients ç»Ÿä¸€ Kill æ‰€æœ‰çš„ Client
	config.Managed = true
    
	// å®šä¹‰ä¸€ä¸ªäºŒè¿›åˆ¶æ‰€èƒ½åŒ…å«çš„ä¸åŒæ’ä»¶
	config.Plugins = dkplugin.PluginMap
	config.SyncStdout = os.Stdout
	config.SyncStderr = os.Stderr

	switch pluginType {
	case dkplugin.ProcessorPluginName:
		// processor ä½¿ç”¨ golang net/rpc è¿›è¡Œé€šä¿¡
		config.AllowedProtocols = []plugin.Protocol{plugin.ProtocolNetRPC}
	case dkplugin.ExecutorPluginName:
		// executor ä½¿ç”¨ gprc è¿›è¡Œé€šä¿¡
		config.AllowedProtocols = []plugin.Protocol{plugin.ProtocolGRPC}
	}

	// åˆå§‹åŒ–å®¢æˆ·ç«¯
	client := plugin.NewClient(&amp;config)

	// go-plugin Client() ä¼šç”¨ exec.Start å¯åŠ¨ plugin server,
	//	åˆ›å»º rpc client, è¿™ä¸ªåº“å°†è¿æ¥å¤ç”¨, ä»¥åŠ rpc/grpc service æŒ‚è½½
	//	ç­‰ç»†èŠ‚å±è”½äº†, å¼€å‘è€…åªè¦åˆ›å»ºä¸šåŠ¡é€»è¾‘ Interface å¹¶å®ç° plugin.Plguin çš„
	//	Serve/Client æ–¹æ³•å°±èƒ½å¤Ÿè¿›è¡Œ rpc é€šä¿¡
	rpcClient, err := client.Client()
	if err != nil {
		return nil, err
	}

	// è°ƒç”¨æŒ‡å®šçš„ service
	raw, err := rpcClient.Dispense(pluginType)
	if err != nil {
		return nil, err
	}

	return raw, nil
}
</code></pre>
<h5 id=è¿è¡Œæ’ä»¶>è¿è¡Œæ’ä»¶</h5>
<pre><code class=language-go>// go-plugin æ’ä»¶ start å‡½æ•°
func (c *Client) Start() (addr net.Addr, err error) {
   ...
    // å¯åŠ¨çš„ç¯å¢ƒå˜é‡
	env := []string{
		fmt.Sprintf(&quot;%s=%s&quot;, c.config.MagicCookieKey, c.config.MagicCookieValue),
		fmt.Sprintf(&quot;PLUGIN_MIN_PORT=%d&quot;, c.config.MinPort),
		fmt.Sprintf(&quot;PLUGIN_MAX_PORT=%d&quot;, c.config.MaxPort),
		fmt.Sprintf(&quot;PLUGIN_PROTOCOL_VERSIONS=%s&quot;, strings.Join(versionStrings, &quot;,&quot;)),
	}

	cmd := c.config.Cmd
	cmd.Env = append(cmd.Env, os.Environ()...)
	cmd.Env = append(cmd.Env, env...)
	cmd.Stdin = os.Stdin

    // pipe è¯»å– std è¾“å‡º
	cmdStdout, err := cmd.StdoutPipe()
	cmdStderr, err := cmd.StderrPipe()

	// å¯åŠ¨äºŒè¿›åˆ¶ç¨‹åº
	err = cmd.Start()
	if err != nil {
		return
	}

    ...
    // è¯»å–æ’ä»¶æ‰§è¡Œçš„ Output
	linesCh := make(chan string)
	c.clientWaitGroup.Add(1)
	go func() {
		defer c.clientWaitGroup.Done()
		defer close(linesCh)

		scanner := bufio.NewScanner(cmdStdout)
		for scanner.Scan() {
			linesCh &lt;- scanner.Text()
		}
	}()

	...
	return
}
</code></pre>
<h4 id=244-æ’ä»¶é€šä¿¡>2.4.4. æ’ä»¶é€šä¿¡</h4>
<h5 id=æ’ä»¶é€šä¿¡æ•°æ®ç»“æ„>æ’ä»¶é€šä¿¡æ•°æ®ç»“æ„</h5>
<pre><code class=language-protobuf>message ExecuteRequest {
  string job_name = 1;
  map&lt;string, string&gt; config = 2;
  uint32 status_server = 3;
}

message ExecuteResponse {
    bytes output = 1;
    string error = 2;
}

service Executor {
    rpc Execute (ExecuteRequest) returns (ExecuteResponse);
}

message StatusUpdateRequest {
  bytes output = 2;
  bool error = 3;
}

message StatusUpdateResponse {
  int64 r = 1;
}

service StatusHelper {
  rpc Update(StatusUpdateRequest) returns (StatusUpdateResponse);
}
</code></pre>
<h5 id=grpc-åŒå‘æµé€šä¿¡>GRPC åŒå‘æµé€šä¿¡</h5>
<pre><code class=language-go>// Here is the gRPC client that GRPCClient talks to.
type ExecutorClient struct {
	// This is the real implementation
	client types.ExecutorClient
	broker *plugin.GRPCBroker
}

// ref: https://github.com/distribworks/dkron/pull/719
// å®ç°æ‰§è¡Œæ—¶å®æ—¶ä¼ è¾“ output, åŒå‘æµ
func (m *ExecutorClient) Execute(args *types.ExecuteRequest, cb StatusHelper) (*types.ExecuteResponse, error) {
	// This is where the magic conversion to Proto happens
	statusHelperServer := &amp;GRPCStatusHelperServer{Impl: cb}

	var s *grpc.Server
	serverFunc := func(opts []grpc.ServerOption) *grpc.Server {
		s = grpc.NewServer(opts...)
		types.RegisterStatusHelperServer(s, statusHelperServer)

		return s
	}

	brokerID := m.broker.NextId()
	go m.broker.AcceptAndServe(brokerID, serverFunc)

	args.StatusServer = brokerID
	r, err := m.client.Execute(context.Background(), args)

	s.Stop()
	return r, err
}
</code></pre>
<p>ç›®å‰çº¿ä¸Šå‡ºç°è¿‡ <code>rpc: transport is closing</code> çš„é”™è¯¯ï¼Œæ˜¯ GRPC é€šä¿¡çš„é”™è¯¯ï¼Œæ¨æµ‹åœ¨æ’ä»¶é€šä¿¡çš„è¯¥éƒ¨åˆ†å‡ºç°é”™è¯¯ã€‚</p>
<h3 id=25-ä»»åŠ¡è°ƒåº¦>2.5. ä»»åŠ¡è°ƒåº¦</h3>
<h4 id=251-æ¦‚è¿°>2.5.1. æ¦‚è¿°</h4>
<p>Dkron Server ä¸­ä¸º Raft Leader çš„æœåŠ¡å™¨æˆä¸ºè°ƒåº¦æœåŠ¡å™¨ï¼Œè´Ÿè´£å®šæ—¶ä»»åŠ¡çš„åˆ†å‘ã€‚</p>
<ol>
<li>é€šè¿‡ GRPC è°ƒç”¨ä¸‹å‘ä»»åŠ¡åˆ° agent èŠ‚ç‚¹ï¼ŒAgent æ‰§è¡Œä»»åŠ¡å¹¶é€šè¿‡ GRPC æµå®æ—¶è¿”å›è¾“å‡ºï¼›</li>
<li>æ‰§è¡Œå®Œ Job å Leader é€šè¿‡ Raft Apply å‚¨å­˜ Job æ‰§è¡Œè®°å½•åˆ°å„ Server èŠ‚ç‚¹ã€‚</li>
</ol>
<h4 id=252-cron-å°è£…>2.5.2. cron å°è£…</h4>
<p>Dkron åŸºäº <a href=https://github.com/robfig/cron>robfig/cron</a> å¢åŠ äº† <code>@at</code> æ—¶é—´å®šä¹‰ï¼Œå…è®¸æŒ‡å®šåªå…è®¸ä¸€æ¬¡çš„å®šæ—¶ä»»åŠ¡ã€‚</p>
<pre><code class=language-go>// extcron/extparser.go
// NewParser creates an ExtParser instance
// å¯ç”¨ second å­—æ®µ
func NewParser() cron.ScheduleParser {
	return ExtParser{cron.NewParser(cron.Second | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)}
}

// Parse parses a cron schedule specification. It accepts the cron spec with
// mandatory seconds parameter, descriptors and the custom descriptors
// &quot;@at &lt;date&gt;&quot; and &quot;@manually&quot;.
// æ·»åŠ äº†è‡ªå®šä¹‰è§£æçš„éƒ¨åˆ†
func (p ExtParser) Parse(spec string) (cron.Schedule, error) {
	if spec == &quot;@manually&quot; {
		return At(time.Time{}), nil
	}

	const at = &quot;@at &quot;
	if strings.HasPrefix(spec, at) {
		date, err := time.Parse(time.RFC3339, spec[len(at):])
		if err != nil {
			return nil, fmt.Errorf(&quot;failed to parse date %s: %s&quot;, spec, err)
		}
		return At(date), nil
	}

	// It's not a dkron specific spec: Let the regular cron schedule parser have it
	return p.parser.Parse(spec)
}
</code></pre>
<h4 id=253-æ•°æ®ä¸€è‡´æ€§>2.5.3. æ•°æ®ä¸€è‡´æ€§</h4>
<pre><code class=language-go>// dkron/leader.go
// å¤„ç†å˜æˆ leader äº‹ä»¶
func (a *Agent) leaderLoop(stopCh chan struct{}) {
RECONCILE:
   ...
	// Apply a raft barrier to ensure our FSM is caught up
	start := time.Now()
	barrier := a.raft.Barrier(barrierWriteTimeout)
	if err := barrier.Error(); err != nil {
		a.logger.WithError(err).Error(&quot;dkron: failed to wait for barrier&quot;)
		goto WAIT
	}
   ...
}
</code></pre>
<p>å˜æˆ Leader åè°ƒç”¨ <code>raft.Barrier</code> ç¡®ä¿ FSM åŒæ­¥åˆ°æœ€æ–°çŠ¶æ€ã€‚</p>
<h4 id=254-ä»»åŠ¡ä¸‹å‘>2.5.4. ä»»åŠ¡ä¸‹å‘</h4>
<h5 id=å¯åŠ¨ä»»åŠ¡è°ƒåº¦>å¯åŠ¨ä»»åŠ¡è°ƒåº¦</h5>
<pre><code class=language-go>// dkron/scheduler.go
// å¯åŠ¨è°ƒåº¦å™¨
func (s *Scheduler) Start(jobs []*Job, agent *Agent) error {
	s.Cron = cron.New(cron.WithParser(extcron.NewParser()))

	for _, job := range jobs {
		job.Agent = agent
		// æ·»åŠ æ‰€æœ‰ Job
		s.AddJob(job)
	}
	// å¼€å§‹å®šæ—¶æ‰§è¡Œ
	s.Cron.Start()
	s.Started = true
	schedulerStarted.Set(1)

	return nil
}
</code></pre>
<p>æ·»åŠ å•ä¸ª Job åˆ° cron å®šæ—¶è§¦å‘ï¼š</p>
<pre><code class=language-go>// dkron/scheduler.go
// AddJob Adds a job to the cron scheduler
// è°ƒåº¦å™¨æ·»åŠ  Job
func (s *Scheduler) AddJob(job *Job) error {
	// Check if the job is already set and remove it if exists
	if _, ok := s.EntryJobMap.Load(job.Name); ok {
		s.RemoveJob(job)
	}

	if job.Disabled || job.ParentJob != &quot;&quot; {
		return nil
	}
    ...

	// ä¸º cron æ·»åŠ ä¸€ä¸ª job
	// Job çš„ Run æ˜¯ cron è§¦å‘çš„æ‰§è¡Œæ–¹æ³•
	id, err := s.Cron.AddJob(schedule, job)
	if err != nil {
		return err
	}
	// å‚¨å­˜ cron çš„ id
	s.EntryJobMap.Store(job.Name, id)
    ...
	return nil
}
</code></pre>
<h5 id=è§¦å‘ä»»åŠ¡è°ƒåº¦>è§¦å‘ä»»åŠ¡è°ƒåº¦</h5>
<pre><code class=language-go>// dkron/job.go
// job çš„ run æ–¹æ³•å®ç° cron.Job æ¥å£
func (j *Job) Run() {
	// Check if it's runnable
	if j.isRunnable(j.logger) {
		...
		cronInspect.Set(j.Name, j)

		// Simple execution wrapper
		ex := NewExecution(j.Name)

		// è§¦å‘è°ƒåº¦è¿è¡Œ Job
		if _, err := j.Agent.Run(j.Name, ex); err != nil {
			j.logger.WithError(err).Error(&quot;job: Error running job&quot;)
		}
	}
}
</code></pre>
<p><code>isRunnable</code> æ£€æŸ¥ä»»åŠ¡æ˜¯å¦è¢«ç¦æ­¢ï¼ŒåŒæ—¶é€šè¿‡ GRPC æŸ¥è¯¢æ‰€æœ‰ Agent å½“å‰æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ï¼Œæ˜¯å¦æœ‰ç›¸åŒçš„ JobNameï¼Œå¦‚æœâ€œä¸å…è®¸å¹¶å‘è°ƒåº¦â€åˆ™åœæ­¢æœ¬æ¬¡è°ƒåº¦ã€‚</p>
<h5 id=ä»»åŠ¡åˆ†å‘åˆ°-agent>ä»»åŠ¡åˆ†å‘åˆ° Agent</h5>
<p>æ³¨æ„ï¼šDkron è°ƒåº¦ä¼šå°†ä»»åŠ¡è°ƒåº¦åˆ°æ‰€æœ‰ç¬¦åˆ tags çš„ã€åŒä¸€ region çš„èŠ‚ç‚¹ï¼ˆSerf Membersï¼‰ä¸Šã€‚</p>
<pre><code class=language-go>// dkron/run.go
// è°ƒåº¦è¿è¡Œ Job -&gt; åˆ†å‘åˆ° agent æ‰§è¡Œä»»åŠ¡
func (a *Agent) Run(jobName string, ex *Execution) (*Job, error) {
	job, err := a.Store.GetJob(jobName, nil)
    ...
	// In case the job is not a child job, compute the next execution time
	if job.ParentJob == &quot;&quot; {
		// è·å– cron.Entry
		if e, ok := a.sched.GetEntry(jobName); ok {
			// è·å–ä¸‹ä¸€æ¬¡æ‰§è¡Œæ—¶é—´
			job.Next = e.Next
			// åŒæ­¥ job æ•°æ®
			if err := a.applySetJob(job.ToProto()); err != nil {
				return nil, fmt.Errorf(&quot;agent: Run error storing job %s before running: %w&quot;, jobName, err)
			}
		} else {
			return nil, fmt.Errorf(&quot;agent: Run error retrieving job: %s from scheduler&quot;, jobName)
		}
	}

	// In the first execution attempt we build and filter the target nodes
	// but we use the existing node target in case of retry.
	var filterMap map[string]string
	if ex.Attempt &lt;= 1 {
		filterMap, _, err = a.processFilteredNodes(job)
		if err != nil {
			return nil, fmt.Errorf(&quot;run error processing filtered nodes: %w&quot;, err)
		}
	} else {
		// In case of retrying, find the rpc address of the node or return with an error
		// é‡è¯•ä½¿ç”¨åŒæ ·çš„ Node æ‰§è¡Œ
		var addr string
		for _, m := range a.serf.Members() {
			if ex.NodeName == m.Name {
				if m.Status == serf.StatusAlive {
					addr = m.Tags[&quot;rpc_addr&quot;]
				} else {
					return nil, fmt.Errorf(&quot;retry node is gone: %s for job %s&quot;, ex.NodeName, ex.JobName)
				}
			}
		}
		filterMap = map[string]string{ex.NodeName: addr}
	}

   ...
	var wg sync.WaitGroup
	for _, v := range filterMap {
		// Call here client GRPC AgentRun
		wg.Add(1)
		go func(node string, wg *sync.WaitGroup) {
			defer wg.Done()
              
            // è¿™é‡ŒçœŸæ­£è°ƒç”¨ GRPC åˆ° agent æ‰§è¡Œ
			err := a.GRPCClient.AgentRun(node, job.ToProto(), ex.ToProto())
			if err != nil {
				...
			}
		}(v, &amp;wg)
	}

	// ç­‰å¾…æ‰€æœ‰èŠ‚ç‚¹æ‰§è¡Œå®Œ
	wg.Wait()
	return job, nil
}

</code></pre>
<p>Server å¯¹æ‰§è¡ŒçŠ¶æ€çš„å¤„ç†ï¼š</p>
<ol>
<li>GRPC é€šä¿¡å¼€å§‹ï¼ŒAgent æ¥æ”¶åˆ°ä»»åŠ¡ï¼›</li>
<li>GRPC ç»“æŸï¼ŒAgent æ‰§è¡Œå®Œæˆï¼ˆæˆåŠŸæˆ–å¤±è´¥ï¼‰ä»»åŠ¡ï¼›</li>
</ol>
<pre><code class=language-go>// dkron/grpc_client.go
// Dkron server è°ƒç”¨æ­¤æ–¹æ³•é€šè¿‡ GRPC ä¸‹å‘ Job åˆ° server/agent æ‰§è¡Œ
func (grpcc *GRPCClient) AgentRun(addr string, job *proto.Job, execution *proto.Execution) error {
	var conn *grpc.ClientConn

	// (MAYO): remove string type wrap
	conn, err := grpcc.Connect(addr)
	if err != nil {
		return err
	}
	defer conn.Close()

	// Streaming call
	a := proto.NewAgentClient(conn)
	stream, err := a.AgentRun(context.Background(), &amp;proto.AgentRunRequest{
		Job:       job,
		Execution: execution,
	})
	if err != nil {
		return err
	}

	var first bool
	for {
		// è¯»å– GRPC æµ
		ars, err := stream.Recv()

		// Stream ends
		if err == io.EOF {
			// ä»»åŠ¡æ‰§è¡Œç»“æŸ, å‘é€ done å‘½ä»¤ç»™ leader æŒä¹…åŒ–å‚¨å­˜
			addr := grpcc.agent.raft.Leader()
			if err := grpcc.ExecutionDone(string(addr), NewExecutionFromProto(execution)); err != nil {
				return err
			}
			return nil
		}

		// Error received from the stream
		if err != nil {
			// At this point the execution status will be unknown, set the FinshedAt time and an explanatory message
			execution.FinishedAt = ptypes.TimestampNow()
			execution.Output = []byte(err.Error())

			grpcc.logger.WithError(err).Error(ErrBrokenStream)

			addr := grpcc.agent.raft.Leader()
			if err := grpcc.ExecutionDone(string(addr), NewExecutionFromProto(execution)); err != nil {
				return err
			}
			return err
		}

		// Registers an active stream
		grpcc.agent.activeExecutions.Store(ars.Execution.Key(), ars.Execution)
		execution = ars.Execution
		defer grpcc.agent.activeExecutions.Delete(execution.Key())

		// Store the received execution in the raft log and store
		if !first {
			// å‚¨å­˜æ‰§è¡ŒçŠ¶æ€
			if err := grpcc.SetExecution(ars.Execution); err != nil {
				return err
			}
			first = true
		}
	}
}

</code></pre>
<h5 id=agent-ä»»åŠ¡æ‰§è¡Œ>Agent ä»»åŠ¡æ‰§è¡Œ</h5>
<p>ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ï¼š</p>
<ol>
<li>å®æ—¶å‘é€æ‰§è¡Œæƒ…å†µåˆ° Serverï¼›</li>
<li>Server å®•æœºï¼Œåˆ‡æ¢ä¸€ä¸ª Server å‘é€æœ€ç»ˆçŠ¶æ€ï¼›</li>
</ol>
<pre><code class=language-go>// dkron/grpc_agent.go
// Dkron agent æ‰§è¡Œä»»åŠ¡, GRPC å®¢æˆ·ç«¯æ¨æµ
func (as *AgentServer) AgentRun(req *types.AgentRunRequest, stream types.Agent_AgentRunServer) error {
	job := req.Job
	execution := req.Execution
    // buffer åˆ›å»º, å‚¨å­˜æ‰§è¡Œè¾“å‡º
	output, _ := circbuf.NewBuffer(maxBufSize)

	var success bool

	jex := job.Executor
	exc := job.ExecutorConfig

	execution.StartedAt = ptypes.TimestampNow()
	execution.NodeName = as.agent.config.NodeName

	// å‘é€æ‰§è¡Œå‰çŠ¶æ€
	if err := stream.Send(&amp;types.AgentRunStream{
		Execution: execution,
	}); err != nil {
		return err
	}

	...

	// Check if executor exists
	// æ‰¾åˆ°å¯¹åº”çš„æ‰§è¡Œæ’ä»¶
	if executor, ok := as.agent.ExecutorPlugins[jex]; ok {
		as.logger.WithField(&quot;plugin&quot;, jex).Debug(&quot;grpc_agent: calling executor plugin&quot;)
		runningExecutions.Store(execution.GetGroup(), execution)
		// go-plugin grpc è°ƒç”¨æ‰§è¡Œ
		out, err := executor.Execute(&amp;types.ExecuteRequest{
			JobName: job.Name,
			Config:  exc,
			// callback, å°†æ‰§è¡Œè¾“å‡ºç»“æœèµ‹å€¼åˆ° output, é€šè¿‡ stream å‘é€ç»™æœåŠ¡ç«¯
			// ref: https://github.com/distribworks/dkron/pull/719
		}, &amp;statusAgentHelper{
			stream:    stream,
			execution: execution,
		})
        ...

		if out != nil {
			output.Write(out.Output)
		}
	} else {
	   ...
		output.Write([]byte(&quot;grpc_agent: Specified executor is not present&quot;))
	}

	// æ‰§è¡Œå®Œæˆ
	execution.FinishedAt = ptypes.TimestampNow()
	execution.Success = success
	execution.Output = output.Bytes()

	runningExecutions.Delete(execution.GetGroup())

	// å‘é€æœ€ç»ˆçŠ¶æ€
	if err := stream.Send(&amp;types.AgentRunStream{
		Execution: execution,
	}); err != nil {
		// æœ‰å¯èƒ½ server æ²¡èƒ½æ¥æ”¶åˆ°æœ€åæ‰§è¡ŒçŠ¶æ€
        ...
		// TCP è¿æ¥ç­›é€‰ä¸€ä¸ª server
		rpcServer, err := as.agent.checkAndSelectServer()
		if err != nil {
			return err
		}
		// è°ƒç”¨æ‰§è¡Œå®Œæˆ
		return as.agent.GRPCClient.ExecutionDone(rpcServer, NewExecutionFromProto(execution))
	}

	return nil
}

</code></pre>
<h5 id=ä»»åŠ¡æ‰§è¡Œåå¤„ç†>ä»»åŠ¡æ‰§è¡Œåå¤„ç†</h5>
<p>Job æ‰§è¡Œå®Œæˆåå¤„ç†ï¼š</p>
<ol>
<li>å¿…é¡»ä¸º Leader è¿›è¡Œæ•°æ®æŒä¹…åŒ–ï¼›</li>
<li>é€šè¿‡ Raft Apply åŒæ­¥ Server é—´æ‰§è¡Œè®°å½•ï¼›</li>
<li>é”™è¯¯é‡è¯•ï¼Œå†æ¬¡è¿›è¡Œä»»åŠ¡è°ƒåº¦ï¼›</li>
<li>æ‰§è¡Œ Job å®šä¹‰ä¸­ä¾èµ–çš„ Jobã€‚</li>
</ol>
<pre><code class=language-go>// dkron/grpc.go
// æ‰§è¡Œå®Œæˆ, è¿›è¡Œåç»­å¤„ç†
func (grpcs *GRPCServer) ExecutionDone(ctx context.Context, execDoneReq *proto.ExecutionDoneRequest) (*proto.ExecutionDoneResponse, error) {
    ...
	if !grpcs.agent.IsLeader() {
		addr := grpcs.agent.raft.Leader()
		// å¦‚æœæˆ‘ä¸æ˜¯ leader , å°†è¯·æ±‚å‘ç»™ leader æ‰§è¡Œ
		grpcs.agent.GRPCClient.ExecutionDone(string(addr), NewExecutionFromProto(execDoneReq.Execution))
		return nil, ErrNotLeader
	}

	// This is the leader at this point, so process the execution, encode the value and apply the log to the cluster.
	// Get the defined output types for the job, and call them
	job, err := grpcs.agent.Store.GetJob(execDoneReq.Execution.JobName, nil)
	if err != nil {
		return nil, err
	}

	// æ‰§è¡Œ processor, ä¸éœ€è¦åŒå‘é€šä¿¡
	// ç”±æ­¤æ¨æµ‹ exector ä½¿ç”¨ grpc æ‰§è¡Œæ˜¯éœ€è¦ GRPC åŒå‘æµ
	pbex := *execDoneReq.Execution
	for k, v := range job.Processors {
		if processor, ok := grpcs.agent.ProcessorPlugins[k]; ok {
			v[&quot;reporting_node&quot;] = grpcs.agent.config.NodeName
			pbex = processor.Process(&amp;plugin.ProcessorArgs{Execution: pbex, Config: v})
		} else {
			...
		}
	}

	// åŒæ­¥é›†ç¾¤çŠ¶æ€
	execDoneReq.Execution = &amp;pbex
	cmd, err := Encode(ExecutionDoneType, execDoneReq)
	if err != nil {
		return nil, err
	}
	af := grpcs.agent.raft.Apply(cmd, raftTimeout)
	if err := af.Error(); err != nil {
		return nil, err
	}

	// Retrieve the fresh, updated job from the store to work on stored values
	job, err = grpcs.agent.Store.GetJob(job.Name, nil)
	if err != nil {
		grpcs.logger.WithError(err).WithField(&quot;job&quot;, execDoneReq.Execution.JobName).Error(&quot;grpc: Error retrieving job from store&quot;)
		return nil, err
	}

	// ä»»åŠ¡æ‰§è¡Œé‡è¯•
	execution := NewExecutionFromProto(&amp;pbex)
	if !execution.Success &amp;&amp; uint(execution.Attempt) &lt; job.Retries+1 {
		execution.Attempt++

		// Keep all execution properties intact except the last output
		execution.Output = &quot;&quot;
        ...

		if _, err := grpcs.agent.Run(job.Name, execution); err != nil {
			return nil, err
		}
		return &amp;proto.ExecutionDoneResponse{
			From:    grpcs.agent.config.NodeName,
			Payload: []byte(&quot;retry&quot;),
		}, nil
	}

	exg, err := grpcs.agent.Store.GetExecutionGroup(execution,
		&amp;ExecutionOptions{
			Timezone: job.GetTimeLocation(),
		},
	)
	if err != nil {
		...
		return nil, err
	}

    ...

	// æ‰§è¡Œä¾èµ–çš„ä»»åŠ¡
	if len(job.DependentJobs) &gt; 0 &amp;&amp; job.Status == StatusSuccess {
		for _, djn := range job.DependentJobs {
			dj, err := grpcs.agent.Store.GetJob(djn, nil)
			dj.Agent = grpcs.agent
			if err != nil {
				return nil, err
			}
		}
	}

	return &amp;proto.ExecutionDoneResponse{
		From:    grpcs.agent.config.NodeName,
		Payload: []byte(&quot;saved&quot;),
	}, nil
}
</code></pre>
<h3 id=26-å­¦ä¹ ç¬”è®°>2.6. å­¦ä¹ ç¬”è®°</h3>
<h4 id=261-serf-cli>2.6.1. Serf CLI</h4>
<p>
<figure class=image>
<img src=/2021/09/dkron-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/627201_0.png alt loading=lazy>
</figure></p>
<p>Serf å®˜æ–¹æ–‡æ¡£çš„ç¤ºä¾‹ä¸»è¦æ˜¯åˆ†å¸ƒå¼è¿è¡Œè„šæœ¬ï¼Œé€šè¿‡å¯åŠ¨åœ¨å¤šä¸ªæœåŠ¡å™¨ä¸Šå¯åŠ¨ serf agentï¼ˆCLI å‘½ä»¤ï¼‰ã€‚</p>
<p>é€šè¿‡é…ç½® Event handler å‚æ•°å¯åŠ¨ï¼š</p>
<pre><code class=language-bash>$ serf agent -event-handler=query:ssh=/bin/bash
</code></pre>
<p>å‘é€ Query å‘½ä»¤å°±å¯ä»¥æ‰§è¡Œç¨‹åºäº†ï¼š</p>
<pre><code class=language-bash>$ serf query ssh uptime
Query 'ssh' dispatched
Ack from 'node1.pocketstudio.net'
Ack from 'node2.pocketstudio.net'
Response from 'node2.pocketstudio.net':  05:25:34 up 21:31,  1 user,  load average: 0.00, 0.00, 0.00
Total Acks: 2
Total Responses: 1
</code></pre>
<p>å¦å¤– Consul çš„ <code>go.mod</code> é‡Œä¹Ÿå¼•ç”¨äº† Serf åŒ…ã€‚</p>
</div>
<footer class=post-footer>
<div class=post-meta>
<time datetime=" 2021-09-23" itemprop=datePublished>Sep 23, 2021</time>
</div>
</footer>
</article>
<script src=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.min.js></script>
<aside class=typeface-sans lang=zh-hans>
<nav class=toc></nav>
</aside>
<script>tocbot.init({tocSelector:'.toc',contentSelector:'article',headingSelector:'h1, h2, h3, h4, h5',hasInnerContainers:!0,collapseDepth:"3",positionFixedSelector:".toc",headingsOffset:10})</script>
</div><script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/filter-highlight-all/prism-filter-highlight-all.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script>Prism.plugins.filterHighlightAll.add(function(a){return a.language!=="mermaid"})</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.init({startOnLoad:!0},"pre code.language-mermaid",function(){const a=document.querySelectorAll('code.language-mermaid');for(const c of a){c.style.backgroundColor='initial';const b=c.parentNode;b.style.border='none',b.style.textAlign='center',window.darkmode&&!window.darkmode.isActivated()&&(b.style.backgroundColor='initial')}})</script>
</div>
</main><footer class=site-footer>
<div class=wrapper>
<div class=social-links>
<a class="social-link social-github" href=https://github.com/mayocream><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5C9.34 21.58 9.5 21.27 9.5 21 9.5 20.77 9.5 20.14 9.5 19.31 6.73 19.91 6.14 17.97 6.14 17.97c-.46-1.16-1.11-1.47-1.11-1.47C4.12 15.88 5.1 15.9 5.1 15.9 6.1 15.97 6.63 16.93 6.63 16.93 7.5 18.45 8.97 18 9.54 17.76 9.63 17.11 9.89 16.67 10.17 16.42c-2.22-.25-4.55-1.11-4.55-4.92.0-1.11.38-2 1.03-2.71C6.55 8.54 6.2 7.5 6.75 6.15c0 0 .84-.27 2.75 1.02C10.29 6.95 11.15 6.84 12 6.84s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02C17.8 7.5 17.45 8.54 17.35 8.79 18 9.5 18.38 10.39 18.38 11.5c0 3.82-2.34 4.66-4.57 4.91C14.17 16.72 14.5 17.33 14.5 18.26c0 1.34.0 2.42.0 2.74.0.27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg>
</a>
<a class="social-link social-twitter" href=https://twitter.com/Freeze_Mayo><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M22.46 6c-.77.35-1.6.58-2.46.69C20.88 6.16 21.56 5.32 21.88 4.31 21.05 4.81 20.13 5.16 19.16 5.36 18.37 4.5 17.26 4 16 4c-2.35.0-4.27 1.92-4.27 4.29C11.73 8.63 11.77 8.96 11.84 9.27 8.28 9.09 5.11 7.38 3 4.79c-.37.63-.58 1.37-.58 2.15.0 1.49.75 2.81 1.91 3.56C3.62 10.5 2.96 10.3 2.38 10V10.03c0 2.08 1.48 3.82 3.44 4.21C5.46 14.34 5.08 14.39 4.69 14.39 4.42 14.39 4.15 14.36 3.89 14.31c.54 1.69 2.11 2.95 4 2.98-1.46 1.16-3.31 1.84-5.33 1.84C2.22 19.13 1.88 19.11 1.54 19.07 3.44 20.29 5.7 21 8.12 21 16 21 20.33 14.46 20.33 8.79 20.33 8.6 20.33 8.42 20.32 8.23 21.16 7.63 21.88 6.87 22.46 6z"/></svg>
</a>
<a class="social-link social-rss" href=/index.xml target=_blank><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M6.18 15.64a2.18 2.18.0 012.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18.0 012.18-2.18M4 4.44A15.56 15.56.0 0119.56 20H16.73A12.73 12.73.0 004 7.27V4.44M4 10.1A9.9 9.9.0 0113.9 20H11.07A7.07 7.07.0 004 12.93V10.1z"/></svg>
</a>
</div>
<div class=credits>
Theme KAGAMI by Kamikat
</div>
</div>
</footer><script>(function(a){for(var a=Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')),b=0,c;b!=a.length;b++)c=a[b],c.innerHTML=c.innerHTML.replace(/[\u2000-\u206eâ¸€-\u2e7eâº€-\u2efeâ¼€-\u2fdeâ¿°-\u2ffe\u3000-ã€¾\u3040-ã‚ã‚ -ãƒ¾\u3100-\u312e\u3130-ã†ã†-ã†ã† -\u31beã‡€-\u31eeã‡°-ã‡¾ãˆ€-ã‹¾ãŒ€-ã¾ã€-\u4dbeä¸€-\u9ffe\ua960-\ua97eê°€-\ud7ae\ud7b0-\ud7feï¤€-\ufafeï¸°-ï¹\uff00-ï¿®]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud82c[\udc00-\udcfe]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e]/g,function(a){return'<span class="baseline-fix-block">'+a+'<'+'/span>'}),c.classList.remove('baseline-fix')})(Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')))</script>
<script type=text/javascript>const resize=function(){this.width=.5*(this.naturalWidth||this.width)};Array.prototype.forEach.call(document.querySelectorAll('.half-size, .retina2x'),function(a){a.naturalWidth?resize.call(a):a.onload=resize})</script>
<script src=https://cdn.jsdelivr.net/npm/twemoji@13.1.0/dist/twemoji.min.js></script>
<script>twemoji.parse(document.body,{folder:'svg',ext:'.svg'})</script>
</body>