<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/c3b55921f92a131e.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-072f062dc024cc52.js"/><script src="/_next/static/chunks/f4f1b8d9-0107da81548bf985.js" async=""></script><script src="/_next/static/chunks/435-d305dd8b5fb158de.js" async=""></script><script src="/_next/static/chunks/main-app-3958e659bb0a464b.js" async=""></script><title>Mayo Rocks!</title><meta name="description" content="Mayo&#x27;s Blog"/><link rel="icon" href="/icon.png?14d5a92fbe70e82a" type="image/png" sizes="460x460"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased"><article><p>æœ¬æ–‡æœ€åˆäº 2020 å¹´ 9 æœˆåœ¨å…¬å¸å†…éƒ¨å‘è¡¨ï¼Œç°æ•´ç†å¹¶å¢åŠ éƒ¨åˆ†æ‰¹æ³¨å…¬å¼€å‘å¸ƒã€‚</p>
<p>æœ€å¼€å§‹åŠ å…¥å…¬å¸ Infrastructure å›¢é˜Ÿæ—¶ï¼Œè¿·èŒ«çš„æˆ‘æ¥åˆ°çš„çš„ä¸€ä¸ªä»»åŠ¡å°±æ˜¯å­¦ä¹  Lua å’Œ <a href="https://github.com/openresty/lua-nginx-module">OpenResty</a>ï¼Œå½“æ—¶æ”¶åˆ°äº†ä¸¤æœ¬ä¹¦ç±çš„ PDF æ–‡ä»¶ï¼Œè¦æ±‚å°½å¿«ç†è§£å­¦ä¹ ï¼Œèƒ½å¤ŸæŒæ¡ <a href="https://github.com/Kong/kong">Kong</a>ï¼Œå¹¶ä¸”å…·æœ‰ç ”å‘èƒ½åŠ›ã€‚</p>
<p>å½“æ—¶æˆ‘è¿˜æ²¡æœ‰æ€ä¹ˆæ¥è§¦å¼€æºç¤¾åŒºï¼Œèƒ½åŠ›åªåœç•™åœ¨ Git Cloneï¼Œå¤§æ¦‚èŠ±äº† 2 å‘¨æ—¶é—´ï¼Œæˆ‘å­¦ä¹  Lua åŸºæœ¬è¯­æ³•åï¼Œå¼€å§‹é˜…è¯» Kong é¡¹ç›®çš„æºç ï¼Œå¹¶æ‰¾åˆ°å‡ ä¸ªåˆ‡å…¥ç‚¹æ¢³ç†äº†æºç åˆ†ææ–‡æ¡£ï¼Œä¹Ÿåº”è¯¥æ­£æ˜¯è¿™ä¸ªæˆæœè®©ç»„é•¿è®¤åŒäº†æˆ‘ï¼Œè¿™ä¹‹åæˆ‘è´Ÿè´£å…¬å¸ API Gateway çš„å¼€å‘ï¼Œä»¥åŠç›¸å…³çš„è½åœ°å·¥ä½œã€‚</p>
<p>é‚£ä¹ˆæœ¬æ–‡é’ˆå¯¹ Kong çš„å¯åŠ¨æµç¨‹ã€æ’ä»¶æœºåˆ¶ã€ç¼“å­˜æœºåˆ¶å’Œè¯·æ±‚çš„ç”Ÿå‘½å‘¨æœŸåšäº†è¯¦ç»†çš„é˜è¿°ï¼Œä¸è¿‡ä»æœ‰æ¬ ç¼ºçš„æ˜¯ä»£ç†è½¬å‘åŠŸèƒ½ï¼Œä¾‹å¦‚è´Ÿè½½å‡è¡¡ã€å¥åº·æ£€æŸ¥ã€æœåŠ¡å‘ç°ç­‰ï¼Œä¸è¿‡ä»‹äºå½“æ—¶çš„æˆ‘è¿˜æ˜¯ä¸ªæ‡µæ‡‚çš„æ–°äººï¼Œè¿™é‡Œå°±å…ˆåŸè°…æˆ‘è‡ªå·±äº† ğŸ¾ã€‚</p>
<p>ç»§è¿™ç¯‡æ–‡ç« ä¹‹åï¼Œæˆ‘è¿˜æ’°å†™äº† Kong Ingress Controller æºç åˆ†æï¼Œåç»­è¿˜æœ‰ APISIX çš„æºç åˆ†æå“¦ã€‚</p>
<h2>1. æ¦‚è¿°</h2>
<p>æœ¬æ–‡é’ˆå¯¹çš„æ˜¯ Kong 2.1 ç‰ˆæœ¬ï¼ˆStableï¼‰ã€‚</p>
<p>æˆ‘é˜…è¯»å¹¶ä½œå‡ºä¸­æ–‡æ³¨é‡Šçš„ Commits å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ï¼š
<a href="https://github.com/mayocream/kong/commits?author=huanghan39">https://github.com/mayocream/kong/commits?author=mayocream</a></p>
<p><strong>Kongï¼ˆOpenRestyï¼‰çš„æ‰§è¡Œé˜¶æ®µ</strong>ï¼š</p>
<p><img src="/images/2021-09-01-20.png" alt=""></p>
<p>Kong çš„æ’ä»¶æœºåˆ¶ä¹Ÿæ˜¯åŸºäº OpenResty çš„ç”Ÿå‘½å‘¨æœŸï¼Œåªä¸è¿‡æ˜¯å…¶åœ¨ä¸Šå±‚åšäº†äº›è®¸å°è£…ã€‚</p>
<p><strong>Kong çš„æ•°æ®åº“å…³è”å…³ç³»</strong>ï¼š</p>
<p><img src="/images/2021-09-01-19.png" alt=""></p>
<p>Kong è™½ç„¶æ ‡ç§°è‡ªå·±æ˜¯ Cloud Native é¡¹ç›®<sup><a href="#user-content-fn-kong" id="user-content-fnref-kong" data-footnote-ref aria-describedby="footnote-label">1</a></sup>ï¼Œä¹Ÿä¸Šæ¦œäº† CNCF <a href="https://landscape.cncf.io/">å…¨æ™¯å›¾</a>ï¼Œä½†æ˜¯å®ƒè¿˜ä¾èµ–äºä¼ ç»Ÿçš„æ•°æ®åº“ PostgreSQLï¼Œå¹¶ä¸”è¿˜è‡ªå®šä¹‰äº†è®¸å¤š functionï¼Œç›¸æ¯”äº APISIX èƒŒåå‚¨å­˜ Etcd è¦å¼±äº†è®¸å¤šã€‚æ¯”èµ· Etcd èƒ½å»ºç«‹ HTTP é•¿è¿æ¥ Watch æ•°æ®å˜åŒ–ï¼ŒKong åªèƒ½ä¾èµ–å®šæ—¶çš„è½®è¯¢ä»æ•°æ®åº“æ›´æ–°çŠ¶æ€ï¼Œæ•°æ®åº“é«˜å¯ç”¨ä¹Ÿç›¸æ¯” Etcd é›†ç¾¤è¦å¤æ‚å¾—å¤šã€‚</p>
<h2>2. é…ç½®æ–‡ä»¶</h2>
<p>Kong åœ¨å¯åŠ¨é˜¶æ®µä¼šè§£æ <a href="https://github.com/kong/kong/tree/master/kong/templates"><code>kong/templates</code></a> ç›®å½•ä¸‹çš„ <code>.lua</code> æ¨¡æ¿æ–‡ä»¶ï¼Œæ³¨å…¥ç¯å¢ƒå˜é‡å’Œ <code>kong.conf</code> è¦†ç›–é…ç½®ï¼Œç”Ÿæˆ Nginx å¯åŠ¨çš„é…ç½®æ–‡ä»¶ <code>nginx.conf</code>ã€‚</p>
<p>ç»“æ„å¦‚ä¸‹ï¼š</p>
<pre><code class="language-yaml">pid pids/nginx.pid;
error_log logs/error.log notice;

# injected nginx_main_* directives

env SKYWALKING_URL;

events {
    # injected nginx_events_* directives
    multi_accept on;
    worker_connections 16384;
}

http {
    lua_package_path       './?.lua;./?/init.lua;;;;';
    lua_package_cpath      ';;;';

    lua_shared_dict kong                        5m;
    lua_shared_dict kong_locks                  8m;
	...

    # injected nginx_http_* directives
    client_body_buffer_size 8k;

    init_by_lua_block {
        Kong = require 'kong'
        Kong.init()
    }

    init_worker_by_lua_block {
        Kong.init_worker()
    }

    upstream kong_upstream {
        server 0.0.0.1;

        # injected nginx_upstream_* directives

        balancer_by_lua_block {
            Kong.balancer()
        }
    }

	# Kong Proxy
    server {
        server_name kong;
		...
    }

	# Kong Admin API
    server {
        server_name kong_admin;
        ...
    }


}
</code></pre>
<p>Kong å®šä¹‰äº† <code>NGINX_MAIN_XXX</code>ï¼Œè¯¸å¦‚æ­¤ç±»çš„ç¯å¢ƒå˜é‡ï¼Œåœ¨è§£æé…ç½®é˜¶æ®µä¼šåŠ è½½åˆ° <code>nginx.conf</code> çš„æŒ‡å®šä½ç½®ï¼Œèƒ½å¤Ÿé¿å…ç›´æ¥ä¿®æ”¹æ¨¡æ¿æ–‡ä»¶ã€‚</p>
<p>ä¾‹å¦‚ï¼š</p>
<pre><code class="language-bash"># åœ¨ main å—é‡Œå®šä¹‰ env å˜é‡
$ export NGINX_MAIN_ENV SKYWALKING_URL;
# åˆ›å»ºæ–°çš„ lua shared dict
$ export NGINX_HTTP_Lua_SHARED_DICT tracing_buffer 128m;
</code></pre>
<p>Kong <a href="https://docs.konghq.com/2.1.x/configuration/">å®˜æ–¹çš„é…ç½®æ–‡æ¡£</a>å·²ç»éå¸¸è¯¦å°½ï¼Œè§£é‡Šäº†å„ä¸ªå‚æ•°ä»£è¡¨çš„å«ä¹‰ã€‚</p>
<p>è¿™é‡Œè¡¥å……ä¸€ç‚¹ï¼Œé€šå¸¸æˆ‘ä»¬éœ€è¦å®šä¹‰å¤šä¸ª Shared dictï¼Œé…ç½®å†™æ³•éœ€è¦æ”¹æˆè¿™ç§ä¸‘é™‹çš„å½¢å¼ï¼š</p>
<pre><code>nginx_http_lua_shared_dict = cache_buffer_one 128m; lua_shared_dict cache_buffer_two 128m
</code></pre>
<h2>3. åˆå§‹åŒ–</h2>
<h3>3.1. æ•°æ®åº“åˆå§‹åŒ–</h3>
<p><code>Kong.init()</code> æ–¹æ³•ä¸­åˆå§‹åŒ–æ•°æ®åº“ç›¸å…³ï¼š</p>
<pre><code class="language-lua">  -- æ•°æ®åº“è¿æ¥ç›¸å…³
  local db = assert(DB.new(config))
  assert(db:init_connector())
  kong.db = db
</code></pre>
<p><code>DB.new()</code> æ–¹æ³•ä¸­ä¾æ¬¡è°ƒç”¨äº† <code>Schema.new()</code>ã€<code>Entity.new()</code>ã€<code>DAO.new()</code> æ–¹æ³•ï¼Œä¸‹é¢ä¸€ä¸ªä¸ªæ¥è¯´æ˜ã€‚</p>
<h4>3.1.1. Schema</h4>
<p>Kong çš„ Schema æ•°æ®ç»“æ„ä½“ä½äº <code>db/schema/entities</code> ä¸‹ï¼Œå°± <code>routes.lua</code> ä¸ºä¾‹ï¼š</p>
<pre><code class="language-lua">local typedefs = require "kong.db.schema.typedefs"


return {
  name         = "routes",
  primary_key  = { "id" },
  endpoint_key = "name",
  workspaceable = true,
  subschema_key = "protocols",

  fields = {
    { id             = typedefs.uuid, },
    { created_at     = typedefs.auto_timestamp_s },
    { updated_at     = typedefs.auto_timestamp_s },
    { name           = typedefs.name },
    { protocols      = { type     = "set",
                         len_min  = 1,
                         required = true,
                         elements = typedefs.protocol,
                         mutually_exclusive_subsets = {
                           { "http", "https" },
                           { "tcp", "tls" },
                           { "grpc", "grpcs" },
                         },
                         default = { "http", "https" }, -- TODO: different default depending on service's scheme
                       }, },
    { methods        = typedefs.methods },
    { hosts          = typedefs.hosts },
    { paths          = typedefs.paths },
    { headers        = typedefs.headers },
    { https_redirect_status_code = { type = "integer",
                                     one_of = { 426, 301, 302, 307, 308 },
                                     default = 426, required = true,
                                   }, },
    { regex_priority = { type = "integer", default = 0 }, },
    { strip_path     = { type = "boolean", default = true }, },
    { path_handling  = { type = "string", default = "v0", one_of = { "v0", "v1" }, }, },
    { preserve_host  = { type = "boolean", default = false }, },
    { snis = { type = "set",
               elements = typedefs.sni }, },
    { sources = typedefs.sources },
    { destinations = typedefs.destinations },
    { tags             = typedefs.tags },
    { service = { type = "foreign", reference = "services" }, },
  },

  entity_checks = {
    { conditional = { if_field = "protocols",
                      if_match = { elements = { type = "string", not_one_of = { "grpcs", "https", "tls" }}},
                      then_field = "snis",
                      then_match = { len_eq = 0 },
                      then_err = "'snis' can only be set when 'protocols' is 'grpcs', 'https' or 'tls'",
                    }},
                  }
}

</code></pre>
<p><code>primary_key</code> æ˜¯åœ¨æ•°æ®åº“ä¸­ä¸»é”®ä¹Ÿæ˜¯å½“ <code>cache_key</code> æœªå®šä¹‰æ—¶çš„é»˜è®¤ <code>cache_key</code>ã€‚</p>
<p>æœ‰ <code>type=foreign</code> çš„æƒ…å†µï¼Œentity åŠ è½½æ—¶ä¼šå½“ä½œ subschema åŠ è½½è¿›æ¥ã€‚</p>
<p>æ’ä»¶ä¸åŒäºå…¶ä»– entityï¼Œæœ‰ç‰¹å®š cache_keyã€‚</p>
<pre><code class="language-lua">  name = "plugins",
  primary_key = { "id" },
  cache_key = { "name", "route", "service", "consumer" },
</code></pre>
<p>Cache ç›¸å…³æ“ä½œä¸­è°ƒç”¨ <code>Entity.cache_key()</code> è·å–ã€‚</p>
<pre><code class="language-lua">    local cache_key = dao:cache_key(entity)
    local ok, err = cache:safe_set(cache_key, entity)
</code></pre>
<p>å…·ä½“ç”Ÿæˆ <code>cache_key</code> çš„æ–¹æ³•ï¼Œè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºç¼“å­˜ keyã€‚</p>
<pre><code class="language-lua">function DAO:cache_key(key, arg2, arg3, arg4, arg5, ws_id)

  if self.schema.workspaceable then
    ws_id = ws_id or workspaces.get_workspace_id()
  end

  -- Fast path: passing the cache_key/primary_key entries in
  -- order as arguments, this produces the same result as
  -- the generic code below, but building the cache key
  -- becomes a single string.format operation
  if type(key) == "string" then
    return fmt("%s:%s:%s:%s:%s:%s:%s", self.schema.name,
               key == nil and "" or key,
               arg2 == nil and "" or arg2,
               arg3 == nil and "" or arg3,
               arg4 == nil and "" or arg4,
               arg5 == nil and "" or arg5,
               ws_id == nil and "" or ws_id)
  end

  -- Generic path: build the cache key from the fields
  -- listed in cache_key or primary_key

  if type(key) ~= "table" then
    error("key must be a string or an entity table", 2)
  end

  if key.ws_id then
    ws_id = key.ws_id
  end

  local values = new_tab(7, 0)
  values[1] = self.schema.name
  local source = self.schema.cache_key or self.schema.primary_key

  local i = 2
  for _, name in ipairs(source) do
    local field = self.schema.fields[name]
    local value = key[name]
    if value == null or value == nil then
      value = ""
    elseif field.type == "foreign" then
      -- FIXME extract foreign key, do not assume `id`
      value = value.id
    end
    values[i] = tostring(value)
    i = i + 1
  end
  for n = i, 6 do
    values[n] = ""
  end

  values[7] = ws_id or ""

  return concat(values, ":")
end
</code></pre>
<p><code>schema/init.lua</code> ä¸­å®šä¹‰äº† schema ç›¸å…³æ“ä½œçš„åŸºæœ¬æ–¹æ³•ï¼š</p>
<pre><code class="language-lua">-- each_field() ç”¨äºéå† schema çš„ fields
-- æ˜¯ schema ç›¸å…³æ“ä½œæœ€é¢‘ç¹çš„
function Schema:each_field(values)
  local i = 1

  local subschema
  if values then
    subschema = get_subschema(self, values)
  end

  return function()
    local item = self.fields[i]
    if not item then
      return nil
    end
    local key = next(item)
    local field = resolve_field(self, key, item[key], subschema)
    i = i + 1
    return key, field
  end
end
</code></pre>
<p><code>Schema.new()</code> æ–¹æ³•ä¸­é€šè¿‡å…ƒç»„è®¾ç½® <code>__index</code> è®©ç»“æ„ä½“ç»§æ‰¿ Schema ä¸‹å®šä¹‰çš„ä¸€ç³»åˆ—æ“ä½œæ–¹æ³•ã€‚</p>
<pre><code class="language-lua">function Schema.new(definition, is_subschema)
  if not definition then
    return nil, validation_errors.SCHEMA_NO_DEFINITION
  end

  if not definition.fields then
    return nil, validation_errors.SCHEMA_NO_FIELDS
  end

  local self = copy(definition)

  -- ç»§æ‰¿ Schema ä¸‹å®šä¹‰çš„ä¸€ç³»åˆ—æ“ä½œæ–¹æ³•
  setmetatable(self, Schema)

  -- entity ç¼“å­˜çš„ cache_keyï¼Œ
  -- å¦‚æœæ²¡æœ‰è¿™ä¸ªå­—æ®µï¼Œåˆ™é»˜è®¤ä½¿ç”¨ schema å®šä¹‰çš„
  -- primary_key æ¥ä½œä¸º cache_key
  -- cache_key æ˜¯ä¸ªæ•°ç»„ï¼Œ
  -- è¿™é‡Œåªæ˜¯åˆ†å¼€å‚¨å­˜
  if self.cache_key then
    self.cache_key_set = {}
    for _, name in ipairs(self.cache_key) do
      self.cache_key_set[name] = true
    end
  end


  -- é€šè¿‡å…ƒç»„ __index æ–¹æ³•è°ƒç”¨ Schema:each_field() æ–¹æ³•
  -- éå† schema çš„ fields table
  for key, field in self:each_field() do
    -- Also give access to fields by name
    self.fields[key] = field
    if field.type == "record" and field.fields then
      allow_record_fields_by_name(field)
    end

    -- å¦‚æœæœ‰å¤–é”®
    -- åˆ™åŠ è½½å¤–é”®å…³è”çš„ schema è¿›æ¥
    if field.type == "foreign" then
      local err
      field.schema, err = get_foreign_schema_for_field(field)
      if not field.schema then
        return nil, err
      end

      if not is_subschema then
        -- Store the inverse relation for implementing constraints
        local constraints = assert(_cache[field.reference]).constraints
        table.insert(constraints, {
          schema     = self,
          field_name = key,
          on_delete  = field.on_delete,
        })
      end
    end
  end

  if self.workspaceable and self.name then
    if not _workspaceable[self.name] then
      _workspaceable[self.name] = true
      table.insert(_workspaceable, { schema = self })
    end
  end

  if self.name then
    -- do not reset the constraints list if a schema in reloaded
    if not _cache[self.name] then
      _cache[self.name] = {
        constraints = {},
      }
    end
    -- but always update the schema object in cache
    _cache[self.name].schema = self
  end

  return self
end
</code></pre>
<p>ç”¨äºä¸‹çº§ç»§æ‰¿çš„å…ƒç»„ï¼Œè™šæ™ƒä¸€æªã€‚</p>
<pre><code class="language-lua">local Schema       = {}
Schema.__index     = Schema
</code></pre>
<h4>3.1.2. Entity</h4>
<p>Entity åªæ˜¯ç®€å•å¯¹ Schema è¿›è¡Œä¸€å±‚å°è£…ã€‚</p>
<pre><code class="language-lua">-- definition æ˜¯ schema ç»“æ„ä½“
function Entity.new(definition)

  -- åˆå§‹åŒ– Schema å¯¹è±¡
  local self, err = Schema.new(definition)
  if not self then
    return nil, err
  end

  -- éå† schema fields
  for name, field in self:each_field() do
    if field.nilable then
      return nil, entity_errors.NO_NILABLE:format(name)
    end

    if field.abstract then
      goto continue
    end

    if field.type == "map" then
      if field.keys.type ~= "string" then
        return nil, entity_errors.MAP_KEY_STRINGS_ONLY:format(name)
      end

    elseif field.type == "record" then
      make_records_required(field)

    elseif field.type == "function" then
      return nil, entity_errors.NO_FUNCTIONS:format(name)
    end

    ::continue::
  end

  self.new_subschema = Entity.new_subschema

  return self
end

</code></pre>
<p>Entity å¯¹è±¡éšåè¢«åŠ è½½åˆ° <code>DB.new()</code> å‡½æ•°ä¸­ï¼š</p>
<pre><code class="language-lua">local schemas = {}

do
  -- load schemas
  -- core entities are for now the only source of schemas.
  -- TODO: support schemas from plugins entities as well.

  -- è½½å…¥æ ¸å¿ƒ entityï¼Œä¸ºä»€ä¹ˆæ˜¯æ ¸å¿ƒ entity
  -- å› ä¸ºè¿˜æœ‰ plugin è‡ªå®šä¹‰çš„ entity
  -- è¿™äº› entity æ˜¯ Kong è‡ªèº«çš„
  for _, entity_name in ipairs(constants.CORE_ENTITIES) do

    -- åŠ è½½ schemaï¼ˆæ•°æ®ç»“æ„ä½“ï¼‰
    local entity_schema = require("kong.db.schema.entities." .. entity_name)

    -- validate core entities schema via metaschema
    local ok, err_t = MetaSchema:validate(entity_schema)
    if not ok then
      return nil, fmt("schema of entity '%s' is invalid: %s", entity_name,
                      tostring(errors:schema_violation(err_t)))
    end

    -- åŠ è½½ entity å¯¹è±¡
    local entity, err = Entity.new(entity_schema)
    if not entity then
      return nil, fmt("schema of entity '%s' is invalid: %s", entity_name,
                      err)
    end
    schemas[entity_name] = entity

    -- load core entities subschemas
    local subschemas
    ok, subschemas = utils.load_module_if_exists("kong.db.schema.entities." .. entity_name .. "_subschemas")
    if ok then
      for name, subschema in pairs(subschemas) do
        local ok, err = entity:new_subschema(name, subschema)
        if not ok then
          return nil, ("error initializing schema for %s: %s"):format(entity_name, err)
        end
      end
    end
  end
end
</code></pre>
<h4>3.1.3. DAO</h4>
<p><code>db/dao/init.lua</code> ä¸­å®šä¹‰äº†ä¸€ç³»åˆ—å¯¹æ•°æ®åº“æ“ä½œçš„æ–¹æ³•ï¼Œä¾‹å¦‚ï¼š</p>
<pre><code class="language-lua">function DAO:select(primary_key, options)
function DAO:page(size, offset, options)
function DAO:each(size, options)
function DAO:insert(entity, options)
function DAO:update(primary_key, entity, options)
function DAO:delete(primary_key, options)
...
</code></pre>
<p><code>DAO.new()</code> ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å« db è¿æ¥ä¿¡æ¯ï¼Œentity çš„ tableã€‚</p>
<pre><code class="language-lua">-- schema å‚æ•°æ˜¯ Entity å¯¹è±¡
--  DB ç»“æ„ä½“ï¼š  local self   = {
  --    daos       = daos,       -- each of those has the connector singleton
  --    strategies = strategies,
  --    connector  = connector,
  --    strategy   = strategy,
  --    errors     = errors,
  --    infos      = connector:infos(),
  --    kong_config = kong_config,
  --  }
function _M.new(db, schema, strategy, errors)
  local fk_methods = generate_foreign_key_methods(schema)
  -- ç»§æ‰¿ DAO åŸºç¡€æ–¹æ³•
  local super      = setmetatable(fk_methods, DAO)

  local self = {
    db         = db,
    schema     = schema,
    strategy   = strategy,
    errors     = errors,
    pagination = utils.shallow_copy(defaults.pagination),
    super      = super,
  }

  if schema.dao then
    -- æ’ä»¶è‡ªå®šä¹‰çš„ dao
    local custom_dao = require(schema.dao)
    for name, method in pairs(custom_dao) do
      self[name] = method
    end
  end

  return setmetatable(self, { __index = super })
end
</code></pre>
<p>åœ¨ <code>db\init.lua</code> ä¸­åŠ è½½æ‰€æœ‰ DAO å¯¹è±¡ã€‚</p>
<pre><code class="language-lua">  do
    -- load DAOs

    for _, schema in pairs(schemas) do
      local strategy = strategies[schema.name]
      if not strategy then
        return nil, fmt("no strategy found for schema '%s'", schema.name)
      end

      -- å‚¨å­˜ daos
      daos[schema.name] = DAO.new(self, schema, strategy, errors)
    end
  end
</code></pre>
<p>å’Œä¸Šé¢ç»“æ„ä¸€æ ·ï¼Œ<code>DB.new()</code> ä¸­æœ€åä¸º table è®¾ç½®å…ƒç»„ __index æ–¹æ³•ã€‚</p>
<pre><code class="language-lua">  -- è®¾ç½®å…ƒç»„ __index æ–¹æ³•
  -- è®¿é—®ä¸å­˜åœ¨çš„å¯¹è±¡åˆ™å…ˆ
  -- DB.xxx å†è®¿é—® DB.daos.xxx
  return setmetatable(self, DB)


local DB = {}
DB.__index = function(self, k)
  -- rawget ä¸ºä¸è°ƒç”¨å…ƒç»„ __index æ–¹æ³•ï¼Œç›´æ¥è·å–åŸæ•°æ®
  return DB[k] or rawget(self, "daos")[k]
end
</code></pre>
<p>Kong ä¸­å…¶ä»–åœ°æ–¹è°ƒç”¨æ•°æ®åº“æ–¹æ³•ï¼Œæ“ä½œç¬¦ä¸º <code>kong.db.services:each_fields()</code>ï¼Œå³å®é™…è°ƒç”¨ <code>daos.services</code>ã€<code>entity:each_fields()</code>ï¼ˆå®é™…æ˜¯ <code>Schema:each_fields()</code>ï¼‰ã€‚</p>
<p>DAO ä¸‹é¢è¿˜æœ‰å°è£…çš„æ•°æ®åº“æ“ä½œå±‚ï¼Œä¾‹å¦‚ postgresql ç”Ÿæˆ SQL è¯­å¥çš„æ–¹æ³•ï¼Œè¿™é‡Œå°±ä¸èµ˜è¿°äº†ã€‚</p>
<p>DAO è¿™ä¸€å±‚ä¸€å±‚çš„å°è£…çœ‹å¾—æˆ‘æ˜¯çœŸçš„è„‘å£³ç—›ï¼ŒIDE è¿˜æ²¡æœ‰å¯¹ lua çš„æ™ºèƒ½æç¤ºï¼ŒæŒ‰ä½ Ctrl æ¯›éƒ½æ˜¾ç¤ºä¸å‡ºæ¥ã€‚</p>
<h3>3.2. ç¼“å­˜æ„å»º</h3>
<p><code>init_by_lua</code>  é˜¶æ®µåˆå§‹åŒ– Master è¿›ç¨‹ï¼Œè¿›è¡Œè§£æé…ç½®æ–‡ä»¶ã€è¿æ¥æ•°æ®åº“ã€æ¸…ç©ºå…±äº«å†…å­˜ã€æ„å»ºè·¯ç”±ç¼“å­˜ç­‰æ“ä½œã€‚</p>
<p><code>reset_kong_shm</code> ä»£ç å—é‡Œæ¸…ç†å…±äº«å†…å­˜ã€‚</p>
<pre><code class="language-lua">    local shms = {
      "kong",
      "kong_locks",
      "kong_healthchecks",
      "kong_process_events",
      "kong_cluster_events",
      "kong_rate_limiting_counters",
      "kong_core_db_cache" .. suffix,
      "kong_core_db_cache_miss" .. suffix,
      "kong_db_cache" .. suffix,
      "kong_db_cache_miss" .. suffix,
      "kong_clustering",
    }

    for _, shm in ipairs(shms) do
      local dict = ngx.shared[shm]
      -- æ¸…ç©ºå…±äº«å†…å­˜
      if dict then
        dict:flush_all()
        dict:flush_expired(0)
      end
    end
</code></pre>
<h4>3.2.1. è·¯ç”±ç¼“å­˜</h4>
<pre><code class="language-lua">  else
    -- DB æ¨¡å¼
    local default_ws = db.workspaces:select_by_name("default")
    kong.default_workspace = default_ws and default_ws.id

    local ok, err = runloop.build_plugins_iterator("init")
    if not ok then
      error("error building initial plugins: " .. tostring(err))
    end

    -- åˆå§‹åŒ–è·¯ç”±
    -- æ„å»ºè·¯ç”±ç¼“å­˜
    assert(runloop.build_router("init"))
  end

  db:close()
end
</code></pre>
<p>DB æ¨¡å¼ä¸‹æœ€åä¸€æ­¥ä¼šè°ƒç”¨ <code>runloop.build_router("init")</code> æ„å»ºè·¯ç”±ç¼“å­˜ã€‚</p>
<p>æ„å»ºè·¯ç”±ç¼“å­˜è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­ Kong æ˜¯å¦å·²ç»åˆå§‹åŒ–è¿‡ Cache ç»„ä»¶ï¼Œ<code>init</code> é˜¶æ®µæ²¡æœ‰å®Œæˆåˆå§‹åŒ– Cacheï¼Œåˆ™åˆ›å»ºä¸€ä¸ª Lua table ç¼“å­˜è·¯ç”±ä¿¡æ¯ã€‚<code>build_services_init_cache()</code> æ–¹æ³•ä¼šåˆ†é¡µåŠ è½½æ‰€æœ‰ Service åˆ° table ä¸­ï¼Œå¯¹å–å‡ºæ¥çš„ Servicesï¼Œåˆ¤æ–­å½“å‰ä½¿ç”¨çš„ Nginx æ¨¡å¼ï¼ˆhttp/streamï¼‰æ˜¯å¦å¯¹åº”è·¯ç”±æŒ‡å®šçš„åè®®ï¼Œå¯¹åº”åˆ™å–å‡º Service å¯¹è±¡ï¼Œä¸ Route è¿›è¡Œå…³è”ã€‚æœ€åä¼ é€’ç»™ <code>Router.new()</code> æ–¹æ³•é€šè¿‡ç®—æ³•å»ºç«‹æ ‘å½¢ç»“æ„å»ºç«‹è·¯ç”±ç´¢å¼•ã€‚</p>
<p>Kong åŸºäº Nginx Subsystem æ”¯æŒçš„åè®®å¯¹åº”å…³ç³»ï¼š</p>
<ul>
<li>http/https -> http</li>
<li>grpc/grpcs -> http</li>
<li>tcp/tls -> stream</li>
</ul>
<pre><code class="language-lua">  build_router = function(version)
    local db = kong.db
    -- table å‚¨å­˜æ‰€æœ‰çš„ route-service æ•°æ®
    local routes, i = {}, 0

    local err
    -- The router is initially created on init phase, where kong.core_cache is
    -- still not ready. For those cases, use a plain Lua table as a cache
    -- instead
    -- init é˜¶æ®µ core_cache è¿˜æ²¡æœ‰åˆå§‹åŒ–å®Œæˆ
    -- è¿™é‡Œä½¿ç”¨ table å‚¨å­˜
    local services_init_cache = {}
    if not kong.core_cache and db.strategy ~= "off" then
      -- è·å–æ‰€æœ‰çš„ servicesï¼Œä½¿ç”¨é»˜è®¤çš„åˆ†é¡µå‚æ•°
      services_init_cache, err = build_services_init_cache(db)
      if err then
        services_init_cache = {}
        log(WARN, "could not build services init cache: ", err)
      end
    end

    local counter = 0
    local page_size = db.routes.pagination.page_size
    for route, err in db.routes:each(nil, GLOBAL_QUERY_OPTS) do
      if err then
        return nil, "could not load routes: " .. err
      end

      -- æ£€æŸ¥ router æ•°æ®æ˜¯å¦å·²ç»å˜åŒ–
      -- é€šè¿‡æ£€æŸ¥ router hash æ˜¯å¦ä¸€è‡´åˆ¤æ–­
      -- å¦‚æœå·²ç»å˜åŒ–åˆ™é€€å‡ºå‡½æ•°
      if db.strategy ~= "off" then
        if kong.core_cache and counter > 0 and counter % page_size == 0 then
          local new_version, err = get_router_version()
          if err then
            return nil, "failed to retrieve router version: " .. err
          end

          if new_version ~= version then
            return nil, "router was changed while rebuilding it"
          end
        end
      end

      -- subsystem æ˜¯å¦æ”¯æŒå½“å‰è·¯ç”±çš„åè®®
      if should_process_route(route) then
        -- è·å– route çš„ service
        local service, err = get_service_for_route(db, route, services_init_cache)
        if err then
          return nil, err
        end

        local r = {
          route   = route,
          service = service,
        }

        i = i + 1
        -- å‚¨å­˜æ‰€æœ‰çš„ route-service
        routes[i] = r
      end

      counter = counter + 1
    end

    local new_router, err = Router.new(routes)
    if not new_router then
      return nil, "could not create router: " .. err
    end

    -- router å®ä¾‹
    router = new_router

    if version then
      router_version = version
    end

    -- LEGACY - singletons module is deprecated
    singletons.router = router
    -- /LEGACY

    return true
  end
</code></pre>
<p>æ„å»ºè·¯ç”±ç¼“å­˜è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­ Kong æ˜¯å¦å·²ç»åˆå§‹åŒ–è¿‡ Cache ç»„ä»¶ï¼Œ<code>init</code> é˜¶æ®µæ²¡æœ‰å®Œæˆåˆå§‹åŒ– Cacheï¼Œåˆ™åˆ›å»ºä¸€ä¸ª Lua table ç¼“å­˜ servicesã€‚</p>
<pre><code class="language-lua">  -- ä»¥ [service.id] = service
  -- ç»“æ„å‚¨å­˜åˆ° table ä¸­
  local function build_services_init_cache(db)
    local services_init_cache = {}

    for service, err in db.services:each(nil, GLOBAL_QUERY_OPTS) do
      if err then
        return nil, err
      end

      services_init_cache[service.id] = service
    end

    return services_init_cache
  end
</code></pre>
<p><code>build_services_init_cache(db)</code> æ–¹æ³•ï¼Œè°ƒç”¨ <code>DAO:each()</code> å‡½æ•°ï¼Œä½¿ç”¨é»˜è®¤åˆ†é¡µå‚æ•° <code>page_size=1000</code>ï¼Œè¿›è¡Œåˆ†é¡µè·å–ï¼Œå†è¿”å›å¯è¿­ä»£çš„å•æ¡è®°å½•ã€‚è¿™é‡Œå› ä¸º <code>init_by_lua</code> é˜¶æ®µæ²¡æœ‰åˆå§‹åŒ–ç¼“å­˜ï¼ˆ<code>kong.core_cache</code> ï¼‰ï¼Œæ‰€ä»¥ä½¿ç”¨ Lua table å‚¨å­˜ç¼“å­˜æ•°æ®ã€‚</p>
<pre><code class="language-lua">function DAO:each(size, options)
  if size ~= nil then
    validate_size_type(size)
  end

  -- è·å–åˆ†é¡µæ¡ä»¶ï¼Œæœ‰é»˜è®¤å€¼
  options = get_pagination_options(self, options)

  if size ~= nil then
    local ok, err = validate_size_value(size, options.pagination.max_page_size)
    if not ok then
      local err_t = self.errors:invalid_size(err)
      return nil, tostring(err_t), err_t
    end

  else
    size = options.pagination.page_size
  end

  local ok, errors = validate_options_value(self, options)
  if not ok then
    local err_t = self.errors:invalid_options(errors)
    return nil, tostring(err_t), err_t
  end

  local pager = function(size, offset, options)
    return self.strategy:page(size, offset, options)
  end

  return iteration.by_row(self, pager, size, options)
end
</code></pre>
<p>é»˜è®¤åˆ†é¡µå‚æ•°åœ¨ <code>db/strategies/connector.lua</code> æ–‡ä»¶ä¸­ï¼š</p>
<pre><code class="language-lua">local Connector = {
  defaults = {
    -- é»˜è®¤åˆ†é¡µæ¡ä»¶
    pagination = {
      page_size     = 1000,
      max_page_size = 50000,
    },
  },
}
</code></pre>
<p>æ¥ä¸‹æ¥ä¼šéå†æ‰€æœ‰çš„ Routesï¼Œé€ä¸ªè°ƒç”¨ <code>should_process_route()</code> å’Œ <code>get_service_for_route()</code> æ–¹æ³•ï¼Œå‰è€…ä¼šåˆ¤æ–­ Nginx Subsystem æ˜¯å¦å’Œ Route åè®®ä¸€è‡´ï¼Œåè€…å…ˆåœ¨ç¼“å­˜ä¸­æŸ¥æ‰¾ Serviceï¼Œå¦‚æœç¼“å­˜ä¸­ä¸å­˜åœ¨åˆ™ä»æ•°æ®åº“ä¸­è·å–ã€‚</p>
<pre><code class="language-lua">  local function get_service_for_route(db, route, services_init_cache)
    -- route å…³è”çš„ service å¤–é”®
    local service_pk = route.service
    if not service_pk then
      return nil
    end

    -- æŸ¥æ‰¾ç¼“å­˜ table é‡Œçš„ service
    local id = service_pk.id
    local service = services_init_cache[id]
    if service then
      return service
    end

    local err

    -- kong.core_cache is available, not in init phase
    if kong.core_cache then
      -- é€šè¿‡ mlcache æŸ¥è¯¢ service
      local cache_key = db.services:cache_key(service_pk.id, nil, nil, nil, nil,
                                              route.ws_id)
      -- æŸ¥è¯¢ cache è·å–ï¼Œæ²¡æœ‰è·å–åˆ°åˆ™è°ƒç”¨ load_service_from_db è·å–
      service, err = kong.core_cache:get(cache_key, TTL_ZERO,
                                    load_service_from_db, service_pk)

    else -- init phase, kong.core_cache not available

      -- A new service/route has been inserted while the initial route
      -- was being created, on init (perhaps by a different Kong node).
      -- Load the service individually and update services_init_cache with it
      -- ç›´æ¥æŸ¥è¯¢æ•°æ®åº“è·å– service
      service, err = load_service_from_db(service_pk)
      services_init_cache[id] = service
    end

    if err then
      return nil, "error raised while finding service for route (" .. route.id .. "): " ..
                  err

    elseif not service then
      return nil, "could not find service for route (" .. route.id .. ")"
    end


    -- TODO: this should not be needed as the schema should check it already
    if SUBSYSTEMS[service.protocol] ~= subsystem then
      log(WARN, "service with protocol '", service.protocol,
                "' cannot be used with '", subsystem, "' subsystem")

      return nil
    end

    return service
  end

</code></pre>
<p><code>load_service_from_db()</code> æ–¹æ³•ä¸­åªæ˜¯ç®€å•è°ƒç”¨ <code>DAO:select()</code> æ–¹æ³•ï¼Œå–å‡º Service åŒæ—¶ç¼“å­˜åˆ° <code>services_init_cache</code> table ä¸­ï¼Œä¸æ›´æ–° <code>Kong.core_cache</code> ç»„ä»¶ã€‚</p>
<p>å¯¹æ•°æ®åº“å®ä½“å¯¹è±¡çš„å¤„ç†ä¸­ï¼Œåªæœ‰<code>create</code> ã€<code>update</code>ã€<code>delete</code> ä¼šé€šè¿‡äº‹ä»¶å¹¿æ’­åˆ°å…¶ä»– Worker åŒæ­¥ï¼Œåé¢äº‹ä»¶çš„ä¸€èŠ‚æˆ‘ä»¬ä¼šè¯¦ç»†é˜è¿°ã€‚</p>
<p>æ¥ä¸‹æ¥å°† <code>{router, service}</code> æ•°ç»„ä¼ å…¥ <code>router.iua</code> ä¸­ <code>Router.new()</code> å‡½æ•°å¤„ç†ã€‚</p>
<pre><code class="language-lua">local new_router, err = Router.new(routes)
if not new_router then
    return nil, "could not create router: " .. err
end

-- ç»‘å®š router å®ä¾‹
router = new_router
</code></pre>
<p>å…·ä½“æ„å»ºè·¯ç”±ç´¢å¼•çš„è¿‡ç¨‹åœ¨ <code>router.lua</code> ä¸­çš„ <code>_M.new(routes)</code> å‡½æ•°ï¼Œä½¿ç”¨ <strong><a href="https://github.com/openresty/lua-resty-lrucache">lua-resty-lrucache</a></strong> åŒ…ç¼“å­˜ï¼Œå¯¹è·¯ç”±å’Œ Service ç»„åˆé€šè¿‡ç®—æ³•è¿›è¡Œæ’åºï¼Œæ„å»ºç´¢å¼•ï¼Œå°†è¯¸å¦‚ <code>{cache_key: {route, service}}</code> ç»“æ„å­˜å…¥ç¼“å­˜ä¸­ï¼Œè¿”å› Router å®ä¾‹ã€‚</p>
<p>è·¯ç”±ç´¢å¼• Key çš„æ„å»ºæ–¹æ³•ï¼š</p>
<pre><code class="language-lua">    local cache_key = req_method .. "|" .. req_uri .. "|" .. req_host ..
                      "|" .. ctx.src_ip .. "|" .. ctx.src_port ..
                      "|" .. ctx.dst_ip .. "|" .. ctx.dst_port ..
                      "|" .. ctx.sni
</code></pre>
<p>Router å®ä¾‹ç”± Master è¿›ç¨‹æ„å»ºï¼Œå¹¶ fork åˆ°å„ä¸ª Worker è¿›ç¨‹ä½¿ç”¨ã€‚</p>
<p>Worker æ‰§è¡Œå®Œå…±äº«å†…å­˜çš„æ„å»ºåï¼Œæ³¨å†Œå®šæ—¶ä»»åŠ¡ï¼Œå®šæ—¶é‡å»ºç¼“å­˜ã€‚</p>
<pre><code class="language-lua">      -- å®šæ—¶é‡å»ºè·¯ç”±ç¼“å­˜
      if kong.db.strategy ~= "off" then
        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          -- Don't wait for the semaphore (timeout = 0) when updating via the
          -- timer.
          -- If the semaphore is locked, that means that the rebuild is
          -- already ongoing.
          local ok, err = rebuild_router(ROUTER_ASYNC_OPTS)
          if not ok then
            log(ERR, "could not rebuild router via timer: ", err)
          end
        end)

        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          local ok, err = rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)
          if not ok then
            log(ERR, "could not rebuild plugins iterator via timer: ", err)
          end
        end)
      end
</code></pre>
<h4>3.2.2. Entity ç¼“å­˜</h4>
<p>è¿™é‡Œé¦–å…ˆä»‹ç»ä¸€ä¸‹ <strong><a href="https://github.com/thibaultcha/lua-resty-mlcache">lua-resty-mlcache</a></strong> è¿™ä¸ªç¼“å­˜åº“ï¼Œè¯¥åº“åŸºäº <a href="https://github.com/openresty/lua-nginx-module#lua_shared_dict">lua_shared_dict</a> å’Œ <a href="https://github.com/openresty/lua-resty-lrucache">lua-resty-lrucache</a> åšäº†ä¸¤å±‚ç¼“å­˜ï¼ŒWorker ä¼šæœ‰è‡ªå·±çš„è¿›ç¨‹çº§åˆ«çš„ LRU ç¼“å­˜ï¼Œé¦–å…ˆä¼šåœ¨è¿™ä¸€å±‚è¿›è¡ŒæŸ¥è¯¢ï¼Œå…¶æ¬¡ä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œç¼“å­˜ï¼Œæœ€åæä¾› callback ä»æ•°æ®åº“æŸ¥è¯¢ï¼Œä½¿ç”¨ <a href="https://github.com/openresty/lua-resty-lock">lua-resty-lock</a> åº“åˆ›å»ºé”åªå…è®¸å•ä¸ªè¿›ç¨‹æ‰§è¡Œ callbackã€‚</p>
<p>mlcache æ¶æ„å›¾ï¼š</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nginx                                           â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚       â”‚worker     â”‚ â”‚worker     â”‚ â”‚worker     â”‚ â”‚
â”‚ L1    â”‚           â”‚ â”‚           â”‚ â”‚           â”‚ â”‚
â”‚       â”‚ Lua cache â”‚ â”‚ Lua cache â”‚ â”‚ Lua cache â”‚ â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚             â”‚             â”‚             â”‚       â”‚
â”‚             â–¼             â–¼             â–¼       â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚       â”‚                                       â”‚ â”‚
â”‚ L2    â”‚           lua_shared_dict             â”‚ â”‚
â”‚       â”‚                                       â”‚ â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚ mutex               â”‚
â”‚                           â–¼                     â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚                  â”‚     callback     â”‚           â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
  L3                        â”‚   I/O fetch
                            â–¼

                   Database, API, DNS, Disk, any I/O...
</code></pre>
<p><code>Kong.init_worker()</code> ä¸­è¿›è¡Œåˆå§‹åŒ–ç¼“å­˜ï¼š</p>
<pre><code class="language-lua">  -- åˆå§‹åŒ–åŸºäºå…±äº«å†…å­˜çš„ cache
  local cache, err = kong_global.init_cache(kong.configuration, cluster_events, worker_events)
  if not cache then
    stash_init_worker_error("failed to instantiate 'kong.cache' module: " ..
                            err)
    return
  end
  kong.cache = cache

  local core_cache, err = kong_global.init_core_cache(kong.configuration, cluster_events, worker_events)
  if not core_cache then
    stash_init_worker_error("failed to instantiate 'kong.core_cache' module: " ..
                            err)
    return
  end
  kong.core_cache = core_cache

  ok, err = runloop.set_init_versions_in_cache()
  if not ok then
    stash_init_worker_error(err) -- 'err' fully formatted
    return
  end
</code></pre>
<p><code>global.init_cache()</code> ç»“æ„å¦‚ä¸‹ï¼š</p>
<pre><code class="language-lua">function _GLOBAL.init_cache(kong_config, cluster_events, worker_events)
  local db_cache_ttl = kong_config.db_cache_ttl
  local db_cache_neg_ttl = kong_config.db_cache_neg_ttl
  local cache_pages = 1
  if kong_config.database == "off" then
    db_cache_ttl = 0
    db_cache_neg_ttl = 0
    cache_pages = 2
  end

  return kong_cache.new {
    shm_name          = "kong_db_cache",
    cluster_events    = cluster_events,
    worker_events     = worker_events,
    ttl               = db_cache_ttl,
    neg_ttl           = db_cache_neg_ttl or db_cache_ttl,
    resurrect_ttl     = kong_config.resurrect_ttl,
    cache_pages       = cache_pages,
    resty_lock_opts   = {
      exptime = 10,
      timeout = 5,
    },
  }
end
</code></pre>
<p>æœ€ç»ˆä¼šè°ƒç”¨ <code>cache.lua</code> ä¸­ <code>_M.new()</code> è¿›è¡Œå¿…è¦å‚æ•°çš„éªŒè¯ï¼Œæ£€æµ‹å…±äº«å†…å­˜å—æ˜¯å¦å¯ä»¥è®¿é—®ï¼Œå…³è”é›†ç¾¤äº‹ä»¶å’Œ Worker äº‹ä»¶ï¼Œå®šä¹‰åºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„æ–¹æ³•ï¼Œå¯¹ mlcache è¿›è¡Œä¸€å±‚å°è£…ã€‚</p>
<pre><code class="language-lua">function _M.new(opts)
  -- opts validation

  opts = opts or {}

  local mlcaches = {}
  local shm_names = {}

  for i = 1, opts.cache_pages or 1 do
    local channel_name  = (i == 1) and "mlcache"                 or "mlcache_2"
    local shm_name      = (i == 1) and opts.shm_name             or opts.shm_name .. "_2"
    local shm_miss_name = (i == 1) and opts.shm_name .. "_miss"  or opts.shm_name .. "_miss_2"

    if ngx.shared[shm_name] then
      local mlcache, err = resty_mlcache.new(shm_name, shm_name, {
        shm_miss         = shm_miss_name,
        shm_locks        = "kong_locks",
        shm_set_retries  = 3,
        lru_size         = LRU_SIZE,
        ttl              = max(opts.ttl     or 3600, 0),
        neg_ttl          = max(opts.neg_ttl or 300,  0),
        resurrect_ttl    = opts.resurrect_ttl or 30,
        resty_lock_opts  = opts.resty_lock_opts,
        ipc = { -- è¿›ç¨‹é—´é€šä¿¡çš„å‡½æ•°ç»‘å®š
          register_listeners = function(events)
            for _, event_t in pairs(events) do
              opts.worker_events.register(function(data)
                event_t.handler(data)
              end, channel_name, event_t.channel)
            end
          end,
          broadcast = function(channel, data)
            local ok, err = opts.worker_events.post(channel_name, channel, data)
            if not ok then
              log(ERR, "failed to post event '", channel_name, "', '",
                       channel, "': ", err)
            end
          end
        }
      })
      if not mlcache then
        return nil, "failed to instantiate mlcache: " .. err
      end
      mlcaches[i] = mlcache
      shm_names[i] = shm_name
    end
  end

  local curr_mlcache = 1

  if opts.cache_pages == 2 then
    curr_mlcache = ngx.shared.kong:get("kong:cache:" .. opts.shm_name .. ":curr_mlcache") or 1
  end

  local self          = {
    cluster_events    = opts.cluster_events,
    mlcache           = mlcaches[curr_mlcache],
    mlcaches          = mlcaches,
    shm_names         = shm_names,
    curr_mlcache      = curr_mlcache,
  }

  local ok, err = self.cluster_events:subscribe("invalidations", function(key)
    log(DEBUG, "received invalidate event from cluster for key: '", key, "'")
    self:invalidate_local(key)
  end)
  if not ok then
    return nil, "failed to subscribe to invalidations cluster events " ..
                "channel: " .. err
  end

  _init[opts.shm_name] = true

  return setmetatable(self, mt)
end
</code></pre>
<p>åˆå§‹åŒ–å®Œç¼“å­˜æ¨¡å—åï¼ŒWorker ä¼šæ ¹æ®é…ç½®æ–‡ä»¶ä¸­çš„ <code>db_cache_warmup_entities</code> åŠ è½½æŒ‡å®šçš„æ•°æ®åº“èµ„æºåˆ°å†…å­˜è¿›è¡Œç¼“å­˜ï¼Œé»˜è®¤é…ç½®ä¼šç¼“å­˜ <code>services, plugins</code>ã€‚</p>
<p><code>LRU_SIZE</code> å€¼ä¸º 500,000ï¼Œå•ä½æ˜¯ itemï¼Œè®¾ç½®æœ€å¤§èƒ½å‚¨å­˜çš„ item æ•°é‡ï¼Œè¿™ä¸ªå€¼è¡¨ç¤ºå•ä¸ª Worker LRU Cache æœ€å¤§å ç”¨ 500M å†…å­˜ã€‚</p>
<p>Worker ä¼šæ ¹æ®é…ç½®é¡¹åŠ è½½æ•°æ®åº“å®ä½“åˆ°å…±äº«å†…å­˜ç¼“å­˜ã€‚</p>
<pre><code class="language-lua">local function execute_cache_warmup(kong_config)
  if kong_config.database == "off" then
    return true
  end

  -- åªåœ¨ä¸€ä¸ª worker ä¸Šæ‰§è¡Œæ“ä½œ
  -- åŠ è½½æ•°æ®åº“å®ä½“åˆ°å…±äº«å†…å­˜ç¼“å­˜
  if ngx.worker.id() == 0 then
    local ok, err = cache_warmup.execute(kong_config.db_cache_warmup_entities)
    if not ok then
      return nil, err
    end
  end

  return true
end
</code></pre>
<p>è¿™é‡Œåªåœ¨ä¸€ä¸ª Worker è¿›ç¨‹ä¸ŠåŠ è½½æ•°æ®åº“æ•°æ®ï¼ŒéšååŒæ­¥åˆ°å…¶ä»–çš„ Worker ä¸Šã€‚</p>
<p><code>cache_warmup.execute()</code> é‡ŒåšåŸºæœ¬ä¿¡æ¯çš„æ£€æµ‹ï¼Œéšåè°ƒç”¨ <code>cache_warmup_single_entity(dao)</code> æ–¹æ³•ã€‚</p>
<pre><code class="language-lua">-- åŠ è½½æ•°æ®åº“å®ä½“åˆ°ç¼“å­˜ï¼Œä»¥å®ç°æ›´å¿«çš„è®¿é—®é€Ÿåº¦
-- åœ¨ Worker åˆå§‹åŒ–é˜¶æ®µè¿è¡Œ
-- é»˜è®¤åŠ è½½ service, plugins
-- å¤§å°å—é…ç½® mem_cache_size å½±å“
-- Loads entities from the database into the cache, for rapid subsequent
-- access. This function is intented to be used during worker initialization.
function cache_warmup.execute(entities)
  if not kong.cache or not kong.core_cache then
    return true
  end

  for _, entity_name in ipairs(entities) do
    if entity_name == "routes" then
      -- do not spend shm memory by caching individual Routes entries
      -- because the routes are kept in-memory by building the router object
      kong.log.notice("the 'routes' entry is ignored in the list of ",
                      "'db_cache_warmup_entities' because Kong ",
                      "caches routes in memory separately")
      goto continue
    end

    local dao = kong.db[entity_name]
    if not (type(dao) == "table" and dao.schema) then
      kong.log.warn(entity_name, " is not a valid entity name, please check ",
                    "the value of 'db_cache_warmup_entities'")
      goto continue
    end

    local ok, err = cache_warmup_single_entity(dao)
    if not ok then
      if err == "no memory" then
        kong.log.warn("cache warmup has been stopped because cache ",
                      "memory is exhausted, please consider increasing ",
                      "the value of 'mem_cache_size' (currently at ",
                      kong.configuration.mem_cache_size, ")")

        return true
      end
      return nil, err
    end

    ::continue::
  end

  return true
end
</code></pre>
<p>ä¸ç¼“å­˜ Routesï¼Œå› ä¸º Route å·²ç»åœ¨ä¸Šä¸€èŠ‚ä¸­æ„å»ºä¸ºè·¯ç”±ç´¢å¼•æ ‘ï¼Œé€šè¿‡ fork åˆ°æ‰€æœ‰çš„ Worker å†…å­˜é‡Œäº†ã€‚</p>
<pre><code class="language-lua">local function cache_warmup_single_entity(dao)
  local entity_name = dao.schema.name

  -- é€‰å®šå‚¨å­˜åœ°æ–¹ cache/core_cache
  local cache_store = constants.ENTITY_CACHE_STORE[entity_name]
  -- cache å…¨å±€å¯¹è±¡
  local cache = kong[cache_store]

  ngx.log(ngx.NOTICE, "Preloading '", entity_name, "' into the ", cache_store, "...")

  local start = ngx.now()

  local hosts_array, hosts_set, host_count
  if entity_name == "services" then
    hosts_array = {}
    hosts_set = {}
    host_count = 0
  end

  for entity, err in dao:each(nil, GLOBAL_QUERY_OPTS) do
    if err then
      return nil, err
    end

    if entity_name == "services" then
      if utils.hostname_type(entity.host) == "name"
         and hosts_set[entity.host] == nil then
        host_count = host_count + 1
        hosts_array[host_count] = entity.host
        hosts_set[entity.host] = true
      end
    end

    -- è·å– cache_key
    local cache_key = dao:cache_key(entity)

    -- è°ƒç”¨ mlcache çš„ safe_set æ–¹æ³•ï¼Œ
    -- å†…å­˜ä¸è¶³ä¼šæŠ¥é”™
    local ok, err = cache:safe_set(cache_key, entity)
    if not ok then
      return nil, err
    end
  end

  if entity_name == "services" and host_count > 0 then
    ngx.timer.at(0, warmup_dns, hosts_array, host_count)
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, "finished preloading '", entity_name,
                      "' into the ", cache_store, " (in ", tostring(elapsed), "ms)")
  return true
end
</code></pre>
<p><code>cache_warmup_single_entity()</code> ä¼šåŠ è½½è¯¥ dao æ‰€æœ‰çš„æ•°æ®åˆ°å†…å­˜ä¸­ï¼Œ<code>set</code> æ–¹æ³•ä¼šåˆ†å‘äº‹ä»¶åŒæ­¥æ•°æ®åˆ°å…¶ä»–çš„ Worker ä¸Šï¼Œæœ€ç»ˆæ¯ä¸ª Worker éƒ½ä¼šç¼“å­˜ä¸€ä»½ã€‚</p>
<h3>3.3. äº‹ä»¶è®¢é˜…</h3>
<p><code>Kong.init_worker()</code> ä¸­åˆå§‹åŒ– Worker äº‹ä»¶å’Œé›†ç¾¤äº‹ä»¶ã€‚</p>
<pre><code class="language-lua">  local worker_events, err = kong_global.init_worker_events()
  if not worker_events then
    stash_init_worker_error("failed to instantiate 'kong.worker_events' " ..
                            "module: " .. err)
    return
  end
  kong.worker_events = worker_events

  local cluster_events, err = kong_global.init_cluster_events(kong.configuration, kong.db)
  if not cluster_events then
    stash_init_worker_error("failed to instantiate 'kong.cluster_events' " ..
                            "module: " .. err)
    return
  end
  kong.cluster_events = cluster_events
</code></pre>
<p>Worker äº‹ä»¶å†…éƒ¨æ˜¯ä½¿ç”¨ <strong><a href="https://github.com/Kong/lua-resty-worker-events">lua-resty-worker-events</a></strong> åº“å®ç°çš„è¿›ç¨‹é—´äº‹ä»¶å¤„ç†ï¼ŒåŸç†æ˜¯é€šè¿‡å…±äº«å†…å­˜å‚¨å­˜äº‹ä»¶ï¼Œæ¯ç§’æ‹‰å–å…±äº«å†…å­˜ä¸­çš„äº‹ä»¶ï¼Œè¿›è¡Œå¤„ç†ã€‚</p>
<pre><code class="language-lua">function _GLOBAL.init_worker_events()
  -- Note: worker_events will not work correctly if required at the top of the file.
  --       It must be required right here, inside the init function
  local worker_events = require "resty.worker.events"

  local ok, err = worker_events.configure {
    shm = "kong_process_events", -- defined by "lua_shared_dict"
    timeout = 5,            -- life time of event data in shm
    interval = 1,           -- poll interval (seconds)

    wait_interval = 0.010,  -- wait before retry fetching event data
    wait_max = 0.5,         -- max wait time before discarding event
  }
  if not ok then
    return nil, err
  end

  return worker_events
end
</code></pre>
<p>é›†ç¾¤äº‹ä»¶ï¼ˆå¤šä¸ª Kong ä¹‹é—´çš„é€šä¿¡ï¼‰æ˜¯é€šè¿‡å°†äº‹ä»¶å‚¨å­˜åœ¨æ•°æ®åº“ä¸­ï¼Œå®šæ—¶è½®è¯¢æ•°æ®åº“æŸ¥è¯¢äº‹ä»¶ï¼Œè¿›è¡Œå¤„ç†ã€‚</p>
<pre><code class="language-lua">function _GLOBAL.init_cluster_events(kong_config, db)
  return kong_cluster_events.new({
    db            = db,
    poll_interval = kong_config.db_update_frequency,
    poll_offset   = kong_config.db_update_propagation,
    poll_delay    = kong_config.db_update_propagation,
  })
end
</code></pre>
<p>ä»è¿™é‡Œå¯ä»¥çœ‹åˆ°é›†ç¾¤äº‹ä»¶æ˜¯é€šè¿‡æ•°æ®åº“è¡¨å®ç°çš„ï¼š</p>
<pre><code class="language-lua">function _M:broadcast(channel, data, delay)
  if type(channel) ~= "string" then
    return nil, "channel must be a string"
  end

  if type(data) ~= "string" then
    return nil, "data must be a string"
  end

  if delay and type(delay) ~= "number" then
    return nil, "delay must be a number"

  elseif self.poll_delay > 0 then
    delay = self.poll_delay
  end

  -- insert event row

  --log(DEBUG, "broadcasting on channel: '", channel, "' data: ", data,
  --           " with delay: ", delay and delay or "none")

  local ok, err = self.strategy:insert(self.node_id, channel, nil, data, delay)
  if not ok then
    return nil, err
  end

  return true
end


function _M:subscribe(channel, cb, start_polling)
  if type(channel) ~= "string" then
    return error("channel must be a string")
  end

  if type(cb) ~= "function" then
    return error("callback must be a function")
  end

  if not self.callbacks[channel] then
    self.callbacks[channel] = { cb }

    insert(self.channels, channel)

  else
    insert(self.callbacks[channel], cb)
  end

  if start_polling == nil then
    start_polling = true
  end

  if not self.polling and start_polling and self.use_polling then
    -- start recurring polling timer

    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      return nil, "failed to start polling timer: " .. err
    end

    self.polling = true
  end

  return true
end
</code></pre>
<p>åœ¨ <code>cache.lua</code> ä¸­é›†ç¾¤äº‹ä»¶è®¢é˜… cache å¤±æ•ˆäº‹ä»¶ï¼Œå†…éƒ¨è°ƒç”¨ mlcache çš„ delete æ–¹æ³•ï¼ŒåŒæ­¥åˆ°æ‰€æœ‰çš„ Worker ä¸Šã€‚</p>
<pre><code class="language-lua">  local ok, err = self.cluster_events:subscribe("invalidations", function(key)
    log(DEBUG, "received invalidate event from cluster for key: '", key, "'")
    self:invalidate_local(key)
  end)


function _M:invalidate_local(key, shadow)
  if type(key) ~= "string" then
    error("key must be a string", 2)
  end

  log(DEBUG, "invalidating (local): '", key, "'")

  local current_page = self.curr_mlcache or 1
  local delete_page
  if shadow and #self.mlcaches == 2 then
    delete_page = current_page == 1 and 2 or 1
  else
    delete_page = current_page
  end

  local ok, err = self.mlcaches[delete_page]:delete(key)
  if not ok then
    log(ERR, "failed to delete entity from node cache: ", err)
  end
end
</code></pre>
<p>è¿™éƒ¨åˆ†ä¸»è¦æè¿° Kong åˆå§‹åŒ–è¿‡ç¨‹ä¸­çš„äº‹ä»¶ç›¸å…³æ“ä½œï¼Œä¸»è¦æ˜¯åˆå§‹åŒ–äº‹ä»¶è®¢é˜…ï¼Œå…³è”åˆ° mlcache çš„ IPC è¿›ç¨‹é—´é€šä¿¡ï¼Œè®¢é˜… cache çš„å¤±æ•ˆäº‹ä»¶ï¼Œå¹¶å…³è” DAO çš„äº‹ä»¶å‘å¸ƒã€‚</p>
<pre><code class="language-lua">function DB:set_events_handler(events)
  for _, dao in pairs(self.daos) do
    dao.events = events
  end
end
</code></pre>
<h2>4. äº‹ä»¶åˆ†å‘</h2>
<p>Kong ä¸­ä¼—å¤šéƒ¨åˆ†é€šè¿‡éé˜»å¡çš„ <code>ngx.timer.at()</code> å’Œ <code>ngx.timer.every()</code> å‡½æ•°æ‰§è¡Œå®šæ—¶ä»»åŠ¡ã€‚è¿™ä¸€éƒ¨åˆ†è¾ƒä¸ºåˆ†æ•£ï¼Œä¸»è¦å™è¿° Kong æ‰§è¡Œéé˜»å¡ä¸€æ¬¡æ€§äº‹ä»¶å¤„ç†ï¼Œå’Œå…¸å‹çš„å®šæ—¶ä»»åŠ¡ã€‚</p>
<h3>4.1. å•æ¬¡ä»»åŠ¡</h3>
<h4>4.1.1. DNS è§£æ</h4>
<p>åœ¨ <code>cache_warmup.lua</code> ä¸­ç¼“å­˜ services å¯¹è±¡æ—¶ï¼ŒKong ä¼šéé˜»å¡åœ°è·å– services ä¸­ host å¯¹åº”çš„ ipã€‚</p>
<pre><code class="language-lua">  if entity_name == "services" and host_count > 0 then
    ngx.timer.at(0, warmup_dns, hosts_array, host_count)
  end

local function warmup_dns(premature, hosts, count)
  if premature then
    return
  end

  ngx.log(ngx.NOTICE, "warming up DNS entries ...")

  local start = ngx.now()

  for i = 1, count do
    kong.dns.toip(hosts[i])
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, "finished warming up DNS entries",
                      "' into the cache (in ", tostring(elapsed), "ms)")
end
</code></pre>
<p>Kong å†…éƒ¨ dns æ¨¡å—ä½¿ç”¨ <strong><a href="https://github.com/Kong/lua-resty-dns-client">lua-resty-dns-client</a></strong>ï¼Œè¿™ä¸ªåº“ä¹Ÿæ˜¯ç”± Kong å¼€æºçš„ï¼Œç‰¹è‰²æœ‰ <code>toip</code> å‡½æ•°ä¼šæ ¹æ® dns è¿”å› ip çš„æƒé‡é…ç½®åŠ æƒè½®è¯¢çš„æƒé‡ï¼Œå‚¨å­˜ dns æŸ¥è¯¢çš„ç»“æœåœ¨å†…å­˜ä¸­ã€‚</p>
<p><code>warmup_dns()</code> å†…è°ƒç”¨ <code>kong.dns.toip()</code> æ–¹æ³•ï¼š</p>
<pre><code class="language-lua">local function warmup_dns(premature, hosts, count)
  if premature then
    return
  end

  ngx.log(ngx.NOTICE, "warming up DNS entries ...")

  local start = ngx.now()

  for i = 1, count do
    kong.dns.toip(hosts[i])
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, "finished warming up DNS entries",
                      "' into the cache (in ", tostring(elapsed), "ms)")
end
</code></pre>
<h3>4.2. å®šæ—¶ä»»åŠ¡</h3>
<h4>4.2.1. é›†ç¾¤ä»»åŠ¡</h4>
<p><code>cluster_events/init.lua</code> ä¸­é›†ç¾¤äº‹æƒ…è®¢é˜…å‡½æ•°é‡Œå¯ç”¨å®šæ—¶å™¨è½®è¯¢æ•°æ®åº“é›†ç¾¤äº‹ä»¶è¡¨ã€‚</p>
<pre><code class="language-lua">function _M:subscribe(channel, cb, start_polling)
  if type(channel) ~= "string" then
    return error("channel must be a string")
  end

  if type(cb) ~= "function" then
    return error("callback must be a function")
  end

  if not self.callbacks[channel] then
    self.callbacks[channel] = { cb }

    insert(self.channels, channel)

  else
    insert(self.callbacks[channel], cb)
  end

  if start_polling == nil then
    start_polling = true
  end

  if not self.polling and start_polling and self.use_polling then
    -- start recurring polling timer

    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      return nil, "failed to start polling timer: " .. err
    end

    self.polling = true
  end

  return true
end
</code></pre>
<p>è¿™é‡Œå› ä¸ºè¦åœ¨æ¯æ¬¡å¾ªç¯è°ƒç”¨æ—¶è¿›è¡Œé”çš„åˆ¤æ–­ï¼Œæ‰€ä»¥æ²¡æœ‰ä½¿ç”¨ <code>ngx.timer.every()</code> å‡½æ•°ï¼Œè€Œæ˜¯ç”¨æ— é™å¾ªç¯è°ƒç”¨ <code>ngx.timer.at()</code>ã€‚</p>
<pre><code class="language-lua">poll_handler = function(premature, self)
  if premature or not self.polling then
    -- set self.polling to false to stop a polling loop
    return
  end

  if not get_lock(self) then
    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      log(CRIT, "failed to start recurring polling timer: ", err)
    end

    return
  end

  -- single worker

  local pok, perr, err = pcall(poll, self)
  if not pok then
    log(ERR, "poll() threw an error: ", perr)

  elseif not perr then
    log(ERR, "failed to poll: ", err)
  end

  -- unlock

  self.shm:delete(POLL_RUNNING_LOCK_KEY)

  local ok, err = timer_at(self.poll_interval, poll_handler, self)
  if not ok then
    log(CRIT, "failed to start recurring polling timer: ", err)
  end
end
</code></pre>
<p>é”é€šè¿‡å…±äº«å†…å­˜äº‹ä»¶ï¼Œä¿è¯åªæœ‰ä¸€ä¸ª Worker æ‰§è¡Œå•æ¬¡ä»»åŠ¡ã€‚</p>
<pre><code class="language-lua">local function get_lock(self)
  -- check if a poll is not currently running, to ensure we don't start
  -- another poll while a worker is still stuck in its own polling (in
  -- case it is being slow)
  -- we still add an exptime to this lock in case something goes horribly
  -- wrong, to ensure other workers can poll new events
  -- a poll cannot take more than max(poll_interval * 5, 10) -- 10s min
  local ok, err = self.shm:safe_add(POLL_RUNNING_LOCK_KEY, true,
                                    max(self.poll_interval * 5, 10))
  if not ok then
    if err ~= "exists" then
      log(ERR, "failed to acquire poll_running lock: ", err)
    end
    -- else
    --   log(DEBUG, "failed to acquire poll_running lock: ",
    --              "a worker still holds the lock")

    return false
  end

  if self.poll_interval > 0.001 then
    -- check if interval of `poll_interval` has elapsed already, to ensure
    -- we do not run the poll when a previous poll was quickly executed, but
    -- another worker got the timer trigger a bit too late.
    ok, err = self.shm:safe_add(POLL_INTERVAL_LOCK_KEY, true,
                                self.poll_interval - 0.001)
    if not ok then
      if err ~= "exists" then
        log(ERR, "failed to acquire poll_interval lock: ", err)
      end
      -- else
      --   log(DEBUG, "failed to acquire poll_interval lock: ",
      --              "not enough time elapsed since last poll")

      self.shm:delete(POLL_RUNNING_LOCK_KEY)

      return false
    end
  end

  return true
end
</code></pre>
<h4>4.2.2. æ•°æ®åº“ TTL</h4>
<p>ä¸ºç»™ PostgreSQL åŠ ä¸Š TTLï¼ŒKong åœ¨ <code>init_worker</code> é˜¶æ®µè°ƒç”¨æ•°æ®åº“å±‚ <code>db/strategies/postgres/connector.lua</code> ä¸­ <code>init_worker()</code> å‡½æ•°ã€‚</p>
<pre><code class="language-lua">-- ä»¥ä¸‹çœç•¥éƒ¨åˆ†å†…å®¹ï¼Œåªå±•ç¤ºå…³é”®éƒ¨åˆ†
function _mt:init_worker(strategies)
  if ngx.worker.id() == 0 then

      cleanup_statements[i] = concat {
        "  DELETE FROM ",
        self:escape_identifier(table_name),
        " WHERE ",
        column_name,
        " &#x3C; CURRENT_TIMESTAMP AT TIME ZONE 'UTC';"
      }

    local cleanup_statement = concat(cleanup_statements, "\n")

    return timer_every(60, function(premature)

      local ok, err, _, num_queries = self:query(cleanup_statement)
      if not ok then
        if num_queries then
          for i = num_queries + 1, cleanup_statements_count do
            local statement = cleanup_statements[i]
            local ok, err = self:query(statement)
            if not ok then
              if err then
                log(WARN, "unable to clean expired rows from table '",
                          sorted_strategies[i], "' on PostgreSQL database (",
                          err, ")")
              else
                log(WARN, "unable to clean expired rows from table '",
                          sorted_strategies[i], "' on PostgreSQL database")
              end
            end
          end

        else
          log(ERR, "unable to clean expired rows from PostgreSQL database (", err, ")")
        end
      end
    end)
  end

  return true
end
</code></pre>
<p>æ•°æ®åº“åˆå§‹åŒ–æ—¶æ–°å¢ä¸€ä¸ª <code>timer</code>ï¼Œåœ¨åç¨‹ä¸­è°ƒç”¨å›è°ƒå‡½æ•°ï¼Œåˆ é™¤ TTL è¿‡æœŸçš„ rowsã€‚</p>
<h4>4.2.3. æ›´æ–°è·¯ç”±ç´¢å¼•</h4>
<p><code>kong.init_worker()</code> ä¼šæ·»åŠ å®šæ—¶ä»»åŠ¡ï¼Œå®šæ—¶æ›´æ–°ç¼“å­˜ã€‚</p>
<pre><code class="language-lua">      -- å®šæ—¶é‡å»ºè·¯ç”±ç¼“å­˜
      if kong.db.strategy ~= "off" then
        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          -- Don't wait for the semaphore (timeout = 0) when updating via the
          -- timer.
          -- If the semaphore is locked, that means that the rebuild is
          -- already ongoing.
          local ok, err = rebuild_router(ROUTER_ASYNC_OPTS)
          if not ok then
            log(ERR, "could not rebuild router via timer: ", err)
          end
        end)

        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          local ok, err = rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)
          if not ok then
            log(ERR, "could not rebuild plugins iterator via timer: ", err)
          end
        end)
      end
</code></pre>
<p>å®é™…è°ƒç”¨é¡ºåºæ˜¯å¼€ä¸€ä¸ª cosocket åç¨‹ï¼Œåˆ¤æ–­ routes æ˜¯å¦æœ‰å˜åŒ–ï¼Œå˜åŒ–åˆ™é‡æ„è·¯ç”±ç¼“å­˜ã€‚</p>
<pre><code class="language-lua">  rebuild_router = function(opts)
    return rebuild("router", update_router, router_version, opts)
  end

local function rebuild(name, callback, version, opts)
  local current_version, err = kong.core_cache:get(name .. ":version", TTL_ZERO,
                                                   utils.uuid)
  if err then
    return nil, "failed to retrieve " .. name .. " version: " .. err
  end

  if current_version == version then
    return true
  end

  -- å¼€ä¸€ä¸ª cosocket åç¨‹è°ƒç”¨ callback
  return concurrency.with_coroutine_mutex(opts, callback)
end

  update_router = function()
    -- we might not need to rebuild the router (if we were not
    -- the first request in this process to enter this code path)
    -- check again and rebuild only if necessary
    local version, err = get_router_version()
    if err then
      return nil, "failed to retrieve router version: " .. err
    end

    if version == router_version then
      return true
    end

    local ok, err = build_router(version)
    if not ok then
      return nil, --[[ 'err' fully formatted ]] err
    end

    return true
  end
</code></pre>
<p>æœ€ç»ˆè¿˜ä¼šè°ƒç”¨åˆ° <code>build_router()</code> æ–¹æ³•ï¼Œæˆ‘ä»¬å·²ç»åœ¨ 1.2.1 ä¸­æè¿°è¿‡ã€‚</p>
<h2>5. äº‹ä»¶å¤„ç†</h2>
<p>Worker é—´çš„äº‹ä»¶å¤„ç†ä½¿ç”¨ <code>lua-resty-worker-events</code> åº“ã€‚</p>
<p>äº‹ä»¶è®¢é˜…å‡½æ•°ï¼š<code>events.register(callback, source, event1, event2, ...)</code>ï¼Œcallback æ–¹æ³• <code>callback = function(data, event, source, pid)</code>ã€‚</p>
<p>äº‹ä»¶å‘å¸ƒå‡½æ•°ï¼š<code>success, err = events.post(source, event, data, unique)</code></p>
<h3>5.1. æ•°æ®åº“äº‹ä»¶</h3>
<p><code>db/dao/init.lua</code> ä¸­å®šä¹‰äº† DAO ç›¸å…³çš„æ“ä½œæ–¹æ³•ï¼Œæˆ‘å·²ç»åœ¨ 1.1.3 ä¸­ç®€å•é˜è¿°è¿‡äº†ã€‚</p>
<p>æ•°æ®åº“ç›¸å…³å®ä½“çš„ CRUDï¼ˆå…¶å®æ²¡æœ‰Rï¼‰äº‹ä»¶æœ€åä¼šè°ƒç”¨ <code>DAO:post_crud_event()</code> æ–¹æ³•å¹¿æ’­äº‹ä»¶ã€‚</p>
<pre><code class="language-lua">function DAO:post_crud_event(operation, entity, old_entity, options)
  if options and options.no_broadcast_crud_event then
    return
  end

  if self.events then
    local entity_without_nulls
    if entity then
      entity_without_nulls = remove_nulls(utils.deep_copy(entity, false))
    end

    local old_entity_without_nulls
    if old_entity then
      old_entity_without_nulls = remove_nulls(utils.deep_copy(old_entity, false))
    end

    local ok, err = self.events.post_local("dao:crud", operation, {
      operation  = operation,
      schema     = self.schema,
      entity     = entity_without_nulls,
      old_entity = old_entity_without_nulls,
    })
    if not ok then
      log(ERR, "[db] failed to propagate CRUD operation: ", err)
    end
  end
end
</code></pre>
<p>åœ¨ <code>dao:crud</code> é€šé“å‘å¸ƒäº†ä¸€ä¸ªäº‹ä»¶ï¼Œoperation ç±»å‹æœ‰ createã€updateã€deleteã€‚</p>
<p><code>runloop/handler.lua</code> ä¸­ <code>register_events()</code> ä¼šåœ¨ <code>kong.init_worker()</code> ä¸­è¢«è°ƒç”¨ï¼Œæ­¤æ—¶ä¼šè®¢é˜…æ•°æ®åº“ç›¸å…³äº‹ä»¶ï¼Œæ·»åŠ å¤„ç†å‡½æ•°ã€‚</p>
<pre><code class="language-lua">  worker_events.register(function(data)
    if not data.schema then
      log(ERR, "[events] missing schema in crud subscriber")
      return
    end

    if not data.entity then
      log(ERR, "[events] missing entity in crud subscriber")
      return
    end

    -- invalidate this entity anywhere it is cached if it has a
    -- caching key
    -- å¦‚æœ entity æœ‰ cache_key åˆ™è®©å®ƒå¤±æ•ˆ
    -- åŸºæœ¬ä¸Šä¹Ÿåªæœ‰ entity schema å®šä¹‰å‡ºé”™çš„æƒ…å†µä¸‹æ‰ä¸ä¼šæœ‰ cache_key

    local cache_key = db[data.schema.name]:cache_key(data.entity)
    local cache_obj = kong[constants.ENTITY_CACHE_STORE[data.schema.name]]

    if cache_key then
      cache_obj:invalidate(cache_key)
    end

    -- if we had an update, but the cache key was part of what was updated,
    -- we need to invalidate the previous entity as well

    if data.old_entity then
      local old_cache_key = db[data.schema.name]:cache_key(data.old_entity)
      if old_cache_key and cache_key ~= old_cache_key then
        cache_obj:invalidate(old_cache_key)
      end
    end

    if not data.operation then
      log(ERR, "[events] missing operation in crud subscriber")
      return
    end

    -- public worker events propagation

    -- è·å– schema åå­—
    local entity_channel           = data.schema.table or data.schema.name
    local entity_operation_channel = fmt("%s:%s", entity_channel,
      data.operation)

    -- crud:routes
    local ok, err = worker_events.post_local("crud", entity_channel, data)
    if not ok then
      log(ERR, "[events] could not broadcast crud event: ", err)
      return
    end

    -- crud:routes:create
    ok, err = worker_events.post_local("crud", entity_operation_channel, data)
    if not ok then
      log(ERR, "[events] could not broadcast crud event: ", err)
      return
    end
  end, "dao:crud")
</code></pre>
<p>CRUDï¼ˆæ²¡æœ‰ Rï¼‰äº‹ä»¶å¤„ç†æµç¨‹ï¼šè°ƒç”¨ <code>cache:invalidate()</code> æ–¹æ³•ï¼Œæ–¹æ³•å†…éƒ¨å‘å¸ƒäº†ä¸€ä¸ª worker çº§äº‹ä»¶ï¼Œé€šçŸ¥ worker è¿›ç¨‹åˆ é™¤è¯¥æ•°æ®ï¼Œè¿˜ä¼šå‘å¸ƒä¸€ä¸ªé›†ç¾¤äº‹ä»¶ï¼Œåœ¨é›†ç¾¤é—´åŒæ­¥åˆ é™¤æ•°æ®ã€‚</p>
<pre><code class="language-lua">  -- ä¿®æ”¹äº† Routes åä¼šæ¸…ç©º router:version ç¼“å­˜ï¼Œ
  -- ä¼šå¯¼è‡´é‡æ–°æ„å»ºè·¯ç”±è¡¨ï¼Œè¯¦æƒ…æŸ¥çœ‹ 2.2.3
  worker_events.register(function()
    log(DEBUG, "[events] Route updated, invalidating router")
    core_cache:invalidate("router:version")
  end, "crud", "routes")

...å…¶ä»–å¯¹è±¡åŒç†
</code></pre>
<h2>6. æ’ä»¶åŠ è½½</h2>
<h3>6.1. æ’ä»¶è¯»å–</h3>
<p><code>init</code> é˜¶æ®µä¼šåŠ è½½é…ç½®æ–‡ä»¶ä¸­ <code>plugins=bundled,skywalking-intergrator</code> çš„æ’ä»¶åˆ—è¡¨ï¼Œè°ƒç”¨ Lua <code>require</code> åŠ è½½å¯¹åº”çš„åŒ…ã€‚ï¼ˆæ‰€æœ‰çš„æ’ä»¶åŒ…éƒ½è¦æ±‚åœ¨ <code>kong.plugins</code> ä¸‹ï¼‰</p>
<pre><code class="language-lua">function Plugins:load_plugin_schemas(plugin_set)
  self.handlers = nil

  local go_plugins_cnt = 0
  local handlers = {}
  local errs

  -- load installed plugins
  for plugin in pairs(plugin_set) do
    local handler, err = load_plugin(self, plugin)

    if handler then
      if type(handler.is) == "function" and handler:is(BasePlugin) then
        -- Backwards-compatibility for 0.x and 1.x plugins inheriting from the
        -- BasePlugin class.
        -- TODO: deprecate &#x26; remove
        handler = handler()
      end

      if handler._go then
        go_plugins_cnt = go_plugins_cnt + 1
      end

      handlers[plugin] = handler

    else
      errs = errs or {}
      table.insert(errs, "on plugin '" .. plugin .. "': " .. tostring(err))
    end
  end

  if errs then
    return nil, "error loading plugin schemas: " .. table.concat(errs, "; ")
  end

  reports.add_immutable_value("go_plugins_cnt", go_plugins_cnt)

  self.handlers = handlers

  return true
end
</code></pre>
<p>æ‰€æœ‰æ’ä»¶çš„ Handler å‡½æ•°ä¼šè¢«å‚¨å­˜åœ¨ <code>kong.db.plugins.handlers</code>ï¼Œæ•°æ®æ ¼å¼ä¸º <code>{plugin_name: handler}</code>ã€‚</p>
<p>æ‰€æœ‰çš„æ’ä»¶ä¼šå‚¨å­˜åˆ° Worker è¿›ç¨‹ä¸Šï¼Œå‘¨æœŸæ€§è¿›è¡ŒåŒæ­¥æ›´æ–°ã€‚</p>
<p>æˆ‘æ•´ç†äº†æ’ä»¶è¡¨åŠ è½½åˆ° Lua table çš„ç»“æ„ï¼Œè¾“å‡ºæˆ YAMLï¼Œæ–¹ä¾¿ç†è§£ï¼š</p>
<pre><code class="language-yaml">map:
  plugin_name: true

combos:
  plugin_name:
    # both: {}
    both:
      route_id: service_id
    # routes: {}
    routes:
      route_id: true
    # services: {}
    services:
      service_id: true
    0: true # å…¨å±€æ’ä»¶
    1: true # è·¯ç”±æ’ä»¶
    2: true # Service æ’ä»¶
    3: true # è·¯ç”±+Service
    4: true # Consumer æ’ä»¶
    5: true # è·¯ç”±+Consumer æ’ä»¶
    6: true # è·¯ç”±+Service+Consumer æ’ä»¶

loaded:
  plugin_name:
    handler:
      phase_name: func()
</code></pre>
<h3>6.2. æ’ä»¶è°ƒç”¨</h3>
<p>æ’ä»¶ä¸ç›´æ¥å’Œè·¯ç”±è¿›è¡Œç»‘å®šï¼Œæ’ä»¶æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œå’Œ Kong çš„ç”Ÿå‘½å‘¨æœŸåŸºæœ¬ç›¸åŒã€‚åœ¨ Kong ç”Ÿå‘½å‘¨æœŸçš„å„ä¸ªé˜¶æ®µä¼šè°ƒç”¨æ’ä»¶çš„å¯¹åº”æ–¹æ³•ã€‚</p>
<p>æ’ä»¶åªåœ¨è°ƒç”¨é˜¶æ®µè¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦å…³è”å½“å‰ Routeã€Serviceã€å’Œ Consumerï¼Œæœ‰åˆ™ä»æ•°æ®åº“è¯»å–æ’ä»¶å…³è”çš„é…ç½®é¡¹ï¼ˆæ’ä»¶ Entityï¼‰ï¼Œå¹¶ä½¿ç”¨ <code>kong.core_cache</code> è¿›è¡Œç¼“å­˜ã€‚</p>
<pre><code class="language-lua">local function load_configuration_through_combos(ctx, combos, plugin)
  local plugin_configuration
  local name = plugin.name

  local route    = ctx.route
  local service  = ctx.service
  local consumer = ctx.authenticated_consumer

  if route and plugin.no_route then
    route = nil
  end
  if service and plugin.no_service then
    service = nil
  end
  if consumer and plugin.no_consumer then
    consumer = nil
  end

  local    route_id = route    and    route.id or nil
  local  service_id = service  and  service.id or nil
  local consumer_id = consumer and consumer.id or nil

  if kong.db.strategy == "off" then
	...
  else
    if route_id and service_id and consumer_id and combos[COMBO_RSC]
      and combos.both[route_id] == service_id
    then
      plugin_configuration = load_configuration(ctx, name, route_id, service_id,
                                                consumer_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    if consumer_id and combos[COMBO_C] then
      plugin_configuration = load_configuration(ctx, name, nil, nil, consumer_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    if route_id and combos[COMBO_R] and combos.routes[route_id] then
      plugin_configuration = load_configuration(ctx, name, route_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    ...

    if combos[COMBO_GLOBAL] then
      return load_configuration(ctx, name)
    end
  end
end
</code></pre>
<p>è¿™é‡Œä¼šæŸ¥è¯¢å½“å‰ Serviceã€Route å’Œ Consumer æ˜¯å¦ä¸æŸä¸ªæ’ä»¶é…å¯¹ï¼ŒæˆåŠŸåˆ™åŠ è½½å¯¹åº”çš„é…ç½®é¡¹ï¼š</p>
<pre><code class="language-lua">--- Load the configuration for a plugin entry.
-- Given a Route, Service, Consumer and a plugin name, retrieve the plugin's
-- configuration if it exists. Results are cached in ngx.dict
-- @param[type=string] name Name of the plugin being tested for configuration.
-- @param[type=string] route_id Id of the route being proxied.
-- @param[type=string] service_id Id of the service being proxied.
-- @param[type=string] consumer_id Id of the donsumer making the request (if any).
-- @treturn table Plugin configuration, if retrieved.
local function load_configuration(ctx,
                                  name,
                                  route_id,
                                  service_id,
                                  consumer_id)
  local ws_id = workspaces.get_workspace_id() or kong.default_workspace
  local key = kong.db.plugins:cache_key(name,
                                        route_id,
                                        service_id,
                                        consumer_id,
                                        nil,
                                        ws_id)
  local plugin, err = kong.core_cache:get(key,
                                          nil,
                                          load_plugin_from_db,
                                          key)
  if err then
    ctx.delay_response = false
    ngx.log(ngx.ERR, tostring(err))
    return ngx.exit(ngx.ERROR)
  end

  if not plugin or not plugin.enabled then
    return
  end

  local cfg = plugin.config or {}

  if not cfg.__key__ then
    cfg.__key__ = key
    cfg.__seq__ = next_seq
    next_seq = next_seq + 1
  end

  cfg.route_id    = plugin.route and plugin.route.id
  cfg.service_id  = plugin.service and plugin.service.id
  cfg.consumer_id = plugin.consumer and plugin.consumer.id

  return cfg
end
</code></pre>
<p>æ’ä»¶çš„è°ƒç”¨æœ‰ä¸¤ç§æ–¹å¼ï¼š</p>
<ol>
<li>åŒæ­¥è°ƒç”¨</li>
<li>å¼‚æ­¥è°ƒç”¨</li>
</ol>
<p>é™¤äº† <code>access_by_lua</code> é˜¶æ®µï¼Œéƒ½æ˜¯ä½¿ç”¨åŒæ­¥è°ƒç”¨ï¼š</p>
<pre><code class="language-lua">local function execute_plugins_iterator(plugins_iterator, phase, ctx)
  local old_ws = ctx and ctx.workspace
  for plugin, configuration in plugins_iterator:iterate(phase, ctx) do
    if ctx then
      if plugin.handler._go then
        ctx.ran_go_plugin = true
      end

      kong_global.set_named_ctx(kong, "plugin", plugin.handler)
    end

    kong_global.set_namespaced_log(kong, plugin.name)
    -- è¿™é‡Œæ˜¯åŒæ­¥è°ƒç”¨
    plugin.handler[phase](plugin.handler, configuration)
    kong_global.reset_log(kong)

    if ctx then
      ctx.workspace = old_ws
    end
  end
end
</code></pre>
<p>è€Œåœ¨ <code>access_by_lua</code> é˜¶æ®µï¼Œä½¿ç”¨åç¨‹å¼‚æ­¥è°ƒç”¨ï¼š</p>
<pre><code class="language-lua">  for plugin, plugin_conf in plugins_iterator:iterate("access", ctx) do
    if plugin.handler._go then
      ctx.ran_go_plugin = true
    end

    if not ctx.delayed_response then
      kong_global.set_named_ctx(kong, "plugin", plugin.handler)
      kong_global.set_namespaced_log(kong, plugin.name)

      -- ä½¿ç”¨ Lua coroutine å¼€å¯åç¨‹å¼‚æ­¥è°ƒç”¨æ’ä»¶å‡½æ•°
      local err = coroutine.wrap(plugin.handler.access)(plugin.handler, plugin_conf)
      if err then
        kong.log.err(err)
        ctx.delayed_response = {
          status_code = 500,
          content     = { message  = "An unexpected error occurred" },
        }
      end

      kong_global.reset_log(kong)
    end
    ctx.workspace = old_ws
  end
</code></pre>
<h2>7. ç¼“å­˜æœºåˆ¶</h2>
<p>æœ¬èŠ‚æ ¹æ®æˆ‘å¯¹ Kong æºç çš„åˆ†æï¼Œåšä¸€ä¸ªç¼“å­˜æœºåˆ¶çš„å°å›é¡¾ã€‚</p>
<p>Kong é’ˆå¯¹ç¼“å­˜æœ‰è¿™äº›æ“ä½œï¼š</p>
<ul>
<li>åˆå§‹åŒ–ç¼“å­˜å—</li>
<li>é¢„è½½åŠ è½½æ•°æ®åº“å†…å®¹åˆ°ç¼“å­˜</li>
<li>è®¿é—®æ—¶æ‰åŠ è½½çš„æ•°æ®å†…å®¹æ·»åŠ åˆ°ç¼“å­˜</li>
<li>timer å®šæ—¶æ›´æ–°ç¼“å­˜</li>
<li>æ•°æ®åº“ CRUD æ“ä½œåˆ é™¤ç¼“å­˜</li>
<li>é›†ç¾¤/Worker é—´åŒæ­¥ç¼“å­˜</li>
</ul>
<p>ç¼“å­˜åŠ è½½å†…å®¹ï¼š</p>
<p>é»˜è®¤é…ç½®ä¸‹ï¼ŒKong å°†è·¯ç”±è¡¨å’Œ Routes å…¨é‡åŠ è½½åˆ°æ¯ä¸ª Worker çš„å†…å­˜ï¼ŒServices å’Œ Plugins å…¨é‡åŠ è½½åˆ°æ¯ä¸ª Worker çš„å†…å­˜å’Œå…±äº«å†…å­˜ä¸­ã€‚Upstreams å’Œ Targets æ ¹æ®è´Ÿè½½å‡è¡¡å™¨çš„è§£æåŠæ—¶ä»æ•°æ®åº“è·å–ï¼ŒåŠ è½½åˆ°å†…å­˜å’Œå…±äº«å†…å­˜ä¸­ã€‚</p>
<p>ä¸Šè¿° Entity åŠ è½½åœ¨ç”± mlcache åº“åˆ›å»ºçš„ L1+L2 ä¸¤çº§ç¼“å­˜ <code>core_cache</code> ä¸­ã€‚</p>
<p>è€Œ consumers åŠ è½½åˆ°åŒä¸º mlcache åˆ›å»ºçš„ä¸åŒåçš„ <code>cache</code> ä¸­ã€‚</p>
<h2>8. è¯·æ±‚ç”Ÿå‘½å‘¨æœŸ</h2>
<p>æœ¬èŠ‚è®²è¿°ä¸€ä¸ªè¯·æ±‚ç»è¿‡ Kong å¤„ç†çš„æµç¨‹ã€‚</p>
<h3>8.1. ssl_certificate_by_lua é˜¶æ®µ</h3>
<pre><code class="language-lua">local function execute()
  local sn, err = server_name()
  if err then
    log(ERR, "could not retrieve SNI: ", err)
    return ngx.exit(ngx.ERROR)
  end

  local cert_and_key, err = find_certificate(sn)
  if err then
    log(ERR, err)
    return ngx.exit(ngx.ERROR)
  end

  if cert_and_key == default_cert_and_key then
    -- use (already set) fallback certificate
    return
  end

  -- set the certificate for this connection

  local ok, err = clear_certs()
  if not ok then
    log(ERR, "could not clear existing (default) certificates: ", err)
    return ngx.exit(ngx.ERROR)
  end

  ok, err = set_cert(cert_and_key.cert)
  if not ok then
    log(ERR, "could not set configured certificate: ", err)
    return ngx.exit(ngx.ERROR)
  end

  ok, err = set_priv_key(cert_and_key.key)
  if not ok then
    log(ERR, "could not set configured private key: ", err)
    return ngx.exit(ngx.ERROR)
  end
end
</code></pre>
<p>æ ¹æ® Server Name æŸ¥æ‰¾å¯¹åº” SSL è¯ä¹¦ Cert å’Œç§é’¥å¹¶è®¾ç½®åœ¨ Nginx ä¸Šã€‚</p>
<h3>8.2. rewrite_by_lua é˜¶æ®µ</h3>
<pre><code class="language-lua">  local ctx = ngx.ctx
  if not ctx.KONG_PROCESSING_START then
    ctx.KONG_PROCESSING_START = ngx.req.start_time() * 1000
  end

  if not ctx.KONG_REWRITE_START then
    ctx.KONG_REWRITE_START = get_now_ms()
  end

  kong_global.set_phase(kong, PHASES.rewrite)
  kong_resty_ctx.stash_ref()

  local is_https = var.https == "on"
  if not is_https then
    log_init_worker_errors(ctx)
  end

  runloop.rewrite.before(ctx)

...

  rewrite = {
    before = function(ctx)
      ctx.host_port = HOST_PORTS[var.server_port] or var.server_port

      -- special handling for proxy-authorization and te headers in case
      -- the plugin(s) want to specify them (store the original)
      ctx.http_proxy_authorization = var.http_proxy_authorization
      ctx.http_te                  = var.http_te
    end,
  },
</code></pre>
<p>åˆå§‹åŒ– <code>kong.ctx</code> ç”Ÿå‘½å‘¨æœŸ Contextï¼Œä¸º Context æ·»åŠ è¯·æ±‚ä¿¡æ¯ã€‚</p>
<h3>8.3. access_by_lua é˜¶æ®µ</h3>
<h4>8.3.1. è·¯ç”±åŒ¹é…</h4>
<p><code>runloop.access.before</code> ä¼šè¿›è¡Œè°ƒç”¨ <code>Router</code> å®ä¾‹è¿›è¡Œè·¯ç”±åŒ¹é…ã€‚é¦–å…ˆä¼šè°ƒç”¨ <code>get_updated_router()</code> åˆ¤æ–­æ˜¯å¦æœ‰è·¯ç”±æ›´æ–°ï¼Œæ²¡æœ‰åˆ™è¿”å›å½“å‰ <code>Router</code> å®ä¾‹ã€‚</p>
<pre><code class="language-lua">      -- routing request
      local router = get_updated_router()
	  -- è°ƒç”¨ Router.exec() æŸ¥æ‰¾åŒ¹é…çš„è·¯ç”±
      local match_t = router.exec()
      if not match_t then
        return kong.response.exit(404, { message = "no Route matched with those values" })
      end
</code></pre>
<p><code>Router.exec()</code> æ–¹æ³•æœ€ç»ˆä¼šè°ƒç”¨ <code>Router.find_route()</code> æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æ¥æ”¶è¯·æ±‚å¤´å­—æ®µï¼Œå¹¶ç”Ÿæˆè·¯ç”± Cache Keyï¼ŒæŸ¥æ‰¾å¯¹åº”çš„é¡¹ç›®ã€‚</p>
<pre><code class="language-lua">  local function find_route(req_method, req_uri, req_host, req_scheme,
                            src_ip, src_port,
                            dst_ip, dst_port,
                            sni, req_headers)

    req_method = req_method or ""
    req_uri = req_uri or ""
    req_host = req_host or ""
    req_headers = req_headers or EMPTY_T

    ctx.req_method     = req_method
    ctx.req_uri        = req_uri
    ctx.req_host       = req_host
    ctx.req_headers    = req_headers
    ctx.src_ip         = src_ip or ""
    ctx.src_port       = src_port or ""
    ctx.dst_ip         = dst_ip or ""
    ctx.dst_port       = dst_port or ""
    ctx.sni            = sni or ""

    local cache_key = req_method .. "|" .. req_uri .. "|" .. req_host ..
                      "|" .. ctx.src_ip .. "|" .. ctx.src_port ..
                      "|" .. ctx.dst_ip .. "|" .. ctx.dst_port ..
                      "|" .. ctx.sni

    do
      local match_t = cache:get(cache_key)
      if match_t and hits.header_name == nil then
        return match_t
      end
    end
</code></pre>
<p>å¦‚æœ LRU ç¼“å­˜ä¸­æœ‰åŒ¹é…è·¯ç”±ï¼Œåˆ™ç›´æ¥è¿”å›ã€‚</p>
<p>å¦åˆ™ç»§ç»­åŒ¹é…è·¯ç”±ï¼Œç”ŸæˆåŒ¹é…é¡¹ç›®ï¼Œå¹¶å­˜å…¥ç¼“å­˜ä¸­ã€‚</p>
<pre><code class="language-lua">              ...
              local match_t     = {
                  route           = matched_route.route,
                  service         = matched_route.service,
                  headers         = matched_route.headers,
                  upstream_url_t  = upstream_url_t,
                  upstream_scheme = upstream_url_t.scheme,
                  upstream_uri    = upstream_uri,
                  upstream_host   = upstream_host,
                  prefix          = request_prefix,
                  matches         = {
                    uri_captures  = matches.uri_captures,
                    uri           = matches.uri,
                    host          = matches.host,
                    headers       = matches.headers,
                    method        = matches.method,
                    src_ip        = matches.src_ip,
                    src_port      = matches.src_port,
                    dst_ip        = matches.dst_ip,
                    dst_port      = matches.dst_port,
                    sni           = matches.sni,
                  }
                }

                if band(matched_route.match_rules, MATCH_RULES.HEADER) == 0 then
                  cache:set(cache_key, match_t)
                end
                ...
</code></pre>
<p>åŒ¹é…æˆåŠŸåä¼šå°†å…³è”çš„ Route å’Œ Service å†™å…¥ <code>ngx.ctx</code> ï¼Œåœ¨æ¥ä¸‹æ¥çš„ç”Ÿå‘½å‘¨æœŸä¸­å…±äº«ã€‚</p>
<h4>8.3.2. è¯·æ±‚è°ƒåº¦</h4>
<p><code>runloop.access.after</code> ä¸­æ ¹æ® Routeã€Service ç­‰æ¡ä»¶è§£æå‡ºåç«¯è¦è¯·æ±‚çš„ IPã€Portã€Schema ç­‰å‚æ•°ã€‚</p>
<pre><code class="language-lua">-- looks up a balancer for the target.
-- @param target the table with the target details
-- @param no_create (optional) if true, do not attempt to create
-- (for thorough testing purposes)
-- @return balancer if found, `false` if not found, or nil+error on error
local function get_balancer(target, no_create)
  -- NOTE: only called upon first lookup, so `cache_only` limitations
  -- do not apply here
  local hostname = target.host


  -- first go and find the upstream object, from cache or the db
  local upstream, err = get_upstream_by_name(hostname)
  if upstream == false then
    return false -- no upstream by this name
  end
  if err then
    return nil, err -- there was an error
  end

  local balancer = balancers[upstream.id]
  if not balancer then
    if no_create then
      return nil, "balancer not found"
    else
      log(ERR, "balancer not found for ", upstream.name, ", will create it")
      return create_balancer(upstream), upstream
    end
  end

  return balancer, upstream
end
</code></pre>
<p><code>get_balancer()</code> æ ¹æ® Service çš„ Host è¿”å›æœ€ç»ˆè¯·æ±‚çš„ Targetï¼Œå’Œè´Ÿè½½å‡è¡¡å™¨ã€‚</p>
<pre><code class="language-lua">  local ip, port, hostname, handle
  if balancer then
    -- have to invoke the ring-balancer
    local hstate = run_hook("balancer:get_peer:pre", target.host)
    ip, port, hostname, handle = balancer:getPeer(dns_cache_only,
                                          target.balancer_handle,
                                          hash_value)
    run_hook("balancer:get_peer:post", hstate)
    if not ip and
      (port == "No peers are available" or port == "Balancer is unhealthy") then
      return nil, "failure to get a peer from the ring-balancer", 503
    end
    hostname = hostname or ip
    target.hash_value = hash_value
    target.balancer_handle = handle

  else
    -- have to do a regular DNS lookup
    local try_list
    local hstate = run_hook("balancer:to_ip:pre", target.host)
    ip, port, try_list = toip(target.host, target.port, dns_cache_only)
    run_hook("balancer:to_ip:post", hstate)
    hostname = target.host
    if not ip then
      log(ERR, "DNS resolution failed: ", port, ". Tried: ", tostring(try_list))
      if port == "dns server error: 3 name error" or
         port == "dns client error: 101 empty record received" then
        return nil, "name resolution failed", 503
      end
    end
  end
</code></pre>
<p>è°ƒç”¨è´Ÿè½½å‡è¡¡å™¨çš„ç­–ç•¥è·å– Target çš„ IPï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨ DNS æŸ¥è¯¢è·å– IP åœ°å€ï¼Œè¿™ä¸€æ­¥åœ¨ 2.1.1 ä¸­å·²ç»æå‰è¿›è¡Œäº† DNS é¢„ç¼“å­˜ï¼Œè¿™é‡Œå¯ä»¥ä»ç¼“å­˜ä¸­è¯»å–ã€‚</p>
<p>å¦‚æœ Service Host ç›´æ¥æ˜¯ IP åœ°å€ï¼Œåˆ™ä¸æ‰§è¡Œè´Ÿè½½å‡è¡¡ç­–ç•¥ã€‚</p>
<pre><code class="language-lua">  -- ip åˆ™ç›´æ¥è¿”å›
  if target.type ~= "name" then
    -- it's an ip address (v4 or v6), so nothing we can do...
    target.ip = target.host
    target.port = target.port or 80 -- TODO: remove this fallback value
    target.hostname = target.host
    return true
  end
</code></pre>
<h3>8.4. balancer_by_lua é˜¶æ®µ</h3>
<p>ä½¿ç”¨ <code>ngx.balancer.set_more_tries()</code> è®¾ç½®é”™è¯¯é‡è¯•æ¬¡æ•°ï¼Œä½¿ç”¨ <code>ngx.balancer.get_last_failure()</code> è·å–ä¸Šä¸€æ¬¡è¯·æ±‚é”™è¯¯è¯¦æƒ…ï¼Œåœ¨é”™è¯¯å¤„ç†ä¸­è¿›è¡Œå¯¹ä¸Šæ¸¸èŠ‚ç‚¹è¿›è¡Œè¢«åŠ¨å¥åº·æ£€æŸ¥ã€‚</p>
<pre><code class="language-lua">  if balancer_data.try_count > 1 then
    -- only call balancer on retry, first one is done in `runloop.access.after`
    -- which runs in the ACCESS context and hence has less limitations than
    -- this BALANCER context where the retries are executed

    -- record failure data
    local previous_try = tries[balancer_data.try_count - 1]
    previous_try.state, previous_try.code = get_last_failure()

    -- Report HTTP status for health checks
    local balancer = balancer_data.balancer
    if balancer then
      if previous_try.state == "failed" then
        if previous_try.code == 504 then
          balancer.report_timeout(balancer_data.balancer_handle)
        else
          balancer.report_tcp_failure(balancer_data.balancer_handle)
        end

      else
        balancer.report_http_status(balancer_data.balancer_handle,
                                    previous_try.code)
      end
    end

    local ok, err, errcode = balancer_execute(balancer_data)
    if not ok then
      ngx_log(ngx_ERR, "failed to retry the dns/balancer resolver for ",
              tostring(balancer_data.host), "' with: ", tostring(err))

      ctx.KONG_BALANCER_ENDED_AT = get_now_ms()
      ctx.KONG_BALANCER_TIME = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_BALANCER_START
      ctx.KONG_PROXY_LATENCY = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_PROCESSING_START

      return ngx.exit(errcode)
    end

  else
    -- first try, so set the max number of retries
    local retries = balancer_data.retries
    if retries > 0 then
      set_more_tries(retries)
    end
  end
</code></pre>
<p>è¯·æ±‚åˆ°æœ€ç»ˆè§£æçš„åç«¯æœåŠ¡ï¼Œä½¿ç”¨ <code>ngx.balancer.set_current_peer()</code> æ–¹æ³•è®¾ç½®è®¿é—®çš„åœ°å€ã€‚</p>
<pre><code class="language-lua">  -- set the targets as resolved
  ngx_log(ngx_DEBUG, "setting address (try ", balancer_data.try_count, "): ",
                     balancer_data.ip, ":", balancer_data.port)
  -- æœ€ç»ˆè°ƒåº¦çš„åœ°å€
  local ok, err = set_current_peer(balancer_data.ip, balancer_data.port, pool_opts)
  if not ok then
    ngx_log(ngx_ERR, "failed to set the current peer (address: ",
            tostring(balancer_data.ip), " port: ", tostring(balancer_data.port),
            "): ", tostring(err))

    ctx.KONG_BALANCER_ENDED_AT = get_now_ms()
    ctx.KONG_BALANCER_TIME = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_BALANCER_START
    ctx.KONG_PROXY_LATENCY = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_PROCESSING_START

    return ngx.exit(500)
  end
</code></pre>
<h3>8.5. header_filter_by_lua é˜¶æ®µ</h3>
<p>æ­¤é˜¶æ®µåœ¨ Kong æ¥æ”¶å®Œä¸Šæ¸¸æœåŠ¡è¿”å›çš„ Header å­—æ®µåæ‰§è¡Œã€‚</p>
<pre><code class="language-lua">      local upstream_status_header = constants.HEADERS.UPSTREAM_STATUS
      if singletons.configuration.enabled_headers[upstream_status_header] then
        header[upstream_status_header] = tonumber(sub(var.upstream_status or "", -3))
        if not header[upstream_status_header] then
          log(ERR, "failed to set ", upstream_status_header, " header")
        end
      end

      local hash_cookie = ctx.balancer_data.hash_cookie
      if not hash_cookie then
        return
      end

      local cookie = ck:new()
      local ok, err = cookie:set(hash_cookie)
</code></pre>
<p><code>runloop.header_filter.before</code> ä¸­åœ¨è¿”å›ç»“æœçš„ header é‡ŒåŠ å…¥èŠ‚ç‚¹çŠ¶æ€ï¼Œä»¥åŠåˆ¤æ–­æ˜¯å¦éœ€è¦åŠ å…¥è´Ÿè½½å‡è¡¡å™¨ä¸€è‡´æ€§ç­–ç•¥çš„ Cookieã€‚</p>
<h3>8.6. body_filter_by_lua é˜¶æ®µ</h3>
<p>æ­¤é˜¶æ®µåœ¨æ¥æ”¶ä¸Šæ¸¸æœåŠ¡è¿”å›çš„ Body æ•°æ®æ—¶æ‰§è¡Œï¼Œæ ¹æ®æ•°æ®å¤§å°åˆ’åˆ† chunksï¼Œæ­¤é˜¶æ®µä¼šè¢«æ‰§è¡Œå¤šæ¬¡ã€‚</p>
<p>åœ¨ Openresty çš„ç”Ÿå‘½å‘¨æœŸé‡Œï¼Œ<code>body_filter_by_lua</code> ä¸­ä½¿ç”¨ <code>ngx.arg[1]</code> è¯»å– chunkï¼Œä½¿ç”¨ <code>ngx.arg[2]</code> æ ‡è®° EOFã€‚</p>
<pre><code class="language-lua">  -- è·å–åˆ°äº†æ‰€æœ‰çš„ body
  if kong.ctx.core.response_body then
    arg[1] = kong.ctx.core.response_body
    arg[2] = true
  end

  if not arg[2] then
    return
  end

  -- è·å–åˆ°æ‰€æœ‰çš„ body å
  -- å†ç»Ÿè®¡æ‰§è¡Œæ—¶é—´
  ctx.KONG_BODY_FILTER_ENDED_AT = get_now_ms()
  ctx.KONG_BODY_FILTER_TIME = ctx.KONG_BODY_FILTER_ENDED_AT - ctx.KONG_BODY_FILTER_START

  if ctx.KONG_PROXIED then
    -- time spent receiving the response (header_filter + body_filter)
    -- we could use $upstream_response_time but we need to distinguish the waiting time
    -- from the receiving time in our logging plugins (especially ALF serializer).
    ctx.KONG_RECEIVE_TIME = ctx.KONG_BODY_FILTER_ENDED_AT - (ctx.KONG_HEADER_FILTER_START or
                                                             ctx.KONG_BALANCER_ENDED_AT or
                                                             ctx.KONG_BALANCER_START or
                                                             ctx.KONG_ACCESS_ENDED_AT)
</code></pre>
<h3>8.7. log_by_lua é˜¶æ®µ</h3>
<p>è°ƒç”¨ Lua çš„åƒåœ¾å›æ”¶å™¨ç»Ÿè®¡ Kong å ç”¨å†…å­˜æƒ…å†µï¼š</p>
<pre><code class="language-lua">local update_lua_mem
do
  local pid = ngx.worker.pid
  local kong_shm = ngx.shared.kong

  local Lua_MEM_SAMPLE_RATE = 10 -- seconds
  local last = ngx.time()

  local collectgarbage = collectgarbage

  update_lua_mem = function(force)
    local time = ngx.time()

    if force or time - last >= Lua_MEM_SAMPLE_RATE then
      local count = collectgarbage("count")

      local ok, err = kong_shm:safe_set("kong:mem:" .. pid(), count)
      if not ok then
        log(ERR, "could not record Lua VM allocated memory: ", err)
      end

      last = ngx.time()
    end
  end
end
</code></pre>
<p>æ ¹æ®å“åº”ç»“æœè°ƒç”¨è´Ÿè½½å‡è¡¡å™¨è°ƒæ•´ä¸Šæ¸¸èŠ‚ç‚¹çš„æƒé‡ï¼š</p>
<pre><code class="language-lua">      -- If response was produced by an upstream (ie, not by a Kong plugin)
      -- Report HTTP status for health checks
      local balancer_data = ctx.balancer_data
      if balancer_data and balancer_data.balancer_handle then
        local status = ngx.status
        if status == 504 then
          balancer_data.balancer.report_timeout(balancer_data.balancer_handle)
        else
          balancer_data.balancer.report_http_status(
            balancer_data.balancer_handle, status)
        end
        -- release the handle, so the balancer can update its statistics
        balancer_data.balancer_handle:release()
      end
</code></pre>
<h2>9. Admin API</h2>
<p>Kong Admin API å…¥å£ï¼š</p>
<pre><code class="language-lua">function Kong.admin_content(options)
  local ctx = ngx.ctx
  if not ctx.workspace then
    ctx.workspace = kong.default_workspace
  end

  return serve_content("kong.api", options)
end
</code></pre>
<pre><code class="language-lua">local function serve_content(module, options)

  -- CORS è·¨åŸŸç›¸å…³
  header["Access-Control-Allow-Origin"] = options.allow_origin or "*"

  -- å¯åŠ¨ lapis
  lapis.serve(module)
end
</code></pre>
<p>å…³äº <a href="https://leafo.net/lapis/">Lapis</a>ï¼š</p>
<blockquote>
<p>Lapis is a framework for building web applications using <a href="https://moonscript.org">MoonScript</a> or <a href="https://lua.org">Lua</a> that runs inside of a customized version of <a href="https://nginx.org">Nginx</a> called <a href="https://openresty.org">OpenResty</a>.</p>
</blockquote>
<pre><code class="language-lua"># api/init.lua
-- åŠ è½½å›ºå®šè·¯ç”±
-- Load core routes
for _, v in ipairs({"kong", "health", "cache", "config", "clustering"}) do
  local routes = require("kong.api.routes." .. v)
  api_helpers.attach_routes(app, routes)
end

  local routes = {}

  -- DAO Routes
  for _, dao in pairs(singletons.db.daos) do
    if dao.schema.generate_admin_api ~= false and not dao.schema.legacy then
      routes = Endpoints.new(dao.schema, routes)
    end
  end
</code></pre>
<p>åˆå§‹åŒ–æ„å»ºè·¯ç”±ï¼š</p>
<pre><code class="language-lua"># api/endpoints.lua
-- åˆ›å»ºåŸºç¡€è·¯ç”±
-- Generates admin api endpoint functions
--
-- Examples:
--
-- /routes
-- /routes/:routes
-- /routes/:routes/service
-- /services/:services/routes
--
-- and
--
-- /services
-- /services/:services
-- /services/:services/routes/:routes
local function generate_endpoints(schema, endpoints)
  -- list è·¯ç”±
  -- e.g. /routes
  generate_collection_endpoints(endpoints, schema)

  -- å•ä½“è·¯ç”±
  -- e.g. /routes/:routes
  generate_entity_endpoints(endpoints, schema)

  -- åˆ¤æ–­æ˜¯å¦æœ‰å…³è”å¯¹è±¡
  -- ä¾‹å¦‚ route å…³è” services
  for foreign_field_name, foreign_field in schema:each_field() do
    -- å¤–é”®
    if foreign_field.type == "foreign" and not foreign_field.schema.legacy then
      -- e.g. /routes/:routes/service
      generate_entity_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name, true)

      -- e.g. /services/:services/routes
      generate_collection_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name)

      -- e.g. /services/:services/routes/:routes
      generate_entity_endpoints(endpoints, foreign_field.schema, schema, foreign_field_name)
    end
  end

  return endpoints
end

-- Generates admin api collection endpoint functions
--
-- Examples:
--
-- /routes
-- /services/:services/routes
--
-- and
--
-- /services
local function generate_collection_endpoints(endpoints, schema, foreign_schema, foreign_field_name)
  local collection_path

  -- å¤–é”®å…³è”
  if foreign_schema then
    collection_path = fmt("/%s/:%s/%s", foreign_schema.admin_api_name or
                                        foreign_schema.name,
                                        foreign_schema.name,
                                        schema.admin_api_nested_name or
                                        schema.admin_api_name or
                                        schema.name)

  else
    -- æ²¡æœ‰å¤–é”®å…³è”
    collection_path = fmt("/%s", schema.admin_api_name or
                                 schema.name)
  end

  endpoints[collection_path] = {
    schema  = schema,
    methods = {
      --OPTIONS = method_not_allowed,
      --HEAD    = method_not_allowed,
      GET     = get_collection_endpoint(schema, foreign_schema, foreign_field_name),
      POST    = post_collection_endpoint(schema, foreign_schema, foreign_field_name),
      --PUT     = method_not_allowed,
      --PATCH   = method_not_allowed,
      --DELETE  = method_not_allowed,
    },
  }
end
</code></pre>
<p>åªå…³æ³¨ POST è¯·æ±‚å¤„ç†çš„éƒ¨åˆ†ï¼š</p>
<pre><code class="language-lua">local function post_collection_endpoint(schema, foreign_schema, foreign_field_name, method)
  return function(self, db, helpers, post_process)
    if foreign_schema then
      local foreign_entity, _, err_t = select_entity(self, db, foreign_schema)
      if err_t then
        return handle_error(err_t)
      end

      if not foreign_entity then
        return not_found()
      end

      self.args.post[foreign_field_name] = foreign_schema:extract_pk_values(foreign_entity)
    end

    -- å¤„ç†è¯·æ±‚ï¼Œå‚æ•°æ ¡éªŒï¼Œæ’å…¥æ•°æ®
    local entity, _, err_t = insert_entity(self, db, schema, method)
    if err_t then
      return handle_error(err_t)
    end

    -- å›è°ƒå‡½æ•°
    if post_process then
      entity, _, err_t = post_process(entity)
      if err_t then
        return handle_error(err_t)
      end
    end

    return created(entity)
  end
end
</code></pre>
<p>Admin API ä»…ä»…æ˜¯ä¸€å±‚ API å°è£…ï¼Œä¸è´Ÿè´£èƒŒåçš„äº‹ä»¶å¤„ç†å’Œæ•°æ®åŒæ­¥ï¼ŒèƒŒåçš„äº‹ä»¶å¤„ç†åœ¨æ–‡ç« äº‹ä»¶å¤„ç†éƒ¨åˆ†é˜è¿°è¿‡äº†ã€‚</p>
<h2>10. æ’ä»¶å¼€å‘</h2>
<p>ç®€å•ä»‹ç»ä¸€ä¸‹æ’ä»¶å¼€å‘èƒ½ç”¨ä¸Šçš„ä¸€äº›å° Trickã€‚</p>
<h3>10.1. å¤šå±‚ Schema åµŒå¥—</h3>
<p>çœ‹ç€å¾ˆæ¶å¿ƒå§ï¼Œä½†è¿™æ˜¯å¤šå±‚ Schema åµŒå¥—çš„æ ·å­ã€‚</p>
<pre><code class="language-lua">local schema = {
    name = plugin_name,
    fields = {
        { consumer = typedefs.no_consumer },
        { protocols = typedefs.protocols_http },
        { config = {
          type = "record",
          fields = { {
            rules = {
              type = "array",
              elements = {
                type = "record",
                fields = { {
                  match = {
                    type = "array",
                    elements = {
                      type = "record",
                      fields = {
                        { vars = { type = "array", elements = {
                            type = "array",
                            elements = { type = "string" }
                        } } }
                      }
                    }
                  }
                } }
              }
            }
          } },
        } }
    }
}
</code></pre>
<h3>10.2. è‡ªå®šä¹‰ Schema æ ¡éªŒå™¨</h3>
<pre><code class="language-lua">local expr = require("resty.expr.v1")

local schema_validator = function(conf)
    if conf.rules then
        for _, rule in ipairs(conf.rules) do
            if rule.match and type(rule.match) == "table" then
                for _, m in pairs(rule.match) do
                    local ok, err = expr.new(m.vars)
                    if not ok then
                        return false, "failed to validate the 'vars' expression: " .. err
                    end
                end
            end
        end
    end

    return true
end
</code></pre>
<h3>10.3. æ—¥å¿—æ‰“å° Table</h3>
<pre><code class="language-lua">kong.log.inspect.on()
kong.log.debug("Lua table: ", t)
</code></pre>
<h3>10.4. è‡ªå®šä¹‰æ—¥å¿—è¾“å‡º</h3>
<p>2.3.0 ç‰ˆæœ¬ä»¥ä¸Šå¯ç”¨ã€‚</p>
<pre><code class="language-lua">local entry = {
    entries = ctx.log_entries,
    id = self.transaction_id,
    action = action_name,
}

kong.log.set_serialize_value("waf", entry)
</code></pre>
<section data-footnotes class="footnotes"><h2 class="sr-only" id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-kong">
<p><a href="https://github.com/Kong/kong">ğŸ¦ The Cloud-Native API Gateway</a> <a href="#user-content-fnref-kong" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">â†©</a></p>
</li>
</ol>
</section></article><script src="/_next/static/chunks/webpack-072f062dc024cc52.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5803,[],\"\"]\n3:I[695,[],\"\"]\n5:I[2576,[],\"OutletBoundary\"]\n7:I[2576,[],\"MetadataBoundary\"]\n9:I[2576,[],\"ViewportBoundary\"]\nb:I[7614,[],\"\"]\n:HL[\"/_next/static/css/c3b55921f92a131e.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"m6A-Tc8bnMTyQXrjIe8w0\",\"p\":\"\",\"c\":[\"\",\"2021\",\"09\",\"kong-%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(posts)\",{\"children\":[[\"year\",\"2021\",\"d\"],{\"children\":[[\"month\",\"09\",\"d\"],{\"children\":[[\"slug\",\"kong-%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c3b55921f92a131e.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"(posts)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:style\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:1:props:style\",\"children\":404}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:2:props:style\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:2:props:children:props:style\",\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"year\",\"2021\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"month\",\"09\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"kong-%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"cmZ52_kEyb1Xjzdq6TGfM\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],null]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Mayo Rocks!\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Mayo's Blog\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/icon.png?14d5a92fbe70e82a\",\"type\":\"image/png\",\"sizes\":\"460x460\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script><script>self.__next_f.push([1,"c:T16a20,"])</script><script>self.__next_f.push([1,"\u003cp\u003eæœ¬æ–‡æœ€åˆäº 2020 å¹´ 9 æœˆåœ¨å…¬å¸å†…éƒ¨å‘è¡¨ï¼Œç°æ•´ç†å¹¶å¢åŠ éƒ¨åˆ†æ‰¹æ³¨å…¬å¼€å‘å¸ƒã€‚\u003c/p\u003e\n\u003cp\u003eæœ€å¼€å§‹åŠ å…¥å…¬å¸ Infrastructure å›¢é˜Ÿæ—¶ï¼Œè¿·èŒ«çš„æˆ‘æ¥åˆ°çš„çš„ä¸€ä¸ªä»»åŠ¡å°±æ˜¯å­¦ä¹  Lua å’Œ \u003ca href=\"https://github.com/openresty/lua-nginx-module\"\u003eOpenResty\u003c/a\u003eï¼Œå½“æ—¶æ”¶åˆ°äº†ä¸¤æœ¬ä¹¦ç±çš„ PDF æ–‡ä»¶ï¼Œè¦æ±‚å°½å¿«ç†è§£å­¦ä¹ ï¼Œèƒ½å¤ŸæŒæ¡ \u003ca href=\"https://github.com/Kong/kong\"\u003eKong\u003c/a\u003eï¼Œå¹¶ä¸”å…·æœ‰ç ”å‘èƒ½åŠ›ã€‚\u003c/p\u003e\n\u003cp\u003eå½“æ—¶æˆ‘è¿˜æ²¡æœ‰æ€ä¹ˆæ¥è§¦å¼€æºç¤¾åŒºï¼Œèƒ½åŠ›åªåœç•™åœ¨ Git Cloneï¼Œå¤§æ¦‚èŠ±äº† 2 å‘¨æ—¶é—´ï¼Œæˆ‘å­¦ä¹  Lua åŸºæœ¬è¯­æ³•åï¼Œå¼€å§‹é˜…è¯» Kong é¡¹ç›®çš„æºç ï¼Œå¹¶æ‰¾åˆ°å‡ ä¸ªåˆ‡å…¥ç‚¹æ¢³ç†äº†æºç åˆ†ææ–‡æ¡£ï¼Œä¹Ÿåº”è¯¥æ­£æ˜¯è¿™ä¸ªæˆæœè®©ç»„é•¿è®¤åŒäº†æˆ‘ï¼Œè¿™ä¹‹åæˆ‘è´Ÿè´£å…¬å¸ API Gateway çš„å¼€å‘ï¼Œä»¥åŠç›¸å…³çš„è½åœ°å·¥ä½œã€‚\u003c/p\u003e\n\u003cp\u003eé‚£ä¹ˆæœ¬æ–‡é’ˆå¯¹ Kong çš„å¯åŠ¨æµç¨‹ã€æ’ä»¶æœºåˆ¶ã€ç¼“å­˜æœºåˆ¶å’Œè¯·æ±‚çš„ç”Ÿå‘½å‘¨æœŸåšäº†è¯¦ç»†çš„é˜è¿°ï¼Œä¸è¿‡ä»æœ‰æ¬ ç¼ºçš„æ˜¯ä»£ç†è½¬å‘åŠŸèƒ½ï¼Œä¾‹å¦‚è´Ÿè½½å‡è¡¡ã€å¥åº·æ£€æŸ¥ã€æœåŠ¡å‘ç°ç­‰ï¼Œä¸è¿‡ä»‹äºå½“æ—¶çš„æˆ‘è¿˜æ˜¯ä¸ªæ‡µæ‡‚çš„æ–°äººï¼Œè¿™é‡Œå°±å…ˆåŸè°…æˆ‘è‡ªå·±äº† ğŸ¾ã€‚\u003c/p\u003e\n\u003cp\u003eç»§è¿™ç¯‡æ–‡ç« ä¹‹åï¼Œæˆ‘è¿˜æ’°å†™äº† Kong Ingress Controller æºç åˆ†æï¼Œåç»­è¿˜æœ‰ APISIX çš„æºç åˆ†æå“¦ã€‚\u003c/p\u003e\n\u003ch2\u003e1. æ¦‚è¿°\u003c/h2\u003e\n\u003cp\u003eæœ¬æ–‡é’ˆå¯¹çš„æ˜¯ Kong 2.1 ç‰ˆæœ¬ï¼ˆStableï¼‰ã€‚\u003c/p\u003e\n\u003cp\u003eæˆ‘é˜…è¯»å¹¶ä½œå‡ºä¸­æ–‡æ³¨é‡Šçš„ Commits å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ï¼š\n\u003ca href=\"https://github.com/mayocream/kong/commits?author=huanghan39\"\u003ehttps://github.com/mayocream/kong/commits?author=mayocream\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKongï¼ˆOpenRestyï¼‰çš„æ‰§è¡Œé˜¶æ®µ\u003c/strong\u003eï¼š\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021-09-01-20.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eKong çš„æ’ä»¶æœºåˆ¶ä¹Ÿæ˜¯åŸºäº OpenResty çš„ç”Ÿå‘½å‘¨æœŸï¼Œåªä¸è¿‡æ˜¯å…¶åœ¨ä¸Šå±‚åšäº†äº›è®¸å°è£…ã€‚\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKong çš„æ•°æ®åº“å…³è”å…³ç³»\u003c/strong\u003eï¼š\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021-09-01-19.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eKong è™½ç„¶æ ‡ç§°è‡ªå·±æ˜¯ Cloud Native é¡¹ç›®\u003csup\u003e\u003ca href=\"#user-content-fn-kong\" id=\"user-content-fnref-kong\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e1\u003c/a\u003e\u003c/sup\u003eï¼Œä¹Ÿä¸Šæ¦œäº† CNCF \u003ca href=\"https://landscape.cncf.io/\"\u003eå…¨æ™¯å›¾\u003c/a\u003eï¼Œä½†æ˜¯å®ƒè¿˜ä¾èµ–äºä¼ ç»Ÿçš„æ•°æ®åº“ PostgreSQLï¼Œå¹¶ä¸”è¿˜è‡ªå®šä¹‰äº†è®¸å¤š functionï¼Œç›¸æ¯”äº APISIX èƒŒåå‚¨å­˜ Etcd è¦å¼±äº†è®¸å¤šã€‚æ¯”èµ· Etcd èƒ½å»ºç«‹ HTTP é•¿è¿æ¥ Watch æ•°æ®å˜åŒ–ï¼ŒKong åªèƒ½ä¾èµ–å®šæ—¶çš„è½®è¯¢ä»æ•°æ®åº“æ›´æ–°çŠ¶æ€ï¼Œæ•°æ®åº“é«˜å¯ç”¨ä¹Ÿç›¸æ¯” Etcd é›†ç¾¤è¦å¤æ‚å¾—å¤šã€‚\u003c/p\u003e\n\u003ch2\u003e2. é…ç½®æ–‡ä»¶\u003c/h2\u003e\n\u003cp\u003eKong åœ¨å¯åŠ¨é˜¶æ®µä¼šè§£æ \u003ca href=\"https://github.com/kong/kong/tree/master/kong/templates\"\u003e\u003ccode\u003ekong/templates\u003c/code\u003e\u003c/a\u003e ç›®å½•ä¸‹çš„ \u003ccode\u003e.lua\u003c/code\u003e æ¨¡æ¿æ–‡ä»¶ï¼Œæ³¨å…¥ç¯å¢ƒå˜é‡å’Œ \u003ccode\u003ekong.conf\u003c/code\u003e è¦†ç›–é…ç½®ï¼Œç”Ÿæˆ Nginx å¯åŠ¨çš„é…ç½®æ–‡ä»¶ \u003ccode\u003enginx.conf\u003c/code\u003eã€‚\u003c/p\u003e\n\u003cp\u003eç»“æ„å¦‚ä¸‹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003epid pids/nginx.pid;\nerror_log logs/error.log notice;\n\n# injected nginx_main_* directives\n\nenv SKYWALKING_URL;\n\nevents {\n    # injected nginx_events_* directives\n    multi_accept on;\n    worker_connections 16384;\n}\n\nhttp {\n    lua_package_path       './?.lua;./?/init.lua;;;;';\n    lua_package_cpath      ';;;';\n\n    lua_shared_dict kong                        5m;\n    lua_shared_dict kong_locks                  8m;\n\t...\n\n    # injected nginx_http_* directives\n    client_body_buffer_size 8k;\n\n    init_by_lua_block {\n        Kong = require 'kong'\n        Kong.init()\n    }\n\n    init_worker_by_lua_block {\n        Kong.init_worker()\n    }\n\n    upstream kong_upstream {\n        server 0.0.0.1;\n\n        # injected nginx_upstream_* directives\n\n        balancer_by_lua_block {\n            Kong.balancer()\n        }\n    }\n\n\t# Kong Proxy\n    server {\n        server_name kong;\n\t\t...\n    }\n\n\t# Kong Admin API\n    server {\n        server_name kong_admin;\n        ...\n    }\n\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKong å®šä¹‰äº† \u003ccode\u003eNGINX_MAIN_XXX\u003c/code\u003eï¼Œè¯¸å¦‚æ­¤ç±»çš„ç¯å¢ƒå˜é‡ï¼Œåœ¨è§£æé…ç½®é˜¶æ®µä¼šåŠ è½½åˆ° \u003ccode\u003enginx.conf\u003c/code\u003e çš„æŒ‡å®šä½ç½®ï¼Œèƒ½å¤Ÿé¿å…ç›´æ¥ä¿®æ”¹æ¨¡æ¿æ–‡ä»¶ã€‚\u003c/p\u003e\n\u003cp\u003eä¾‹å¦‚ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# åœ¨ main å—é‡Œå®šä¹‰ env å˜é‡\n$ export NGINX_MAIN_ENV SKYWALKING_URL;\n# åˆ›å»ºæ–°çš„ lua shared dict\n$ export NGINX_HTTP_Lua_SHARED_DICT tracing_buffer 128m;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKong \u003ca href=\"https://docs.konghq.com/2.1.x/configuration/\"\u003eå®˜æ–¹çš„é…ç½®æ–‡æ¡£\u003c/a\u003eå·²ç»éå¸¸è¯¦å°½ï¼Œè§£é‡Šäº†å„ä¸ªå‚æ•°ä»£è¡¨çš„å«ä¹‰ã€‚\u003c/p\u003e\n\u003cp\u003eè¿™é‡Œè¡¥å……ä¸€ç‚¹ï¼Œé€šå¸¸æˆ‘ä»¬éœ€è¦å®šä¹‰å¤šä¸ª Shared dictï¼Œé…ç½®å†™æ³•éœ€è¦æ”¹æˆè¿™ç§ä¸‘é™‹çš„å½¢å¼ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enginx_http_lua_shared_dict = cache_buffer_one 128m; lua_shared_dict cache_buffer_two 128m\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3. åˆå§‹åŒ–\u003c/h2\u003e\n\u003ch3\u003e3.1. æ•°æ®åº“åˆå§‹åŒ–\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eKong.init()\u003c/code\u003e æ–¹æ³•ä¸­åˆå§‹åŒ–æ•°æ®åº“ç›¸å…³ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  -- æ•°æ®åº“è¿æ¥ç›¸å…³\n  local db = assert(DB.new(config))\n  assert(db:init_connector())\n  kong.db = db\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eDB.new()\u003c/code\u003e æ–¹æ³•ä¸­ä¾æ¬¡è°ƒç”¨äº† \u003ccode\u003eSchema.new()\u003c/code\u003eã€\u003ccode\u003eEntity.new()\u003c/code\u003eã€\u003ccode\u003eDAO.new()\u003c/code\u003e æ–¹æ³•ï¼Œä¸‹é¢ä¸€ä¸ªä¸ªæ¥è¯´æ˜ã€‚\u003c/p\u003e\n\u003ch4\u003e3.1.1. Schema\u003c/h4\u003e\n\u003cp\u003eKong çš„ Schema æ•°æ®ç»“æ„ä½“ä½äº \u003ccode\u003edb/schema/entities\u003c/code\u003e ä¸‹ï¼Œå°± \u003ccode\u003eroutes.lua\u003c/code\u003e ä¸ºä¾‹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal typedefs = require \"kong.db.schema.typedefs\"\n\n\nreturn {\n  name         = \"routes\",\n  primary_key  = { \"id\" },\n  endpoint_key = \"name\",\n  workspaceable = true,\n  subschema_key = \"protocols\",\n\n  fields = {\n    { id             = typedefs.uuid, },\n    { created_at     = typedefs.auto_timestamp_s },\n    { updated_at     = typedefs.auto_timestamp_s },\n    { name           = typedefs.name },\n    { protocols      = { type     = \"set\",\n                         len_min  = 1,\n                         required = true,\n                         elements = typedefs.protocol,\n                         mutually_exclusive_subsets = {\n                           { \"http\", \"https\" },\n                           { \"tcp\", \"tls\" },\n                           { \"grpc\", \"grpcs\" },\n                         },\n                         default = { \"http\", \"https\" }, -- TODO: different default depending on service's scheme\n                       }, },\n    { methods        = typedefs.methods },\n    { hosts          = typedefs.hosts },\n    { paths          = typedefs.paths },\n    { headers        = typedefs.headers },\n    { https_redirect_status_code = { type = \"integer\",\n                                     one_of = { 426, 301, 302, 307, 308 },\n                                     default = 426, required = true,\n                                   }, },\n    { regex_priority = { type = \"integer\", default = 0 }, },\n    { strip_path     = { type = \"boolean\", default = true }, },\n    { path_handling  = { type = \"string\", default = \"v0\", one_of = { \"v0\", \"v1\" }, }, },\n    { preserve_host  = { type = \"boolean\", default = false }, },\n    { snis = { type = \"set\",\n               elements = typedefs.sni }, },\n    { sources = typedefs.sources },\n    { destinations = typedefs.destinations },\n    { tags             = typedefs.tags },\n    { service = { type = \"foreign\", reference = \"services\" }, },\n  },\n\n  entity_checks = {\n    { conditional = { if_field = \"protocols\",\n                      if_match = { elements = { type = \"string\", not_one_of = { \"grpcs\", \"https\", \"tls\" }}},\n                      then_field = \"snis\",\n                      then_match = { len_eq = 0 },\n                      then_err = \"'snis' can only be set when 'protocols' is 'grpcs', 'https' or 'tls'\",\n                    }},\n                  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eprimary_key\u003c/code\u003e æ˜¯åœ¨æ•°æ®åº“ä¸­ä¸»é”®ä¹Ÿæ˜¯å½“ \u003ccode\u003ecache_key\u003c/code\u003e æœªå®šä¹‰æ—¶çš„é»˜è®¤ \u003ccode\u003ecache_key\u003c/code\u003eã€‚\u003c/p\u003e\n\u003cp\u003eæœ‰ \u003ccode\u003etype=foreign\u003c/code\u003e çš„æƒ…å†µï¼Œentity åŠ è½½æ—¶ä¼šå½“ä½œ subschema åŠ è½½è¿›æ¥ã€‚\u003c/p\u003e\n\u003cp\u003eæ’ä»¶ä¸åŒäºå…¶ä»– entityï¼Œæœ‰ç‰¹å®š cache_keyã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  name = \"plugins\",\n  primary_key = { \"id\" },\n  cache_key = { \"name\", \"route\", \"service\", \"consumer\" },\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCache ç›¸å…³æ“ä½œä¸­è°ƒç”¨ \u003ccode\u003eEntity.cache_key()\u003c/code\u003e è·å–ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e    local cache_key = dao:cache_key(entity)\n    local ok, err = cache:safe_set(cache_key, entity)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå…·ä½“ç”Ÿæˆ \u003ccode\u003ecache_key\u003c/code\u003e çš„æ–¹æ³•ï¼Œè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºç¼“å­˜ keyã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction DAO:cache_key(key, arg2, arg3, arg4, arg5, ws_id)\n\n  if self.schema.workspaceable then\n    ws_id = ws_id or workspaces.get_workspace_id()\n  end\n\n  -- Fast path: passing the cache_key/primary_key entries in\n  -- order as arguments, this produces the same result as\n  -- the generic code below, but building the cache key\n  -- becomes a single string.format operation\n  if type(key) == \"string\" then\n    return fmt(\"%s:%s:%s:%s:%s:%s:%s\", self.schema.name,\n               key == nil and \"\" or key,\n               arg2 == nil and \"\" or arg2,\n               arg3 == nil and \"\" or arg3,\n               arg4 == nil and \"\" or arg4,\n               arg5 == nil and \"\" or arg5,\n               ws_id == nil and \"\" or ws_id)\n  end\n\n  -- Generic path: build the cache key from the fields\n  -- listed in cache_key or primary_key\n\n  if type(key) ~= \"table\" then\n    error(\"key must be a string or an entity table\", 2)\n  end\n\n  if key.ws_id then\n    ws_id = key.ws_id\n  end\n\n  local values = new_tab(7, 0)\n  values[1] = self.schema.name\n  local source = self.schema.cache_key or self.schema.primary_key\n\n  local i = 2\n  for _, name in ipairs(source) do\n    local field = self.schema.fields[name]\n    local value = key[name]\n    if value == null or value == nil then\n      value = \"\"\n    elseif field.type == \"foreign\" then\n      -- FIXME extract foreign key, do not assume `id`\n      value = value.id\n    end\n    values[i] = tostring(value)\n    i = i + 1\n  end\n  for n = i, 6 do\n    values[n] = \"\"\n  end\n\n  values[7] = ws_id or \"\"\n\n  return concat(values, \":\")\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eschema/init.lua\u003c/code\u003e ä¸­å®šä¹‰äº† schema ç›¸å…³æ“ä½œçš„åŸºæœ¬æ–¹æ³•ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e-- each_field() ç”¨äºéå† schema çš„ fields\n-- æ˜¯ schema ç›¸å…³æ“ä½œæœ€é¢‘ç¹çš„\nfunction Schema:each_field(values)\n  local i = 1\n\n  local subschema\n  if values then\n    subschema = get_subschema(self, values)\n  end\n\n  return function()\n    local item = self.fields[i]\n    if not item then\n      return nil\n    end\n    local key = next(item)\n    local field = resolve_field(self, key, item[key], subschema)\n    i = i + 1\n    return key, field\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eSchema.new()\u003c/code\u003e æ–¹æ³•ä¸­é€šè¿‡å…ƒç»„è®¾ç½® \u003ccode\u003e__index\u003c/code\u003e è®©ç»“æ„ä½“ç»§æ‰¿ Schema ä¸‹å®šä¹‰çš„ä¸€ç³»åˆ—æ“ä½œæ–¹æ³•ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction Schema.new(definition, is_subschema)\n  if not definition then\n    return nil, validation_errors.SCHEMA_NO_DEFINITION\n  end\n\n  if not definition.fields then\n    return nil, validation_errors.SCHEMA_NO_FIELDS\n  end\n\n  local self = copy(definition)\n\n  -- ç»§æ‰¿ Schema ä¸‹å®šä¹‰çš„ä¸€ç³»åˆ—æ“ä½œæ–¹æ³•\n  setmetatable(self, Schema)\n\n  -- entity ç¼“å­˜çš„ cache_keyï¼Œ\n  -- å¦‚æœæ²¡æœ‰è¿™ä¸ªå­—æ®µï¼Œåˆ™é»˜è®¤ä½¿ç”¨ schema å®šä¹‰çš„\n  -- primary_key æ¥ä½œä¸º cache_key\n  -- cache_key æ˜¯ä¸ªæ•°ç»„ï¼Œ\n  -- è¿™é‡Œåªæ˜¯åˆ†å¼€å‚¨å­˜\n  if self.cache_key then\n    self.cache_key_set = {}\n    for _, name in ipairs(self.cache_key) do\n      self.cache_key_set[name] = true\n    end\n  end\n\n\n  -- é€šè¿‡å…ƒç»„ __index æ–¹æ³•è°ƒç”¨ Schema:each_field() æ–¹æ³•\n  -- éå† schema çš„ fields table\n  for key, field in self:each_field() do\n    -- Also give access to fields by name\n    self.fields[key] = field\n    if field.type == \"record\" and field.fields then\n      allow_record_fields_by_name(field)\n    end\n\n    -- å¦‚æœæœ‰å¤–é”®\n    -- åˆ™åŠ è½½å¤–é”®å…³è”çš„ schema è¿›æ¥\n    if field.type == \"foreign\" then\n      local err\n      field.schema, err = get_foreign_schema_for_field(field)\n      if not field.schema then\n        return nil, err\n      end\n\n      if not is_subschema then\n        -- Store the inverse relation for implementing constraints\n        local constraints = assert(_cache[field.reference]).constraints\n        table.insert(constraints, {\n          schema     = self,\n          field_name = key,\n          on_delete  = field.on_delete,\n        })\n      end\n    end\n  end\n\n  if self.workspaceable and self.name then\n    if not _workspaceable[self.name] then\n      _workspaceable[self.name] = true\n      table.insert(_workspaceable, { schema = self })\n    end\n  end\n\n  if self.name then\n    -- do not reset the constraints list if a schema in reloaded\n    if not _cache[self.name] then\n      _cache[self.name] = {\n        constraints = {},\n      }\n    end\n    -- but always update the schema object in cache\n    _cache[self.name].schema = self\n  end\n\n  return self\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eç”¨äºä¸‹çº§ç»§æ‰¿çš„å…ƒç»„ï¼Œè™šæ™ƒä¸€æªã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal Schema       = {}\nSchema.__index     = Schema\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e3.1.2. Entity\u003c/h4\u003e\n\u003cp\u003eEntity åªæ˜¯ç®€å•å¯¹ Schema è¿›è¡Œä¸€å±‚å°è£…ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e-- definition æ˜¯ schema ç»“æ„ä½“\nfunction Entity.new(definition)\n\n  -- åˆå§‹åŒ– Schema å¯¹è±¡\n  local self, err = Schema.new(definition)\n  if not self then\n    return nil, err\n  end\n\n  -- éå† schema fields\n  for name, field in self:each_field() do\n    if field.nilable then\n      return nil, entity_errors.NO_NILABLE:format(name)\n    end\n\n    if field.abstract then\n      goto continue\n    end\n\n    if field.type == \"map\" then\n      if field.keys.type ~= \"string\" then\n        return nil, entity_errors.MAP_KEY_STRINGS_ONLY:format(name)\n      end\n\n    elseif field.type == \"record\" then\n      make_records_required(field)\n\n    elseif field.type == \"function\" then\n      return nil, entity_errors.NO_FUNCTIONS:format(name)\n    end\n\n    ::continue::\n  end\n\n  self.new_subschema = Entity.new_subschema\n\n  return self\nend\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEntity å¯¹è±¡éšåè¢«åŠ è½½åˆ° \u003ccode\u003eDB.new()\u003c/code\u003e å‡½æ•°ä¸­ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal schemas = {}\n\ndo\n  -- load schemas\n  -- core entities are for now the only source of schemas.\n  -- TODO: support schemas from plugins entities as well.\n\n  -- è½½å…¥æ ¸å¿ƒ entityï¼Œä¸ºä»€ä¹ˆæ˜¯æ ¸å¿ƒ entity\n  -- å› ä¸ºè¿˜æœ‰ plugin è‡ªå®šä¹‰çš„ entity\n  -- è¿™äº› entity æ˜¯ Kong è‡ªèº«çš„\n  for _, entity_name in ipairs(constants.CORE_ENTITIES) do\n\n    -- åŠ è½½ schemaï¼ˆæ•°æ®ç»“æ„ä½“ï¼‰\n    local entity_schema = require(\"kong.db.schema.entities.\" .. entity_name)\n\n    -- validate core entities schema via metaschema\n    local ok, err_t = MetaSchema:validate(entity_schema)\n    if not ok then\n      return nil, fmt(\"schema of entity '%s' is invalid: %s\", entity_name,\n                      tostring(errors:schema_violation(err_t)))\n    end\n\n    -- åŠ è½½ entity å¯¹è±¡\n    local entity, err = Entity.new(entity_schema)\n    if not entity then\n      return nil, fmt(\"schema of entity '%s' is invalid: %s\", entity_name,\n                      err)\n    end\n    schemas[entity_name] = entity\n\n    -- load core entities subschemas\n    local subschemas\n    ok, subschemas = utils.load_module_if_exists(\"kong.db.schema.entities.\" .. entity_name .. \"_subschemas\")\n    if ok then\n      for name, subschema in pairs(subschemas) do\n        local ok, err = entity:new_subschema(name, subschema)\n        if not ok then\n          return nil, (\"error initializing schema for %s: %s\"):format(entity_name, err)\n        end\n      end\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e3.1.3. DAO\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003edb/dao/init.lua\u003c/code\u003e ä¸­å®šä¹‰äº†ä¸€ç³»åˆ—å¯¹æ•°æ®åº“æ“ä½œçš„æ–¹æ³•ï¼Œä¾‹å¦‚ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction DAO:select(primary_key, options)\nfunction DAO:page(size, offset, options)\nfunction DAO:each(size, options)\nfunction DAO:insert(entity, options)\nfunction DAO:update(primary_key, entity, options)\nfunction DAO:delete(primary_key, options)\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eDAO.new()\u003c/code\u003e ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å« db è¿æ¥ä¿¡æ¯ï¼Œentity çš„ tableã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e-- schema å‚æ•°æ˜¯ Entity å¯¹è±¡\n--  DB ç»“æ„ä½“ï¼š  local self   = {\n  --    daos       = daos,       -- each of those has the connector singleton\n  --    strategies = strategies,\n  --    connector  = connector,\n  --    strategy   = strategy,\n  --    errors     = errors,\n  --    infos      = connector:infos(),\n  --    kong_config = kong_config,\n  --  }\nfunction _M.new(db, schema, strategy, errors)\n  local fk_methods = generate_foreign_key_methods(schema)\n  -- ç»§æ‰¿ DAO åŸºç¡€æ–¹æ³•\n  local super      = setmetatable(fk_methods, DAO)\n\n  local self = {\n    db         = db,\n    schema     = schema,\n    strategy   = strategy,\n    errors     = errors,\n    pagination = utils.shallow_copy(defaults.pagination),\n    super      = super,\n  }\n\n  if schema.dao then\n    -- æ’ä»¶è‡ªå®šä¹‰çš„ dao\n    local custom_dao = require(schema.dao)\n    for name, method in pairs(custom_dao) do\n      self[name] = method\n    end\n  end\n\n  return setmetatable(self, { __index = super })\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåœ¨ \u003ccode\u003edb\\init.lua\u003c/code\u003e ä¸­åŠ è½½æ‰€æœ‰ DAO å¯¹è±¡ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  do\n    -- load DAOs\n\n    for _, schema in pairs(schemas) do\n      local strategy = strategies[schema.name]\n      if not strategy then\n        return nil, fmt(\"no strategy found for schema '%s'\", schema.name)\n      end\n\n      -- å‚¨å­˜ daos\n      daos[schema.name] = DAO.new(self, schema, strategy, errors)\n    end\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå’Œä¸Šé¢ç»“æ„ä¸€æ ·ï¼Œ\u003ccode\u003eDB.new()\u003c/code\u003e ä¸­æœ€åä¸º table è®¾ç½®å…ƒç»„ __index æ–¹æ³•ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  -- è®¾ç½®å…ƒç»„ __index æ–¹æ³•\n  -- è®¿é—®ä¸å­˜åœ¨çš„å¯¹è±¡åˆ™å…ˆ\n  -- DB.xxx å†è®¿é—® DB.daos.xxx\n  return setmetatable(self, DB)\n\n\nlocal DB = {}\nDB.__index = function(self, k)\n  -- rawget ä¸ºä¸è°ƒç”¨å…ƒç»„ __index æ–¹æ³•ï¼Œç›´æ¥è·å–åŸæ•°æ®\n  return DB[k] or rawget(self, \"daos\")[k]\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKong ä¸­å…¶ä»–åœ°æ–¹è°ƒç”¨æ•°æ®åº“æ–¹æ³•ï¼Œæ“ä½œç¬¦ä¸º \u003ccode\u003ekong.db.services:each_fields()\u003c/code\u003eï¼Œå³å®é™…è°ƒç”¨ \u003ccode\u003edaos.services\u003c/code\u003eã€\u003ccode\u003eentity:each_fields()\u003c/code\u003eï¼ˆå®é™…æ˜¯ \u003ccode\u003eSchema:each_fields()\u003c/code\u003eï¼‰ã€‚\u003c/p\u003e\n\u003cp\u003eDAO ä¸‹é¢è¿˜æœ‰å°è£…çš„æ•°æ®åº“æ“ä½œå±‚ï¼Œä¾‹å¦‚ postgresql ç”Ÿæˆ SQL è¯­å¥çš„æ–¹æ³•ï¼Œè¿™é‡Œå°±ä¸èµ˜è¿°äº†ã€‚\u003c/p\u003e\n\u003cp\u003eDAO è¿™ä¸€å±‚ä¸€å±‚çš„å°è£…çœ‹å¾—æˆ‘æ˜¯çœŸçš„è„‘å£³ç—›ï¼ŒIDE è¿˜æ²¡æœ‰å¯¹ lua çš„æ™ºèƒ½æç¤ºï¼ŒæŒ‰ä½ Ctrl æ¯›éƒ½æ˜¾ç¤ºä¸å‡ºæ¥ã€‚\u003c/p\u003e\n\u003ch3\u003e3.2. ç¼“å­˜æ„å»º\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003einit_by_lua\u003c/code\u003e  é˜¶æ®µåˆå§‹åŒ– Master è¿›ç¨‹ï¼Œè¿›è¡Œè§£æé…ç½®æ–‡ä»¶ã€è¿æ¥æ•°æ®åº“ã€æ¸…ç©ºå…±äº«å†…å­˜ã€æ„å»ºè·¯ç”±ç¼“å­˜ç­‰æ“ä½œã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereset_kong_shm\u003c/code\u003e ä»£ç å—é‡Œæ¸…ç†å…±äº«å†…å­˜ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e    local shms = {\n      \"kong\",\n      \"kong_locks\",\n      \"kong_healthchecks\",\n      \"kong_process_events\",\n      \"kong_cluster_events\",\n      \"kong_rate_limiting_counters\",\n      \"kong_core_db_cache\" .. suffix,\n      \"kong_core_db_cache_miss\" .. suffix,\n      \"kong_db_cache\" .. suffix,\n      \"kong_db_cache_miss\" .. suffix,\n      \"kong_clustering\",\n    }\n\n    for _, shm in ipairs(shms) do\n      local dict = ngx.shared[shm]\n      -- æ¸…ç©ºå…±äº«å†…å­˜\n      if dict then\n        dict:flush_all()\n        dict:flush_expired(0)\n      end\n    end\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e3.2.1. è·¯ç”±ç¼“å­˜\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  else\n    -- DB æ¨¡å¼\n    local default_ws = db.workspaces:select_by_name(\"default\")\n    kong.default_workspace = default_ws and default_ws.id\n\n    local ok, err = runloop.build_plugins_iterator(\"init\")\n    if not ok then\n      error(\"error building initial plugins: \" .. tostring(err))\n    end\n\n    -- åˆå§‹åŒ–è·¯ç”±\n    -- æ„å»ºè·¯ç”±ç¼“å­˜\n    assert(runloop.build_router(\"init\"))\n  end\n\n  db:close()\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDB æ¨¡å¼ä¸‹æœ€åä¸€æ­¥ä¼šè°ƒç”¨ \u003ccode\u003erunloop.build_router(\"init\")\u003c/code\u003e æ„å»ºè·¯ç”±ç¼“å­˜ã€‚\u003c/p\u003e\n\u003cp\u003eæ„å»ºè·¯ç”±ç¼“å­˜è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­ Kong æ˜¯å¦å·²ç»åˆå§‹åŒ–è¿‡ Cache ç»„ä»¶ï¼Œ\u003ccode\u003einit\u003c/code\u003e é˜¶æ®µæ²¡æœ‰å®Œæˆåˆå§‹åŒ– Cacheï¼Œåˆ™åˆ›å»ºä¸€ä¸ª Lua table ç¼“å­˜è·¯ç”±ä¿¡æ¯ã€‚\u003ccode\u003ebuild_services_init_cache()\u003c/code\u003e æ–¹æ³•ä¼šåˆ†é¡µåŠ è½½æ‰€æœ‰ Service åˆ° table ä¸­ï¼Œå¯¹å–å‡ºæ¥çš„ Servicesï¼Œåˆ¤æ–­å½“å‰ä½¿ç”¨çš„ Nginx æ¨¡å¼ï¼ˆhttp/streamï¼‰æ˜¯å¦å¯¹åº”è·¯ç”±æŒ‡å®šçš„åè®®ï¼Œå¯¹åº”åˆ™å–å‡º Service å¯¹è±¡ï¼Œä¸ Route è¿›è¡Œå…³è”ã€‚æœ€åä¼ é€’ç»™ \u003ccode\u003eRouter.new()\u003c/code\u003e æ–¹æ³•é€šè¿‡ç®—æ³•å»ºç«‹æ ‘å½¢ç»“æ„å»ºç«‹è·¯ç”±ç´¢å¼•ã€‚\u003c/p\u003e\n\u003cp\u003eKong åŸºäº Nginx Subsystem æ”¯æŒçš„åè®®å¯¹åº”å…³ç³»ï¼š\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ehttp/https -\u003e http\u003c/li\u003e\n\u003cli\u003egrpc/grpcs -\u003e http\u003c/li\u003e\n\u003cli\u003etcp/tls -\u003e stream\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  build_router = function(version)\n    local db = kong.db\n    -- table å‚¨å­˜æ‰€æœ‰çš„ route-service æ•°æ®\n    local routes, i = {}, 0\n\n    local err\n    -- The router is initially created on init phase, where kong.core_cache is\n    -- still not ready. For those cases, use a plain Lua table as a cache\n    -- instead\n    -- init é˜¶æ®µ core_cache è¿˜æ²¡æœ‰åˆå§‹åŒ–å®Œæˆ\n    -- è¿™é‡Œä½¿ç”¨ table å‚¨å­˜\n    local services_init_cache = {}\n    if not kong.core_cache and db.strategy ~= \"off\" then\n      -- è·å–æ‰€æœ‰çš„ servicesï¼Œä½¿ç”¨é»˜è®¤çš„åˆ†é¡µå‚æ•°\n      services_init_cache, err = build_services_init_cache(db)\n      if err then\n        services_init_cache = {}\n        log(WARN, \"could not build services init cache: \", err)\n      end\n    end\n\n    local counter = 0\n    local page_size = db.routes.pagination.page_size\n    for route, err in db.routes:each(nil, GLOBAL_QUERY_OPTS) do\n      if err then\n        return nil, \"could not load routes: \" .. err\n      end\n\n      -- æ£€æŸ¥ router æ•°æ®æ˜¯å¦å·²ç»å˜åŒ–\n      -- é€šè¿‡æ£€æŸ¥ router hash æ˜¯å¦ä¸€è‡´åˆ¤æ–­\n      -- å¦‚æœå·²ç»å˜åŒ–åˆ™é€€å‡ºå‡½æ•°\n      if db.strategy ~= \"off\" then\n        if kong.core_cache and counter \u003e 0 and counter % page_size == 0 then\n          local new_version, err = get_router_version()\n          if err then\n            return nil, \"failed to retrieve router version: \" .. err\n          end\n\n          if new_version ~= version then\n            return nil, \"router was changed while rebuilding it\"\n          end\n        end\n      end\n\n      -- subsystem æ˜¯å¦æ”¯æŒå½“å‰è·¯ç”±çš„åè®®\n      if should_process_route(route) then\n        -- è·å– route çš„ service\n        local service, err = get_service_for_route(db, route, services_init_cache)\n        if err then\n          return nil, err\n        end\n\n        local r = {\n          route   = route,\n          service = service,\n        }\n\n        i = i + 1\n        -- å‚¨å­˜æ‰€æœ‰çš„ route-service\n        routes[i] = r\n      end\n\n      counter = counter + 1\n    end\n\n    local new_router, err = Router.new(routes)\n    if not new_router then\n      return nil, \"could not create router: \" .. err\n    end\n\n    -- router å®ä¾‹\n    router = new_router\n\n    if version then\n      router_version = version\n    end\n\n    -- LEGACY - singletons module is deprecated\n    singletons.router = router\n    -- /LEGACY\n\n    return true\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ„å»ºè·¯ç”±ç¼“å­˜è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­ Kong æ˜¯å¦å·²ç»åˆå§‹åŒ–è¿‡ Cache ç»„ä»¶ï¼Œ\u003ccode\u003einit\u003c/code\u003e é˜¶æ®µæ²¡æœ‰å®Œæˆåˆå§‹åŒ– Cacheï¼Œåˆ™åˆ›å»ºä¸€ä¸ª Lua table ç¼“å­˜ servicesã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  -- ä»¥ [service.id] = service\n  -- ç»“æ„å‚¨å­˜åˆ° table ä¸­\n  local function build_services_init_cache(db)\n    local services_init_cache = {}\n\n    for service, err in db.services:each(nil, GLOBAL_QUERY_OPTS) do\n      if err then\n        return nil, err\n      end\n\n      services_init_cache[service.id] = service\n    end\n\n    return services_init_cache\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebuild_services_init_cache(db)\u003c/code\u003e æ–¹æ³•ï¼Œè°ƒç”¨ \u003ccode\u003eDAO:each()\u003c/code\u003e å‡½æ•°ï¼Œä½¿ç”¨é»˜è®¤åˆ†é¡µå‚æ•° \u003ccode\u003epage_size=1000\u003c/code\u003eï¼Œè¿›è¡Œåˆ†é¡µè·å–ï¼Œå†è¿”å›å¯è¿­ä»£çš„å•æ¡è®°å½•ã€‚è¿™é‡Œå› ä¸º \u003ccode\u003einit_by_lua\u003c/code\u003e é˜¶æ®µæ²¡æœ‰åˆå§‹åŒ–ç¼“å­˜ï¼ˆ\u003ccode\u003ekong.core_cache\u003c/code\u003e ï¼‰ï¼Œæ‰€ä»¥ä½¿ç”¨ Lua table å‚¨å­˜ç¼“å­˜æ•°æ®ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction DAO:each(size, options)\n  if size ~= nil then\n    validate_size_type(size)\n  end\n\n  -- è·å–åˆ†é¡µæ¡ä»¶ï¼Œæœ‰é»˜è®¤å€¼\n  options = get_pagination_options(self, options)\n\n  if size ~= nil then\n    local ok, err = validate_size_value(size, options.pagination.max_page_size)\n    if not ok then\n      local err_t = self.errors:invalid_size(err)\n      return nil, tostring(err_t), err_t\n    end\n\n  else\n    size = options.pagination.page_size\n  end\n\n  local ok, errors = validate_options_value(self, options)\n  if not ok then\n    local err_t = self.errors:invalid_options(errors)\n    return nil, tostring(err_t), err_t\n  end\n\n  local pager = function(size, offset, options)\n    return self.strategy:page(size, offset, options)\n  end\n\n  return iteration.by_row(self, pager, size, options)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eé»˜è®¤åˆ†é¡µå‚æ•°åœ¨ \u003ccode\u003edb/strategies/connector.lua\u003c/code\u003e æ–‡ä»¶ä¸­ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal Connector = {\n  defaults = {\n    -- é»˜è®¤åˆ†é¡µæ¡ä»¶\n    pagination = {\n      page_size     = 1000,\n      max_page_size = 50000,\n    },\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ¥ä¸‹æ¥ä¼šéå†æ‰€æœ‰çš„ Routesï¼Œé€ä¸ªè°ƒç”¨ \u003ccode\u003eshould_process_route()\u003c/code\u003e å’Œ \u003ccode\u003eget_service_for_route()\u003c/code\u003e æ–¹æ³•ï¼Œå‰è€…ä¼šåˆ¤æ–­ Nginx Subsystem æ˜¯å¦å’Œ Route åè®®ä¸€è‡´ï¼Œåè€…å…ˆåœ¨ç¼“å­˜ä¸­æŸ¥æ‰¾ Serviceï¼Œå¦‚æœç¼“å­˜ä¸­ä¸å­˜åœ¨åˆ™ä»æ•°æ®åº“ä¸­è·å–ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  local function get_service_for_route(db, route, services_init_cache)\n    -- route å…³è”çš„ service å¤–é”®\n    local service_pk = route.service\n    if not service_pk then\n      return nil\n    end\n\n    -- æŸ¥æ‰¾ç¼“å­˜ table é‡Œçš„ service\n    local id = service_pk.id\n    local service = services_init_cache[id]\n    if service then\n      return service\n    end\n\n    local err\n\n    -- kong.core_cache is available, not in init phase\n    if kong.core_cache then\n      -- é€šè¿‡ mlcache æŸ¥è¯¢ service\n      local cache_key = db.services:cache_key(service_pk.id, nil, nil, nil, nil,\n                                              route.ws_id)\n      -- æŸ¥è¯¢ cache è·å–ï¼Œæ²¡æœ‰è·å–åˆ°åˆ™è°ƒç”¨ load_service_from_db è·å–\n      service, err = kong.core_cache:get(cache_key, TTL_ZERO,\n                                    load_service_from_db, service_pk)\n\n    else -- init phase, kong.core_cache not available\n\n      -- A new service/route has been inserted while the initial route\n      -- was being created, on init (perhaps by a different Kong node).\n      -- Load the service individually and update services_init_cache with it\n      -- ç›´æ¥æŸ¥è¯¢æ•°æ®åº“è·å– service\n      service, err = load_service_from_db(service_pk)\n      services_init_cache[id] = service\n    end\n\n    if err then\n      return nil, \"error raised while finding service for route (\" .. route.id .. \"): \" ..\n                  err\n\n    elseif not service then\n      return nil, \"could not find service for route (\" .. route.id .. \")\"\n    end\n\n\n    -- TODO: this should not be needed as the schema should check it already\n    if SUBSYSTEMS[service.protocol] ~= subsystem then\n      log(WARN, \"service with protocol '\", service.protocol,\n                \"' cannot be used with '\", subsystem, \"' subsystem\")\n\n      return nil\n    end\n\n    return service\n  end\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eload_service_from_db()\u003c/code\u003e æ–¹æ³•ä¸­åªæ˜¯ç®€å•è°ƒç”¨ \u003ccode\u003eDAO:select()\u003c/code\u003e æ–¹æ³•ï¼Œå–å‡º Service åŒæ—¶ç¼“å­˜åˆ° \u003ccode\u003eservices_init_cache\u003c/code\u003e table ä¸­ï¼Œä¸æ›´æ–° \u003ccode\u003eKong.core_cache\u003c/code\u003e ç»„ä»¶ã€‚\u003c/p\u003e\n\u003cp\u003eå¯¹æ•°æ®åº“å®ä½“å¯¹è±¡çš„å¤„ç†ä¸­ï¼Œåªæœ‰\u003ccode\u003ecreate\u003c/code\u003e ã€\u003ccode\u003eupdate\u003c/code\u003eã€\u003ccode\u003edelete\u003c/code\u003e ä¼šé€šè¿‡äº‹ä»¶å¹¿æ’­åˆ°å…¶ä»– Worker åŒæ­¥ï¼Œåé¢äº‹ä»¶çš„ä¸€èŠ‚æˆ‘ä»¬ä¼šè¯¦ç»†é˜è¿°ã€‚\u003c/p\u003e\n\u003cp\u003eæ¥ä¸‹æ¥å°† \u003ccode\u003e{router, service}\u003c/code\u003e æ•°ç»„ä¼ å…¥ \u003ccode\u003erouter.iua\u003c/code\u003e ä¸­ \u003ccode\u003eRouter.new()\u003c/code\u003e å‡½æ•°å¤„ç†ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal new_router, err = Router.new(routes)\nif not new_router then\n    return nil, \"could not create router: \" .. err\nend\n\n-- ç»‘å®š router å®ä¾‹\nrouter = new_router\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå…·ä½“æ„å»ºè·¯ç”±ç´¢å¼•çš„è¿‡ç¨‹åœ¨ \u003ccode\u003erouter.lua\u003c/code\u003e ä¸­çš„ \u003ccode\u003e_M.new(routes)\u003c/code\u003e å‡½æ•°ï¼Œä½¿ç”¨ \u003cstrong\u003e\u003ca href=\"https://github.com/openresty/lua-resty-lrucache\"\u003elua-resty-lrucache\u003c/a\u003e\u003c/strong\u003e åŒ…ç¼“å­˜ï¼Œå¯¹è·¯ç”±å’Œ Service ç»„åˆé€šè¿‡ç®—æ³•è¿›è¡Œæ’åºï¼Œæ„å»ºç´¢å¼•ï¼Œå°†è¯¸å¦‚ \u003ccode\u003e{cache_key: {route, service}}\u003c/code\u003e ç»“æ„å­˜å…¥ç¼“å­˜ä¸­ï¼Œè¿”å› Router å®ä¾‹ã€‚\u003c/p\u003e\n\u003cp\u003eè·¯ç”±ç´¢å¼• Key çš„æ„å»ºæ–¹æ³•ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e    local cache_key = req_method .. \"|\" .. req_uri .. \"|\" .. req_host ..\n                      \"|\" .. ctx.src_ip .. \"|\" .. ctx.src_port ..\n                      \"|\" .. ctx.dst_ip .. \"|\" .. ctx.dst_port ..\n                      \"|\" .. ctx.sni\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRouter å®ä¾‹ç”± Master è¿›ç¨‹æ„å»ºï¼Œå¹¶ fork åˆ°å„ä¸ª Worker è¿›ç¨‹ä½¿ç”¨ã€‚\u003c/p\u003e\n\u003cp\u003eWorker æ‰§è¡Œå®Œå…±äº«å†…å­˜çš„æ„å»ºåï¼Œæ³¨å†Œå®šæ—¶ä»»åŠ¡ï¼Œå®šæ—¶é‡å»ºç¼“å­˜ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e      -- å®šæ—¶é‡å»ºè·¯ç”±ç¼“å­˜\n      if kong.db.strategy ~= \"off\" then\n        timer_every(worker_state_update_frequency, function(premature)\n          if premature then\n            return\n          end\n\n          -- Don't wait for the semaphore (timeout = 0) when updating via the\n          -- timer.\n          -- If the semaphore is locked, that means that the rebuild is\n          -- already ongoing.\n          local ok, err = rebuild_router(ROUTER_ASYNC_OPTS)\n          if not ok then\n            log(ERR, \"could not rebuild router via timer: \", err)\n          end\n        end)\n\n        timer_every(worker_state_update_frequency, function(premature)\n          if premature then\n            return\n          end\n\n          local ok, err = rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)\n          if not ok then\n            log(ERR, \"could not rebuild plugins iterator via timer: \", err)\n          end\n        end)\n      end\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e3.2.2. Entity ç¼“å­˜\u003c/h4\u003e\n\u003cp\u003eè¿™é‡Œé¦–å…ˆä»‹ç»ä¸€ä¸‹ \u003cstrong\u003e\u003ca href=\"https://github.com/thibaultcha/lua-resty-mlcache\"\u003elua-resty-mlcache\u003c/a\u003e\u003c/strong\u003e è¿™ä¸ªç¼“å­˜åº“ï¼Œè¯¥åº“åŸºäº \u003ca href=\"https://github.com/openresty/lua-nginx-module#lua_shared_dict\"\u003elua_shared_dict\u003c/a\u003e å’Œ \u003ca href=\"https://github.com/openresty/lua-resty-lrucache\"\u003elua-resty-lrucache\u003c/a\u003e åšäº†ä¸¤å±‚ç¼“å­˜ï¼ŒWorker ä¼šæœ‰è‡ªå·±çš„è¿›ç¨‹çº§åˆ«çš„ LRU ç¼“å­˜ï¼Œé¦–å…ˆä¼šåœ¨è¿™ä¸€å±‚è¿›è¡ŒæŸ¥è¯¢ï¼Œå…¶æ¬¡ä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œç¼“å­˜ï¼Œæœ€åæä¾› callback ä»æ•°æ®åº“æŸ¥è¯¢ï¼Œä½¿ç”¨ \u003ca href=\"https://github.com/openresty/lua-resty-lock\"\u003elua-resty-lock\u003c/a\u003e åº“åˆ›å»ºé”åªå…è®¸å•ä¸ªè¿›ç¨‹æ‰§è¡Œ callbackã€‚\u003c/p\u003e\n\u003cp\u003emlcache æ¶æ„å›¾ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Nginx                                           â”‚\nâ”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚       â”‚worker     â”‚ â”‚worker     â”‚ â”‚worker     â”‚ â”‚\nâ”‚ L1    â”‚           â”‚ â”‚           â”‚ â”‚           â”‚ â”‚\nâ”‚       â”‚ Lua cache â”‚ â”‚ Lua cache â”‚ â”‚ Lua cache â”‚ â”‚\nâ”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”‚             â”‚             â”‚             â”‚       â”‚\nâ”‚             â–¼             â–¼             â–¼       â”‚\nâ”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚       â”‚                                       â”‚ â”‚\nâ”‚ L2    â”‚           lua_shared_dict             â”‚ â”‚\nâ”‚       â”‚                                       â”‚ â”‚\nâ”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”‚                           â”‚ mutex               â”‚\nâ”‚                           â–¼                     â”‚\nâ”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚\nâ”‚                  â”‚     callback     â”‚           â”‚\nâ”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                            â”‚\n  L3                        â”‚   I/O fetch\n                            â–¼\n\n                   Database, API, DNS, Disk, any I/O...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eKong.init_worker()\u003c/code\u003e ä¸­è¿›è¡Œåˆå§‹åŒ–ç¼“å­˜ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  -- åˆå§‹åŒ–åŸºäºå…±äº«å†…å­˜çš„ cache\n  local cache, err = kong_global.init_cache(kong.configuration, cluster_events, worker_events)\n  if not cache then\n    stash_init_worker_error(\"failed to instantiate 'kong.cache' module: \" ..\n                            err)\n    return\n  end\n  kong.cache = cache\n\n  local core_cache, err = kong_global.init_core_cache(kong.configuration, cluster_events, worker_events)\n  if not core_cache then\n    stash_init_worker_error(\"failed to instantiate 'kong.core_cache' module: \" ..\n                            err)\n    return\n  end\n  kong.core_cache = core_cache\n\n  ok, err = runloop.set_init_versions_in_cache()\n  if not ok then\n    stash_init_worker_error(err) -- 'err' fully formatted\n    return\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eglobal.init_cache()\u003c/code\u003e ç»“æ„å¦‚ä¸‹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction _GLOBAL.init_cache(kong_config, cluster_events, worker_events)\n  local db_cache_ttl = kong_config.db_cache_ttl\n  local db_cache_neg_ttl = kong_config.db_cache_neg_ttl\n  local cache_pages = 1\n  if kong_config.database == \"off\" then\n    db_cache_ttl = 0\n    db_cache_neg_ttl = 0\n    cache_pages = 2\n  end\n\n  return kong_cache.new {\n    shm_name          = \"kong_db_cache\",\n    cluster_events    = cluster_events,\n    worker_events     = worker_events,\n    ttl               = db_cache_ttl,\n    neg_ttl           = db_cache_neg_ttl or db_cache_ttl,\n    resurrect_ttl     = kong_config.resurrect_ttl,\n    cache_pages       = cache_pages,\n    resty_lock_opts   = {\n      exptime = 10,\n      timeout = 5,\n    },\n  }\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæœ€ç»ˆä¼šè°ƒç”¨ \u003ccode\u003ecache.lua\u003c/code\u003e ä¸­ \u003ccode\u003e_M.new()\u003c/code\u003e è¿›è¡Œå¿…è¦å‚æ•°çš„éªŒè¯ï¼Œæ£€æµ‹å…±äº«å†…å­˜å—æ˜¯å¦å¯ä»¥è®¿é—®ï¼Œå…³è”é›†ç¾¤äº‹ä»¶å’Œ Worker äº‹ä»¶ï¼Œå®šä¹‰åºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„æ–¹æ³•ï¼Œå¯¹ mlcache è¿›è¡Œä¸€å±‚å°è£…ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction _M.new(opts)\n  -- opts validation\n\n  opts = opts or {}\n\n  local mlcaches = {}\n  local shm_names = {}\n\n  for i = 1, opts.cache_pages or 1 do\n    local channel_name  = (i == 1) and \"mlcache\"                 or \"mlcache_2\"\n    local shm_name      = (i == 1) and opts.shm_name             or opts.shm_name .. \"_2\"\n    local shm_miss_name = (i == 1) and opts.shm_name .. \"_miss\"  or opts.shm_name .. \"_miss_2\"\n\n    if ngx.shared[shm_name] then\n      local mlcache, err = resty_mlcache.new(shm_name, shm_name, {\n        shm_miss         = shm_miss_name,\n        shm_locks        = \"kong_locks\",\n        shm_set_retries  = 3,\n        lru_size         = LRU_SIZE,\n        ttl              = max(opts.ttl     or 3600, 0),\n        neg_ttl          = max(opts.neg_ttl or 300,  0),\n        resurrect_ttl    = opts.resurrect_ttl or 30,\n        resty_lock_opts  = opts.resty_lock_opts,\n        ipc = { -- è¿›ç¨‹é—´é€šä¿¡çš„å‡½æ•°ç»‘å®š\n          register_listeners = function(events)\n            for _, event_t in pairs(events) do\n              opts.worker_events.register(function(data)\n                event_t.handler(data)\n              end, channel_name, event_t.channel)\n            end\n          end,\n          broadcast = function(channel, data)\n            local ok, err = opts.worker_events.post(channel_name, channel, data)\n            if not ok then\n              log(ERR, \"failed to post event '\", channel_name, \"', '\",\n                       channel, \"': \", err)\n            end\n          end\n        }\n      })\n      if not mlcache then\n        return nil, \"failed to instantiate mlcache: \" .. err\n      end\n      mlcaches[i] = mlcache\n      shm_names[i] = shm_name\n    end\n  end\n\n  local curr_mlcache = 1\n\n  if opts.cache_pages == 2 then\n    curr_mlcache = ngx.shared.kong:get(\"kong:cache:\" .. opts.shm_name .. \":curr_mlcache\") or 1\n  end\n\n  local self          = {\n    cluster_events    = opts.cluster_events,\n    mlcache           = mlcaches[curr_mlcache],\n    mlcaches          = mlcaches,\n    shm_names         = shm_names,\n    curr_mlcache      = curr_mlcache,\n  }\n\n  local ok, err = self.cluster_events:subscribe(\"invalidations\", function(key)\n    log(DEBUG, \"received invalidate event from cluster for key: '\", key, \"'\")\n    self:invalidate_local(key)\n  end)\n  if not ok then\n    return nil, \"failed to subscribe to invalidations cluster events \" ..\n                \"channel: \" .. err\n  end\n\n  _init[opts.shm_name] = true\n\n  return setmetatable(self, mt)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåˆå§‹åŒ–å®Œç¼“å­˜æ¨¡å—åï¼ŒWorker ä¼šæ ¹æ®é…ç½®æ–‡ä»¶ä¸­çš„ \u003ccode\u003edb_cache_warmup_entities\u003c/code\u003e åŠ è½½æŒ‡å®šçš„æ•°æ®åº“èµ„æºåˆ°å†…å­˜è¿›è¡Œç¼“å­˜ï¼Œé»˜è®¤é…ç½®ä¼šç¼“å­˜ \u003ccode\u003eservices, plugins\u003c/code\u003eã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLRU_SIZE\u003c/code\u003e å€¼ä¸º 500,000ï¼Œå•ä½æ˜¯ itemï¼Œè®¾ç½®æœ€å¤§èƒ½å‚¨å­˜çš„ item æ•°é‡ï¼Œè¿™ä¸ªå€¼è¡¨ç¤ºå•ä¸ª Worker LRU Cache æœ€å¤§å ç”¨ 500M å†…å­˜ã€‚\u003c/p\u003e\n\u003cp\u003eWorker ä¼šæ ¹æ®é…ç½®é¡¹åŠ è½½æ•°æ®åº“å®ä½“åˆ°å…±äº«å†…å­˜ç¼“å­˜ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function execute_cache_warmup(kong_config)\n  if kong_config.database == \"off\" then\n    return true\n  end\n\n  -- åªåœ¨ä¸€ä¸ª worker ä¸Šæ‰§è¡Œæ“ä½œ\n  -- åŠ è½½æ•°æ®åº“å®ä½“åˆ°å…±äº«å†…å­˜ç¼“å­˜\n  if ngx.worker.id() == 0 then\n    local ok, err = cache_warmup.execute(kong_config.db_cache_warmup_entities)\n    if not ok then\n      return nil, err\n    end\n  end\n\n  return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¿™é‡Œåªåœ¨ä¸€ä¸ª Worker è¿›ç¨‹ä¸ŠåŠ è½½æ•°æ®åº“æ•°æ®ï¼ŒéšååŒæ­¥åˆ°å…¶ä»–çš„ Worker ä¸Šã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecache_warmup.execute()\u003c/code\u003e é‡ŒåšåŸºæœ¬ä¿¡æ¯çš„æ£€æµ‹ï¼Œéšåè°ƒç”¨ \u003ccode\u003ecache_warmup_single_entity(dao)\u003c/code\u003e æ–¹æ³•ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e-- åŠ è½½æ•°æ®åº“å®ä½“åˆ°ç¼“å­˜ï¼Œä»¥å®ç°æ›´å¿«çš„è®¿é—®é€Ÿåº¦\n-- åœ¨ Worker åˆå§‹åŒ–é˜¶æ®µè¿è¡Œ\n-- é»˜è®¤åŠ è½½ service, plugins\n-- å¤§å°å—é…ç½® mem_cache_size å½±å“\n-- Loads entities from the database into the cache, for rapid subsequent\n-- access. This function is intented to be used during worker initialization.\nfunction cache_warmup.execute(entities)\n  if not kong.cache or not kong.core_cache then\n    return true\n  end\n\n  for _, entity_name in ipairs(entities) do\n    if entity_name == \"routes\" then\n      -- do not spend shm memory by caching individual Routes entries\n      -- because the routes are kept in-memory by building the router object\n      kong.log.notice(\"the 'routes' entry is ignored in the list of \",\n                      \"'db_cache_warmup_entities' because Kong \",\n                      \"caches routes in memory separately\")\n      goto continue\n    end\n\n    local dao = kong.db[entity_name]\n    if not (type(dao) == \"table\" and dao.schema) then\n      kong.log.warn(entity_name, \" is not a valid entity name, please check \",\n                    \"the value of 'db_cache_warmup_entities'\")\n      goto continue\n    end\n\n    local ok, err = cache_warmup_single_entity(dao)\n    if not ok then\n      if err == \"no memory\" then\n        kong.log.warn(\"cache warmup has been stopped because cache \",\n                      \"memory is exhausted, please consider increasing \",\n                      \"the value of 'mem_cache_size' (currently at \",\n                      kong.configuration.mem_cache_size, \")\")\n\n        return true\n      end\n      return nil, err\n    end\n\n    ::continue::\n  end\n\n  return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eä¸ç¼“å­˜ Routesï¼Œå› ä¸º Route å·²ç»åœ¨ä¸Šä¸€èŠ‚ä¸­æ„å»ºä¸ºè·¯ç”±ç´¢å¼•æ ‘ï¼Œé€šè¿‡ fork åˆ°æ‰€æœ‰çš„ Worker å†…å­˜é‡Œäº†ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function cache_warmup_single_entity(dao)\n  local entity_name = dao.schema.name\n\n  -- é€‰å®šå‚¨å­˜åœ°æ–¹ cache/core_cache\n  local cache_store = constants.ENTITY_CACHE_STORE[entity_name]\n  -- cache å…¨å±€å¯¹è±¡\n  local cache = kong[cache_store]\n\n  ngx.log(ngx.NOTICE, \"Preloading '\", entity_name, \"' into the \", cache_store, \"...\")\n\n  local start = ngx.now()\n\n  local hosts_array, hosts_set, host_count\n  if entity_name == \"services\" then\n    hosts_array = {}\n    hosts_set = {}\n    host_count = 0\n  end\n\n  for entity, err in dao:each(nil, GLOBAL_QUERY_OPTS) do\n    if err then\n      return nil, err\n    end\n\n    if entity_name == \"services\" then\n      if utils.hostname_type(entity.host) == \"name\"\n         and hosts_set[entity.host] == nil then\n        host_count = host_count + 1\n        hosts_array[host_count] = entity.host\n        hosts_set[entity.host] = true\n      end\n    end\n\n    -- è·å– cache_key\n    local cache_key = dao:cache_key(entity)\n\n    -- è°ƒç”¨ mlcache çš„ safe_set æ–¹æ³•ï¼Œ\n    -- å†…å­˜ä¸è¶³ä¼šæŠ¥é”™\n    local ok, err = cache:safe_set(cache_key, entity)\n    if not ok then\n      return nil, err\n    end\n  end\n\n  if entity_name == \"services\" and host_count \u003e 0 then\n    ngx.timer.at(0, warmup_dns, hosts_array, host_count)\n  end\n\n  local elapsed = math.floor((ngx.now() - start) * 1000)\n\n  ngx.log(ngx.NOTICE, \"finished preloading '\", entity_name,\n                      \"' into the \", cache_store, \" (in \", tostring(elapsed), \"ms)\")\n  return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecache_warmup_single_entity()\u003c/code\u003e ä¼šåŠ è½½è¯¥ dao æ‰€æœ‰çš„æ•°æ®åˆ°å†…å­˜ä¸­ï¼Œ\u003ccode\u003eset\u003c/code\u003e æ–¹æ³•ä¼šåˆ†å‘äº‹ä»¶åŒæ­¥æ•°æ®åˆ°å…¶ä»–çš„ Worker ä¸Šï¼Œæœ€ç»ˆæ¯ä¸ª Worker éƒ½ä¼šç¼“å­˜ä¸€ä»½ã€‚\u003c/p\u003e\n\u003ch3\u003e3.3. äº‹ä»¶è®¢é˜…\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eKong.init_worker()\u003c/code\u003e ä¸­åˆå§‹åŒ– Worker äº‹ä»¶å’Œé›†ç¾¤äº‹ä»¶ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  local worker_events, err = kong_global.init_worker_events()\n  if not worker_events then\n    stash_init_worker_error(\"failed to instantiate 'kong.worker_events' \" ..\n                            \"module: \" .. err)\n    return\n  end\n  kong.worker_events = worker_events\n\n  local cluster_events, err = kong_global.init_cluster_events(kong.configuration, kong.db)\n  if not cluster_events then\n    stash_init_worker_error(\"failed to instantiate 'kong.cluster_events' \" ..\n                            \"module: \" .. err)\n    return\n  end\n  kong.cluster_events = cluster_events\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWorker äº‹ä»¶å†…éƒ¨æ˜¯ä½¿ç”¨ \u003cstrong\u003e\u003ca href=\"https://github.com/Kong/lua-resty-worker-events\"\u003elua-resty-worker-events\u003c/a\u003e\u003c/strong\u003e åº“å®ç°çš„è¿›ç¨‹é—´äº‹ä»¶å¤„ç†ï¼ŒåŸç†æ˜¯é€šè¿‡å…±äº«å†…å­˜å‚¨å­˜äº‹ä»¶ï¼Œæ¯ç§’æ‹‰å–å…±äº«å†…å­˜ä¸­çš„äº‹ä»¶ï¼Œè¿›è¡Œå¤„ç†ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction _GLOBAL.init_worker_events()\n  -- Note: worker_events will not work correctly if required at the top of the file.\n  --       It must be required right here, inside the init function\n  local worker_events = require \"resty.worker.events\"\n\n  local ok, err = worker_events.configure {\n    shm = \"kong_process_events\", -- defined by \"lua_shared_dict\"\n    timeout = 5,            -- life time of event data in shm\n    interval = 1,           -- poll interval (seconds)\n\n    wait_interval = 0.010,  -- wait before retry fetching event data\n    wait_max = 0.5,         -- max wait time before discarding event\n  }\n  if not ok then\n    return nil, err\n  end\n\n  return worker_events\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eé›†ç¾¤äº‹ä»¶ï¼ˆå¤šä¸ª Kong ä¹‹é—´çš„é€šä¿¡ï¼‰æ˜¯é€šè¿‡å°†äº‹ä»¶å‚¨å­˜åœ¨æ•°æ®åº“ä¸­ï¼Œå®šæ—¶è½®è¯¢æ•°æ®åº“æŸ¥è¯¢äº‹ä»¶ï¼Œè¿›è¡Œå¤„ç†ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction _GLOBAL.init_cluster_events(kong_config, db)\n  return kong_cluster_events.new({\n    db            = db,\n    poll_interval = kong_config.db_update_frequency,\n    poll_offset   = kong_config.db_update_propagation,\n    poll_delay    = kong_config.db_update_propagation,\n  })\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eä»è¿™é‡Œå¯ä»¥çœ‹åˆ°é›†ç¾¤äº‹ä»¶æ˜¯é€šè¿‡æ•°æ®åº“è¡¨å®ç°çš„ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction _M:broadcast(channel, data, delay)\n  if type(channel) ~= \"string\" then\n    return nil, \"channel must be a string\"\n  end\n\n  if type(data) ~= \"string\" then\n    return nil, \"data must be a string\"\n  end\n\n  if delay and type(delay) ~= \"number\" then\n    return nil, \"delay must be a number\"\n\n  elseif self.poll_delay \u003e 0 then\n    delay = self.poll_delay\n  end\n\n  -- insert event row\n\n  --log(DEBUG, \"broadcasting on channel: '\", channel, \"' data: \", data,\n  --           \" with delay: \", delay and delay or \"none\")\n\n  local ok, err = self.strategy:insert(self.node_id, channel, nil, data, delay)\n  if not ok then\n    return nil, err\n  end\n\n  return true\nend\n\n\nfunction _M:subscribe(channel, cb, start_polling)\n  if type(channel) ~= \"string\" then\n    return error(\"channel must be a string\")\n  end\n\n  if type(cb) ~= \"function\" then\n    return error(\"callback must be a function\")\n  end\n\n  if not self.callbacks[channel] then\n    self.callbacks[channel] = { cb }\n\n    insert(self.channels, channel)\n\n  else\n    insert(self.callbacks[channel], cb)\n  end\n\n  if start_polling == nil then\n    start_polling = true\n  end\n\n  if not self.polling and start_polling and self.use_polling then\n    -- start recurring polling timer\n\n    local ok, err = timer_at(self.poll_interval, poll_handler, self)\n    if not ok then\n      return nil, \"failed to start polling timer: \" .. err\n    end\n\n    self.polling = true\n  end\n\n  return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåœ¨ \u003ccode\u003ecache.lua\u003c/code\u003e ä¸­é›†ç¾¤äº‹ä»¶è®¢é˜… cache å¤±æ•ˆäº‹ä»¶ï¼Œå†…éƒ¨è°ƒç”¨ mlcache çš„ delete æ–¹æ³•ï¼ŒåŒæ­¥åˆ°æ‰€æœ‰çš„ Worker ä¸Šã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  local ok, err = self.cluster_events:subscribe(\"invalidations\", function(key)\n    log(DEBUG, \"received invalidate event from cluster for key: '\", key, \"'\")\n    self:invalidate_local(key)\n  end)\n\n\nfunction _M:invalidate_local(key, shadow)\n  if type(key) ~= \"string\" then\n    error(\"key must be a string\", 2)\n  end\n\n  log(DEBUG, \"invalidating (local): '\", key, \"'\")\n\n  local current_page = self.curr_mlcache or 1\n  local delete_page\n  if shadow and #self.mlcaches == 2 then\n    delete_page = current_page == 1 and 2 or 1\n  else\n    delete_page = current_page\n  end\n\n  local ok, err = self.mlcaches[delete_page]:delete(key)\n  if not ok then\n    log(ERR, \"failed to delete entity from node cache: \", err)\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¿™éƒ¨åˆ†ä¸»è¦æè¿° Kong åˆå§‹åŒ–è¿‡ç¨‹ä¸­çš„äº‹ä»¶ç›¸å…³æ“ä½œï¼Œä¸»è¦æ˜¯åˆå§‹åŒ–äº‹ä»¶è®¢é˜…ï¼Œå…³è”åˆ° mlcache çš„ IPC è¿›ç¨‹é—´é€šä¿¡ï¼Œè®¢é˜… cache çš„å¤±æ•ˆäº‹ä»¶ï¼Œå¹¶å…³è” DAO çš„äº‹ä»¶å‘å¸ƒã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction DB:set_events_handler(events)\n  for _, dao in pairs(self.daos) do\n    dao.events = events\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e4. äº‹ä»¶åˆ†å‘\u003c/h2\u003e\n\u003cp\u003eKong ä¸­ä¼—å¤šéƒ¨åˆ†é€šè¿‡éé˜»å¡çš„ \u003ccode\u003engx.timer.at()\u003c/code\u003e å’Œ \u003ccode\u003engx.timer.every()\u003c/code\u003e å‡½æ•°æ‰§è¡Œå®šæ—¶ä»»åŠ¡ã€‚è¿™ä¸€éƒ¨åˆ†è¾ƒä¸ºåˆ†æ•£ï¼Œä¸»è¦å™è¿° Kong æ‰§è¡Œéé˜»å¡ä¸€æ¬¡æ€§äº‹ä»¶å¤„ç†ï¼Œå’Œå…¸å‹çš„å®šæ—¶ä»»åŠ¡ã€‚\u003c/p\u003e\n\u003ch3\u003e4.1. å•æ¬¡ä»»åŠ¡\u003c/h3\u003e\n\u003ch4\u003e4.1.1. DNS è§£æ\u003c/h4\u003e\n\u003cp\u003eåœ¨ \u003ccode\u003ecache_warmup.lua\u003c/code\u003e ä¸­ç¼“å­˜ services å¯¹è±¡æ—¶ï¼ŒKong ä¼šéé˜»å¡åœ°è·å– services ä¸­ host å¯¹åº”çš„ ipã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  if entity_name == \"services\" and host_count \u003e 0 then\n    ngx.timer.at(0, warmup_dns, hosts_array, host_count)\n  end\n\nlocal function warmup_dns(premature, hosts, count)\n  if premature then\n    return\n  end\n\n  ngx.log(ngx.NOTICE, \"warming up DNS entries ...\")\n\n  local start = ngx.now()\n\n  for i = 1, count do\n    kong.dns.toip(hosts[i])\n  end\n\n  local elapsed = math.floor((ngx.now() - start) * 1000)\n\n  ngx.log(ngx.NOTICE, \"finished warming up DNS entries\",\n                      \"' into the cache (in \", tostring(elapsed), \"ms)\")\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKong å†…éƒ¨ dns æ¨¡å—ä½¿ç”¨ \u003cstrong\u003e\u003ca href=\"https://github.com/Kong/lua-resty-dns-client\"\u003elua-resty-dns-client\u003c/a\u003e\u003c/strong\u003eï¼Œè¿™ä¸ªåº“ä¹Ÿæ˜¯ç”± Kong å¼€æºçš„ï¼Œç‰¹è‰²æœ‰ \u003ccode\u003etoip\u003c/code\u003e å‡½æ•°ä¼šæ ¹æ® dns è¿”å› ip çš„æƒé‡é…ç½®åŠ æƒè½®è¯¢çš„æƒé‡ï¼Œå‚¨å­˜ dns æŸ¥è¯¢çš„ç»“æœåœ¨å†…å­˜ä¸­ã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewarmup_dns()\u003c/code\u003e å†…è°ƒç”¨ \u003ccode\u003ekong.dns.toip()\u003c/code\u003e æ–¹æ³•ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function warmup_dns(premature, hosts, count)\n  if premature then\n    return\n  end\n\n  ngx.log(ngx.NOTICE, \"warming up DNS entries ...\")\n\n  local start = ngx.now()\n\n  for i = 1, count do\n    kong.dns.toip(hosts[i])\n  end\n\n  local elapsed = math.floor((ngx.now() - start) * 1000)\n\n  ngx.log(ngx.NOTICE, \"finished warming up DNS entries\",\n                      \"' into the cache (in \", tostring(elapsed), \"ms)\")\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4.2. å®šæ—¶ä»»åŠ¡\u003c/h3\u003e\n\u003ch4\u003e4.2.1. é›†ç¾¤ä»»åŠ¡\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ecluster_events/init.lua\u003c/code\u003e ä¸­é›†ç¾¤äº‹æƒ…è®¢é˜…å‡½æ•°é‡Œå¯ç”¨å®šæ—¶å™¨è½®è¯¢æ•°æ®åº“é›†ç¾¤äº‹ä»¶è¡¨ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction _M:subscribe(channel, cb, start_polling)\n  if type(channel) ~= \"string\" then\n    return error(\"channel must be a string\")\n  end\n\n  if type(cb) ~= \"function\" then\n    return error(\"callback must be a function\")\n  end\n\n  if not self.callbacks[channel] then\n    self.callbacks[channel] = { cb }\n\n    insert(self.channels, channel)\n\n  else\n    insert(self.callbacks[channel], cb)\n  end\n\n  if start_polling == nil then\n    start_polling = true\n  end\n\n  if not self.polling and start_polling and self.use_polling then\n    -- start recurring polling timer\n\n    local ok, err = timer_at(self.poll_interval, poll_handler, self)\n    if not ok then\n      return nil, \"failed to start polling timer: \" .. err\n    end\n\n    self.polling = true\n  end\n\n  return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¿™é‡Œå› ä¸ºè¦åœ¨æ¯æ¬¡å¾ªç¯è°ƒç”¨æ—¶è¿›è¡Œé”çš„åˆ¤æ–­ï¼Œæ‰€ä»¥æ²¡æœ‰ä½¿ç”¨ \u003ccode\u003engx.timer.every()\u003c/code\u003e å‡½æ•°ï¼Œè€Œæ˜¯ç”¨æ— é™å¾ªç¯è°ƒç”¨ \u003ccode\u003engx.timer.at()\u003c/code\u003eã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003epoll_handler = function(premature, self)\n  if premature or not self.polling then\n    -- set self.polling to false to stop a polling loop\n    return\n  end\n\n  if not get_lock(self) then\n    local ok, err = timer_at(self.poll_interval, poll_handler, self)\n    if not ok then\n      log(CRIT, \"failed to start recurring polling timer: \", err)\n    end\n\n    return\n  end\n\n  -- single worker\n\n  local pok, perr, err = pcall(poll, self)\n  if not pok then\n    log(ERR, \"poll() threw an error: \", perr)\n\n  elseif not perr then\n    log(ERR, \"failed to poll: \", err)\n  end\n\n  -- unlock\n\n  self.shm:delete(POLL_RUNNING_LOCK_KEY)\n\n  local ok, err = timer_at(self.poll_interval, poll_handler, self)\n  if not ok then\n    log(CRIT, \"failed to start recurring polling timer: \", err)\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eé”é€šè¿‡å…±äº«å†…å­˜äº‹ä»¶ï¼Œä¿è¯åªæœ‰ä¸€ä¸ª Worker æ‰§è¡Œå•æ¬¡ä»»åŠ¡ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function get_lock(self)\n  -- check if a poll is not currently running, to ensure we don't start\n  -- another poll while a worker is still stuck in its own polling (in\n  -- case it is being slow)\n  -- we still add an exptime to this lock in case something goes horribly\n  -- wrong, to ensure other workers can poll new events\n  -- a poll cannot take more than max(poll_interval * 5, 10) -- 10s min\n  local ok, err = self.shm:safe_add(POLL_RUNNING_LOCK_KEY, true,\n                                    max(self.poll_interval * 5, 10))\n  if not ok then\n    if err ~= \"exists\" then\n      log(ERR, \"failed to acquire poll_running lock: \", err)\n    end\n    -- else\n    --   log(DEBUG, \"failed to acquire poll_running lock: \",\n    --              \"a worker still holds the lock\")\n\n    return false\n  end\n\n  if self.poll_interval \u003e 0.001 then\n    -- check if interval of `poll_interval` has elapsed already, to ensure\n    -- we do not run the poll when a previous poll was quickly executed, but\n    -- another worker got the timer trigger a bit too late.\n    ok, err = self.shm:safe_add(POLL_INTERVAL_LOCK_KEY, true,\n                                self.poll_interval - 0.001)\n    if not ok then\n      if err ~= \"exists\" then\n        log(ERR, \"failed to acquire poll_interval lock: \", err)\n      end\n      -- else\n      --   log(DEBUG, \"failed to acquire poll_interval lock: \",\n      --              \"not enough time elapsed since last poll\")\n\n      self.shm:delete(POLL_RUNNING_LOCK_KEY)\n\n      return false\n    end\n  end\n\n  return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e4.2.2. æ•°æ®åº“ TTL\u003c/h4\u003e\n\u003cp\u003eä¸ºç»™ PostgreSQL åŠ ä¸Š TTLï¼ŒKong åœ¨ \u003ccode\u003einit_worker\u003c/code\u003e é˜¶æ®µè°ƒç”¨æ•°æ®åº“å±‚ \u003ccode\u003edb/strategies/postgres/connector.lua\u003c/code\u003e ä¸­ \u003ccode\u003einit_worker()\u003c/code\u003e å‡½æ•°ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e-- ä»¥ä¸‹çœç•¥éƒ¨åˆ†å†…å®¹ï¼Œåªå±•ç¤ºå…³é”®éƒ¨åˆ†\nfunction _mt:init_worker(strategies)\n  if ngx.worker.id() == 0 then\n\n      cleanup_statements[i] = concat {\n        \"  DELETE FROM \",\n        self:escape_identifier(table_name),\n        \" WHERE \",\n        column_name,\n        \" \u0026#x3C; CURRENT_TIMESTAMP AT TIME ZONE 'UTC';\"\n      }\n\n    local cleanup_statement = concat(cleanup_statements, \"\\n\")\n\n    return timer_every(60, function(premature)\n\n      local ok, err, _, num_queries = self:query(cleanup_statement)\n      if not ok then\n        if num_queries then\n          for i = num_queries + 1, cleanup_statements_count do\n            local statement = cleanup_statements[i]\n            local ok, err = self:query(statement)\n            if not ok then\n              if err then\n                log(WARN, \"unable to clean expired rows from table '\",\n                          sorted_strategies[i], \"' on PostgreSQL database (\",\n                          err, \")\")\n              else\n                log(WARN, \"unable to clean expired rows from table '\",\n                          sorted_strategies[i], \"' on PostgreSQL database\")\n              end\n            end\n          end\n\n        else\n          log(ERR, \"unable to clean expired rows from PostgreSQL database (\", err, \")\")\n        end\n      end\n    end)\n  end\n\n  return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ•°æ®åº“åˆå§‹åŒ–æ—¶æ–°å¢ä¸€ä¸ª \u003ccode\u003etimer\u003c/code\u003eï¼Œåœ¨åç¨‹ä¸­è°ƒç”¨å›è°ƒå‡½æ•°ï¼Œåˆ é™¤ TTL è¿‡æœŸçš„ rowsã€‚\u003c/p\u003e\n\u003ch4\u003e4.2.3. æ›´æ–°è·¯ç”±ç´¢å¼•\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ekong.init_worker()\u003c/code\u003e ä¼šæ·»åŠ å®šæ—¶ä»»åŠ¡ï¼Œå®šæ—¶æ›´æ–°ç¼“å­˜ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e      -- å®šæ—¶é‡å»ºè·¯ç”±ç¼“å­˜\n      if kong.db.strategy ~= \"off\" then\n        timer_every(worker_state_update_frequency, function(premature)\n          if premature then\n            return\n          end\n\n          -- Don't wait for the semaphore (timeout = 0) when updating via the\n          -- timer.\n          -- If the semaphore is locked, that means that the rebuild is\n          -- already ongoing.\n          local ok, err = rebuild_router(ROUTER_ASYNC_OPTS)\n          if not ok then\n            log(ERR, \"could not rebuild router via timer: \", err)\n          end\n        end)\n\n        timer_every(worker_state_update_frequency, function(premature)\n          if premature then\n            return\n          end\n\n          local ok, err = rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)\n          if not ok then\n            log(ERR, \"could not rebuild plugins iterator via timer: \", err)\n          end\n        end)\n      end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå®é™…è°ƒç”¨é¡ºåºæ˜¯å¼€ä¸€ä¸ª cosocket åç¨‹ï¼Œåˆ¤æ–­ routes æ˜¯å¦æœ‰å˜åŒ–ï¼Œå˜åŒ–åˆ™é‡æ„è·¯ç”±ç¼“å­˜ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  rebuild_router = function(opts)\n    return rebuild(\"router\", update_router, router_version, opts)\n  end\n\nlocal function rebuild(name, callback, version, opts)\n  local current_version, err = kong.core_cache:get(name .. \":version\", TTL_ZERO,\n                                                   utils.uuid)\n  if err then\n    return nil, \"failed to retrieve \" .. name .. \" version: \" .. err\n  end\n\n  if current_version == version then\n    return true\n  end\n\n  -- å¼€ä¸€ä¸ª cosocket åç¨‹è°ƒç”¨ callback\n  return concurrency.with_coroutine_mutex(opts, callback)\nend\n\n  update_router = function()\n    -- we might not need to rebuild the router (if we were not\n    -- the first request in this process to enter this code path)\n    -- check again and rebuild only if necessary\n    local version, err = get_router_version()\n    if err then\n      return nil, \"failed to retrieve router version: \" .. err\n    end\n\n    if version == router_version then\n      return true\n    end\n\n    local ok, err = build_router(version)\n    if not ok then\n      return nil, --[[ 'err' fully formatted ]] err\n    end\n\n    return true\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæœ€ç»ˆè¿˜ä¼šè°ƒç”¨åˆ° \u003ccode\u003ebuild_router()\u003c/code\u003e æ–¹æ³•ï¼Œæˆ‘ä»¬å·²ç»åœ¨ 1.2.1 ä¸­æè¿°è¿‡ã€‚\u003c/p\u003e\n\u003ch2\u003e5. äº‹ä»¶å¤„ç†\u003c/h2\u003e\n\u003cp\u003eWorker é—´çš„äº‹ä»¶å¤„ç†ä½¿ç”¨ \u003ccode\u003elua-resty-worker-events\u003c/code\u003e åº“ã€‚\u003c/p\u003e\n\u003cp\u003eäº‹ä»¶è®¢é˜…å‡½æ•°ï¼š\u003ccode\u003eevents.register(callback, source, event1, event2, ...)\u003c/code\u003eï¼Œcallback æ–¹æ³• \u003ccode\u003ecallback = function(data, event, source, pid)\u003c/code\u003eã€‚\u003c/p\u003e\n\u003cp\u003eäº‹ä»¶å‘å¸ƒå‡½æ•°ï¼š\u003ccode\u003esuccess, err = events.post(source, event, data, unique)\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003e5.1. æ•°æ®åº“äº‹ä»¶\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edb/dao/init.lua\u003c/code\u003e ä¸­å®šä¹‰äº† DAO ç›¸å…³çš„æ“ä½œæ–¹æ³•ï¼Œæˆ‘å·²ç»åœ¨ 1.1.3 ä¸­ç®€å•é˜è¿°è¿‡äº†ã€‚\u003c/p\u003e\n\u003cp\u003eæ•°æ®åº“ç›¸å…³å®ä½“çš„ CRUDï¼ˆå…¶å®æ²¡æœ‰Rï¼‰äº‹ä»¶æœ€åä¼šè°ƒç”¨ \u003ccode\u003eDAO:post_crud_event()\u003c/code\u003e æ–¹æ³•å¹¿æ’­äº‹ä»¶ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction DAO:post_crud_event(operation, entity, old_entity, options)\n  if options and options.no_broadcast_crud_event then\n    return\n  end\n\n  if self.events then\n    local entity_without_nulls\n    if entity then\n      entity_without_nulls = remove_nulls(utils.deep_copy(entity, false))\n    end\n\n    local old_entity_without_nulls\n    if old_entity then\n      old_entity_without_nulls = remove_nulls(utils.deep_copy(old_entity, false))\n    end\n\n    local ok, err = self.events.post_local(\"dao:crud\", operation, {\n      operation  = operation,\n      schema     = self.schema,\n      entity     = entity_without_nulls,\n      old_entity = old_entity_without_nulls,\n    })\n    if not ok then\n      log(ERR, \"[db] failed to propagate CRUD operation: \", err)\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåœ¨ \u003ccode\u003edao:crud\u003c/code\u003e é€šé“å‘å¸ƒäº†ä¸€ä¸ªäº‹ä»¶ï¼Œoperation ç±»å‹æœ‰ createã€updateã€deleteã€‚\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erunloop/handler.lua\u003c/code\u003e ä¸­ \u003ccode\u003eregister_events()\u003c/code\u003e ä¼šåœ¨ \u003ccode\u003ekong.init_worker()\u003c/code\u003e ä¸­è¢«è°ƒç”¨ï¼Œæ­¤æ—¶ä¼šè®¢é˜…æ•°æ®åº“ç›¸å…³äº‹ä»¶ï¼Œæ·»åŠ å¤„ç†å‡½æ•°ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  worker_events.register(function(data)\n    if not data.schema then\n      log(ERR, \"[events] missing schema in crud subscriber\")\n      return\n    end\n\n    if not data.entity then\n      log(ERR, \"[events] missing entity in crud subscriber\")\n      return\n    end\n\n    -- invalidate this entity anywhere it is cached if it has a\n    -- caching key\n    -- å¦‚æœ entity æœ‰ cache_key åˆ™è®©å®ƒå¤±æ•ˆ\n    -- åŸºæœ¬ä¸Šä¹Ÿåªæœ‰ entity schema å®šä¹‰å‡ºé”™çš„æƒ…å†µä¸‹æ‰ä¸ä¼šæœ‰ cache_key\n\n    local cache_key = db[data.schema.name]:cache_key(data.entity)\n    local cache_obj = kong[constants.ENTITY_CACHE_STORE[data.schema.name]]\n\n    if cache_key then\n      cache_obj:invalidate(cache_key)\n    end\n\n    -- if we had an update, but the cache key was part of what was updated,\n    -- we need to invalidate the previous entity as well\n\n    if data.old_entity then\n      local old_cache_key = db[data.schema.name]:cache_key(data.old_entity)\n      if old_cache_key and cache_key ~= old_cache_key then\n        cache_obj:invalidate(old_cache_key)\n      end\n    end\n\n    if not data.operation then\n      log(ERR, \"[events] missing operation in crud subscriber\")\n      return\n    end\n\n    -- public worker events propagation\n\n    -- è·å– schema åå­—\n    local entity_channel           = data.schema.table or data.schema.name\n    local entity_operation_channel = fmt(\"%s:%s\", entity_channel,\n      data.operation)\n\n    -- crud:routes\n    local ok, err = worker_events.post_local(\"crud\", entity_channel, data)\n    if not ok then\n      log(ERR, \"[events] could not broadcast crud event: \", err)\n      return\n    end\n\n    -- crud:routes:create\n    ok, err = worker_events.post_local(\"crud\", entity_operation_channel, data)\n    if not ok then\n      log(ERR, \"[events] could not broadcast crud event: \", err)\n      return\n    end\n  end, \"dao:crud\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCRUDï¼ˆæ²¡æœ‰ Rï¼‰äº‹ä»¶å¤„ç†æµç¨‹ï¼šè°ƒç”¨ \u003ccode\u003ecache:invalidate()\u003c/code\u003e æ–¹æ³•ï¼Œæ–¹æ³•å†…éƒ¨å‘å¸ƒäº†ä¸€ä¸ª worker çº§äº‹ä»¶ï¼Œé€šçŸ¥ worker è¿›ç¨‹åˆ é™¤è¯¥æ•°æ®ï¼Œè¿˜ä¼šå‘å¸ƒä¸€ä¸ªé›†ç¾¤äº‹ä»¶ï¼Œåœ¨é›†ç¾¤é—´åŒæ­¥åˆ é™¤æ•°æ®ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  -- ä¿®æ”¹äº† Routes åä¼šæ¸…ç©º router:version ç¼“å­˜ï¼Œ\n  -- ä¼šå¯¼è‡´é‡æ–°æ„å»ºè·¯ç”±è¡¨ï¼Œè¯¦æƒ…æŸ¥çœ‹ 2.2.3\n  worker_events.register(function()\n    log(DEBUG, \"[events] Route updated, invalidating router\")\n    core_cache:invalidate(\"router:version\")\n  end, \"crud\", \"routes\")\n\n...å…¶ä»–å¯¹è±¡åŒç†\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e6. æ’ä»¶åŠ è½½\u003c/h2\u003e\n\u003ch3\u003e6.1. æ’ä»¶è¯»å–\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003einit\u003c/code\u003e é˜¶æ®µä¼šåŠ è½½é…ç½®æ–‡ä»¶ä¸­ \u003ccode\u003eplugins=bundled,skywalking-intergrator\u003c/code\u003e çš„æ’ä»¶åˆ—è¡¨ï¼Œè°ƒç”¨ Lua \u003ccode\u003erequire\u003c/code\u003e åŠ è½½å¯¹åº”çš„åŒ…ã€‚ï¼ˆæ‰€æœ‰çš„æ’ä»¶åŒ…éƒ½è¦æ±‚åœ¨ \u003ccode\u003ekong.plugins\u003c/code\u003e ä¸‹ï¼‰\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction Plugins:load_plugin_schemas(plugin_set)\n  self.handlers = nil\n\n  local go_plugins_cnt = 0\n  local handlers = {}\n  local errs\n\n  -- load installed plugins\n  for plugin in pairs(plugin_set) do\n    local handler, err = load_plugin(self, plugin)\n\n    if handler then\n      if type(handler.is) == \"function\" and handler:is(BasePlugin) then\n        -- Backwards-compatibility for 0.x and 1.x plugins inheriting from the\n        -- BasePlugin class.\n        -- TODO: deprecate \u0026#x26; remove\n        handler = handler()\n      end\n\n      if handler._go then\n        go_plugins_cnt = go_plugins_cnt + 1\n      end\n\n      handlers[plugin] = handler\n\n    else\n      errs = errs or {}\n      table.insert(errs, \"on plugin '\" .. plugin .. \"': \" .. tostring(err))\n    end\n  end\n\n  if errs then\n    return nil, \"error loading plugin schemas: \" .. table.concat(errs, \"; \")\n  end\n\n  reports.add_immutable_value(\"go_plugins_cnt\", go_plugins_cnt)\n\n  self.handlers = handlers\n\n  return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ‰€æœ‰æ’ä»¶çš„ Handler å‡½æ•°ä¼šè¢«å‚¨å­˜åœ¨ \u003ccode\u003ekong.db.plugins.handlers\u003c/code\u003eï¼Œæ•°æ®æ ¼å¼ä¸º \u003ccode\u003e{plugin_name: handler}\u003c/code\u003eã€‚\u003c/p\u003e\n\u003cp\u003eæ‰€æœ‰çš„æ’ä»¶ä¼šå‚¨å­˜åˆ° Worker è¿›ç¨‹ä¸Šï¼Œå‘¨æœŸæ€§è¿›è¡ŒåŒæ­¥æ›´æ–°ã€‚\u003c/p\u003e\n\u003cp\u003eæˆ‘æ•´ç†äº†æ’ä»¶è¡¨åŠ è½½åˆ° Lua table çš„ç»“æ„ï¼Œè¾“å‡ºæˆ YAMLï¼Œæ–¹ä¾¿ç†è§£ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003emap:\n  plugin_name: true\n\ncombos:\n  plugin_name:\n    # both: {}\n    both:\n      route_id: service_id\n    # routes: {}\n    routes:\n      route_id: true\n    # services: {}\n    services:\n      service_id: true\n    0: true # å…¨å±€æ’ä»¶\n    1: true # è·¯ç”±æ’ä»¶\n    2: true # Service æ’ä»¶\n    3: true # è·¯ç”±+Service\n    4: true # Consumer æ’ä»¶\n    5: true # è·¯ç”±+Consumer æ’ä»¶\n    6: true # è·¯ç”±+Service+Consumer æ’ä»¶\n\nloaded:\n  plugin_name:\n    handler:\n      phase_name: func()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.2. æ’ä»¶è°ƒç”¨\u003c/h3\u003e\n\u003cp\u003eæ’ä»¶ä¸ç›´æ¥å’Œè·¯ç”±è¿›è¡Œç»‘å®šï¼Œæ’ä»¶æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œå’Œ Kong çš„ç”Ÿå‘½å‘¨æœŸåŸºæœ¬ç›¸åŒã€‚åœ¨ Kong ç”Ÿå‘½å‘¨æœŸçš„å„ä¸ªé˜¶æ®µä¼šè°ƒç”¨æ’ä»¶çš„å¯¹åº”æ–¹æ³•ã€‚\u003c/p\u003e\n\u003cp\u003eæ’ä»¶åªåœ¨è°ƒç”¨é˜¶æ®µè¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦å…³è”å½“å‰ Routeã€Serviceã€å’Œ Consumerï¼Œæœ‰åˆ™ä»æ•°æ®åº“è¯»å–æ’ä»¶å…³è”çš„é…ç½®é¡¹ï¼ˆæ’ä»¶ Entityï¼‰ï¼Œå¹¶ä½¿ç”¨ \u003ccode\u003ekong.core_cache\u003c/code\u003e è¿›è¡Œç¼“å­˜ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function load_configuration_through_combos(ctx, combos, plugin)\n  local plugin_configuration\n  local name = plugin.name\n\n  local route    = ctx.route\n  local service  = ctx.service\n  local consumer = ctx.authenticated_consumer\n\n  if route and plugin.no_route then\n    route = nil\n  end\n  if service and plugin.no_service then\n    service = nil\n  end\n  if consumer and plugin.no_consumer then\n    consumer = nil\n  end\n\n  local    route_id = route    and    route.id or nil\n  local  service_id = service  and  service.id or nil\n  local consumer_id = consumer and consumer.id or nil\n\n  if kong.db.strategy == \"off\" then\n\t...\n  else\n    if route_id and service_id and consumer_id and combos[COMBO_RSC]\n      and combos.both[route_id] == service_id\n    then\n      plugin_configuration = load_configuration(ctx, name, route_id, service_id,\n                                                consumer_id)\n      if plugin_configuration then\n        return plugin_configuration\n      end\n    end\n\n    if consumer_id and combos[COMBO_C] then\n      plugin_configuration = load_configuration(ctx, name, nil, nil, consumer_id)\n      if plugin_configuration then\n        return plugin_configuration\n      end\n    end\n\n    if route_id and combos[COMBO_R] and combos.routes[route_id] then\n      plugin_configuration = load_configuration(ctx, name, route_id)\n      if plugin_configuration then\n        return plugin_configuration\n      end\n    end\n\n    ...\n\n    if combos[COMBO_GLOBAL] then\n      return load_configuration(ctx, name)\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¿™é‡Œä¼šæŸ¥è¯¢å½“å‰ Serviceã€Route å’Œ Consumer æ˜¯å¦ä¸æŸä¸ªæ’ä»¶é…å¯¹ï¼ŒæˆåŠŸåˆ™åŠ è½½å¯¹åº”çš„é…ç½®é¡¹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e--- Load the configuration for a plugin entry.\n-- Given a Route, Service, Consumer and a plugin name, retrieve the plugin's\n-- configuration if it exists. Results are cached in ngx.dict\n-- @param[type=string] name Name of the plugin being tested for configuration.\n-- @param[type=string] route_id Id of the route being proxied.\n-- @param[type=string] service_id Id of the service being proxied.\n-- @param[type=string] consumer_id Id of the donsumer making the request (if any).\n-- @treturn table Plugin configuration, if retrieved.\nlocal function load_configuration(ctx,\n                                  name,\n                                  route_id,\n                                  service_id,\n                                  consumer_id)\n  local ws_id = workspaces.get_workspace_id() or kong.default_workspace\n  local key = kong.db.plugins:cache_key(name,\n                                        route_id,\n                                        service_id,\n                                        consumer_id,\n                                        nil,\n                                        ws_id)\n  local plugin, err = kong.core_cache:get(key,\n                                          nil,\n                                          load_plugin_from_db,\n                                          key)\n  if err then\n    ctx.delay_response = false\n    ngx.log(ngx.ERR, tostring(err))\n    return ngx.exit(ngx.ERROR)\n  end\n\n  if not plugin or not plugin.enabled then\n    return\n  end\n\n  local cfg = plugin.config or {}\n\n  if not cfg.__key__ then\n    cfg.__key__ = key\n    cfg.__seq__ = next_seq\n    next_seq = next_seq + 1\n  end\n\n  cfg.route_id    = plugin.route and plugin.route.id\n  cfg.service_id  = plugin.service and plugin.service.id\n  cfg.consumer_id = plugin.consumer and plugin.consumer.id\n\n  return cfg\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ’ä»¶çš„è°ƒç”¨æœ‰ä¸¤ç§æ–¹å¼ï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eåŒæ­¥è°ƒç”¨\u003c/li\u003e\n\u003cli\u003eå¼‚æ­¥è°ƒç”¨\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eé™¤äº† \u003ccode\u003eaccess_by_lua\u003c/code\u003e é˜¶æ®µï¼Œéƒ½æ˜¯ä½¿ç”¨åŒæ­¥è°ƒç”¨ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function execute_plugins_iterator(plugins_iterator, phase, ctx)\n  local old_ws = ctx and ctx.workspace\n  for plugin, configuration in plugins_iterator:iterate(phase, ctx) do\n    if ctx then\n      if plugin.handler._go then\n        ctx.ran_go_plugin = true\n      end\n\n      kong_global.set_named_ctx(kong, \"plugin\", plugin.handler)\n    end\n\n    kong_global.set_namespaced_log(kong, plugin.name)\n    -- è¿™é‡Œæ˜¯åŒæ­¥è°ƒç”¨\n    plugin.handler[phase](plugin.handler, configuration)\n    kong_global.reset_log(kong)\n\n    if ctx then\n      ctx.workspace = old_ws\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè€Œåœ¨ \u003ccode\u003eaccess_by_lua\u003c/code\u003e é˜¶æ®µï¼Œä½¿ç”¨åç¨‹å¼‚æ­¥è°ƒç”¨ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  for plugin, plugin_conf in plugins_iterator:iterate(\"access\", ctx) do\n    if plugin.handler._go then\n      ctx.ran_go_plugin = true\n    end\n\n    if not ctx.delayed_response then\n      kong_global.set_named_ctx(kong, \"plugin\", plugin.handler)\n      kong_global.set_namespaced_log(kong, plugin.name)\n\n      -- ä½¿ç”¨ Lua coroutine å¼€å¯åç¨‹å¼‚æ­¥è°ƒç”¨æ’ä»¶å‡½æ•°\n      local err = coroutine.wrap(plugin.handler.access)(plugin.handler, plugin_conf)\n      if err then\n        kong.log.err(err)\n        ctx.delayed_response = {\n          status_code = 500,\n          content     = { message  = \"An unexpected error occurred\" },\n        }\n      end\n\n      kong_global.reset_log(kong)\n    end\n    ctx.workspace = old_ws\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e7. ç¼“å­˜æœºåˆ¶\u003c/h2\u003e\n\u003cp\u003eæœ¬èŠ‚æ ¹æ®æˆ‘å¯¹ Kong æºç çš„åˆ†æï¼Œåšä¸€ä¸ªç¼“å­˜æœºåˆ¶çš„å°å›é¡¾ã€‚\u003c/p\u003e\n\u003cp\u003eKong é’ˆå¯¹ç¼“å­˜æœ‰è¿™äº›æ“ä½œï¼š\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eåˆå§‹åŒ–ç¼“å­˜å—\u003c/li\u003e\n\u003cli\u003eé¢„è½½åŠ è½½æ•°æ®åº“å†…å®¹åˆ°ç¼“å­˜\u003c/li\u003e\n\u003cli\u003eè®¿é—®æ—¶æ‰åŠ è½½çš„æ•°æ®å†…å®¹æ·»åŠ åˆ°ç¼“å­˜\u003c/li\u003e\n\u003cli\u003etimer å®šæ—¶æ›´æ–°ç¼“å­˜\u003c/li\u003e\n\u003cli\u003eæ•°æ®åº“ CRUD æ“ä½œåˆ é™¤ç¼“å­˜\u003c/li\u003e\n\u003cli\u003eé›†ç¾¤/Worker é—´åŒæ­¥ç¼“å­˜\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eç¼“å­˜åŠ è½½å†…å®¹ï¼š\u003c/p\u003e\n\u003cp\u003eé»˜è®¤é…ç½®ä¸‹ï¼ŒKong å°†è·¯ç”±è¡¨å’Œ Routes å…¨é‡åŠ è½½åˆ°æ¯ä¸ª Worker çš„å†…å­˜ï¼ŒServices å’Œ Plugins å…¨é‡åŠ è½½åˆ°æ¯ä¸ª Worker çš„å†…å­˜å’Œå…±äº«å†…å­˜ä¸­ã€‚Upstreams å’Œ Targets æ ¹æ®è´Ÿè½½å‡è¡¡å™¨çš„è§£æåŠæ—¶ä»æ•°æ®åº“è·å–ï¼ŒåŠ è½½åˆ°å†…å­˜å’Œå…±äº«å†…å­˜ä¸­ã€‚\u003c/p\u003e\n\u003cp\u003eä¸Šè¿° Entity åŠ è½½åœ¨ç”± mlcache åº“åˆ›å»ºçš„ L1+L2 ä¸¤çº§ç¼“å­˜ \u003ccode\u003ecore_cache\u003c/code\u003e ä¸­ã€‚\u003c/p\u003e\n\u003cp\u003eè€Œ consumers åŠ è½½åˆ°åŒä¸º mlcache åˆ›å»ºçš„ä¸åŒåçš„ \u003ccode\u003ecache\u003c/code\u003e ä¸­ã€‚\u003c/p\u003e\n\u003ch2\u003e8. è¯·æ±‚ç”Ÿå‘½å‘¨æœŸ\u003c/h2\u003e\n\u003cp\u003eæœ¬èŠ‚è®²è¿°ä¸€ä¸ªè¯·æ±‚ç»è¿‡ Kong å¤„ç†çš„æµç¨‹ã€‚\u003c/p\u003e\n\u003ch3\u003e8.1. ssl_certificate_by_lua é˜¶æ®µ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function execute()\n  local sn, err = server_name()\n  if err then\n    log(ERR, \"could not retrieve SNI: \", err)\n    return ngx.exit(ngx.ERROR)\n  end\n\n  local cert_and_key, err = find_certificate(sn)\n  if err then\n    log(ERR, err)\n    return ngx.exit(ngx.ERROR)\n  end\n\n  if cert_and_key == default_cert_and_key then\n    -- use (already set) fallback certificate\n    return\n  end\n\n  -- set the certificate for this connection\n\n  local ok, err = clear_certs()\n  if not ok then\n    log(ERR, \"could not clear existing (default) certificates: \", err)\n    return ngx.exit(ngx.ERROR)\n  end\n\n  ok, err = set_cert(cert_and_key.cert)\n  if not ok then\n    log(ERR, \"could not set configured certificate: \", err)\n    return ngx.exit(ngx.ERROR)\n  end\n\n  ok, err = set_priv_key(cert_and_key.key)\n  if not ok then\n    log(ERR, \"could not set configured private key: \", err)\n    return ngx.exit(ngx.ERROR)\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ ¹æ® Server Name æŸ¥æ‰¾å¯¹åº” SSL è¯ä¹¦ Cert å’Œç§é’¥å¹¶è®¾ç½®åœ¨ Nginx ä¸Šã€‚\u003c/p\u003e\n\u003ch3\u003e8.2. rewrite_by_lua é˜¶æ®µ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  local ctx = ngx.ctx\n  if not ctx.KONG_PROCESSING_START then\n    ctx.KONG_PROCESSING_START = ngx.req.start_time() * 1000\n  end\n\n  if not ctx.KONG_REWRITE_START then\n    ctx.KONG_REWRITE_START = get_now_ms()\n  end\n\n  kong_global.set_phase(kong, PHASES.rewrite)\n  kong_resty_ctx.stash_ref()\n\n  local is_https = var.https == \"on\"\n  if not is_https then\n    log_init_worker_errors(ctx)\n  end\n\n  runloop.rewrite.before(ctx)\n\n...\n\n  rewrite = {\n    before = function(ctx)\n      ctx.host_port = HOST_PORTS[var.server_port] or var.server_port\n\n      -- special handling for proxy-authorization and te headers in case\n      -- the plugin(s) want to specify them (store the original)\n      ctx.http_proxy_authorization = var.http_proxy_authorization\n      ctx.http_te                  = var.http_te\n    end,\n  },\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåˆå§‹åŒ– \u003ccode\u003ekong.ctx\u003c/code\u003e ç”Ÿå‘½å‘¨æœŸ Contextï¼Œä¸º Context æ·»åŠ è¯·æ±‚ä¿¡æ¯ã€‚\u003c/p\u003e\n\u003ch3\u003e8.3. access_by_lua é˜¶æ®µ\u003c/h3\u003e\n\u003ch4\u003e8.3.1. è·¯ç”±åŒ¹é…\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003erunloop.access.before\u003c/code\u003e ä¼šè¿›è¡Œè°ƒç”¨ \u003ccode\u003eRouter\u003c/code\u003e å®ä¾‹è¿›è¡Œè·¯ç”±åŒ¹é…ã€‚é¦–å…ˆä¼šè°ƒç”¨ \u003ccode\u003eget_updated_router()\u003c/code\u003e åˆ¤æ–­æ˜¯å¦æœ‰è·¯ç”±æ›´æ–°ï¼Œæ²¡æœ‰åˆ™è¿”å›å½“å‰ \u003ccode\u003eRouter\u003c/code\u003e å®ä¾‹ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e      -- routing request\n      local router = get_updated_router()\n\t  -- è°ƒç”¨ Router.exec() æŸ¥æ‰¾åŒ¹é…çš„è·¯ç”±\n      local match_t = router.exec()\n      if not match_t then\n        return kong.response.exit(404, { message = \"no Route matched with those values\" })\n      end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eRouter.exec()\u003c/code\u003e æ–¹æ³•æœ€ç»ˆä¼šè°ƒç”¨ \u003ccode\u003eRouter.find_route()\u003c/code\u003e æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æ¥æ”¶è¯·æ±‚å¤´å­—æ®µï¼Œå¹¶ç”Ÿæˆè·¯ç”± Cache Keyï¼ŒæŸ¥æ‰¾å¯¹åº”çš„é¡¹ç›®ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  local function find_route(req_method, req_uri, req_host, req_scheme,\n                            src_ip, src_port,\n                            dst_ip, dst_port,\n                            sni, req_headers)\n\n    req_method = req_method or \"\"\n    req_uri = req_uri or \"\"\n    req_host = req_host or \"\"\n    req_headers = req_headers or EMPTY_T\n\n    ctx.req_method     = req_method\n    ctx.req_uri        = req_uri\n    ctx.req_host       = req_host\n    ctx.req_headers    = req_headers\n    ctx.src_ip         = src_ip or \"\"\n    ctx.src_port       = src_port or \"\"\n    ctx.dst_ip         = dst_ip or \"\"\n    ctx.dst_port       = dst_port or \"\"\n    ctx.sni            = sni or \"\"\n\n    local cache_key = req_method .. \"|\" .. req_uri .. \"|\" .. req_host ..\n                      \"|\" .. ctx.src_ip .. \"|\" .. ctx.src_port ..\n                      \"|\" .. ctx.dst_ip .. \"|\" .. ctx.dst_port ..\n                      \"|\" .. ctx.sni\n\n    do\n      local match_t = cache:get(cache_key)\n      if match_t and hits.header_name == nil then\n        return match_t\n      end\n    end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå¦‚æœ LRU ç¼“å­˜ä¸­æœ‰åŒ¹é…è·¯ç”±ï¼Œåˆ™ç›´æ¥è¿”å›ã€‚\u003c/p\u003e\n\u003cp\u003eå¦åˆ™ç»§ç»­åŒ¹é…è·¯ç”±ï¼Œç”ŸæˆåŒ¹é…é¡¹ç›®ï¼Œå¹¶å­˜å…¥ç¼“å­˜ä¸­ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e              ...\n              local match_t     = {\n                  route           = matched_route.route,\n                  service         = matched_route.service,\n                  headers         = matched_route.headers,\n                  upstream_url_t  = upstream_url_t,\n                  upstream_scheme = upstream_url_t.scheme,\n                  upstream_uri    = upstream_uri,\n                  upstream_host   = upstream_host,\n                  prefix          = request_prefix,\n                  matches         = {\n                    uri_captures  = matches.uri_captures,\n                    uri           = matches.uri,\n                    host          = matches.host,\n                    headers       = matches.headers,\n                    method        = matches.method,\n                    src_ip        = matches.src_ip,\n                    src_port      = matches.src_port,\n                    dst_ip        = matches.dst_ip,\n                    dst_port      = matches.dst_port,\n                    sni           = matches.sni,\n                  }\n                }\n\n                if band(matched_route.match_rules, MATCH_RULES.HEADER) == 0 then\n                  cache:set(cache_key, match_t)\n                end\n                ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåŒ¹é…æˆåŠŸåä¼šå°†å…³è”çš„ Route å’Œ Service å†™å…¥ \u003ccode\u003engx.ctx\u003c/code\u003e ï¼Œåœ¨æ¥ä¸‹æ¥çš„ç”Ÿå‘½å‘¨æœŸä¸­å…±äº«ã€‚\u003c/p\u003e\n\u003ch4\u003e8.3.2. è¯·æ±‚è°ƒåº¦\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003erunloop.access.after\u003c/code\u003e ä¸­æ ¹æ® Routeã€Service ç­‰æ¡ä»¶è§£æå‡ºåç«¯è¦è¯·æ±‚çš„ IPã€Portã€Schema ç­‰å‚æ•°ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e-- looks up a balancer for the target.\n-- @param target the table with the target details\n-- @param no_create (optional) if true, do not attempt to create\n-- (for thorough testing purposes)\n-- @return balancer if found, `false` if not found, or nil+error on error\nlocal function get_balancer(target, no_create)\n  -- NOTE: only called upon first lookup, so `cache_only` limitations\n  -- do not apply here\n  local hostname = target.host\n\n\n  -- first go and find the upstream object, from cache or the db\n  local upstream, err = get_upstream_by_name(hostname)\n  if upstream == false then\n    return false -- no upstream by this name\n  end\n  if err then\n    return nil, err -- there was an error\n  end\n\n  local balancer = balancers[upstream.id]\n  if not balancer then\n    if no_create then\n      return nil, \"balancer not found\"\n    else\n      log(ERR, \"balancer not found for \", upstream.name, \", will create it\")\n      return create_balancer(upstream), upstream\n    end\n  end\n\n  return balancer, upstream\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eget_balancer()\u003c/code\u003e æ ¹æ® Service çš„ Host è¿”å›æœ€ç»ˆè¯·æ±‚çš„ Targetï¼Œå’Œè´Ÿè½½å‡è¡¡å™¨ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  local ip, port, hostname, handle\n  if balancer then\n    -- have to invoke the ring-balancer\n    local hstate = run_hook(\"balancer:get_peer:pre\", target.host)\n    ip, port, hostname, handle = balancer:getPeer(dns_cache_only,\n                                          target.balancer_handle,\n                                          hash_value)\n    run_hook(\"balancer:get_peer:post\", hstate)\n    if not ip and\n      (port == \"No peers are available\" or port == \"Balancer is unhealthy\") then\n      return nil, \"failure to get a peer from the ring-balancer\", 503\n    end\n    hostname = hostname or ip\n    target.hash_value = hash_value\n    target.balancer_handle = handle\n\n  else\n    -- have to do a regular DNS lookup\n    local try_list\n    local hstate = run_hook(\"balancer:to_ip:pre\", target.host)\n    ip, port, try_list = toip(target.host, target.port, dns_cache_only)\n    run_hook(\"balancer:to_ip:post\", hstate)\n    hostname = target.host\n    if not ip then\n      log(ERR, \"DNS resolution failed: \", port, \". Tried: \", tostring(try_list))\n      if port == \"dns server error: 3 name error\" or\n         port == \"dns client error: 101 empty record received\" then\n        return nil, \"name resolution failed\", 503\n      end\n    end\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè°ƒç”¨è´Ÿè½½å‡è¡¡å™¨çš„ç­–ç•¥è·å– Target çš„ IPï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨ DNS æŸ¥è¯¢è·å– IP åœ°å€ï¼Œè¿™ä¸€æ­¥åœ¨ 2.1.1 ä¸­å·²ç»æå‰è¿›è¡Œäº† DNS é¢„ç¼“å­˜ï¼Œè¿™é‡Œå¯ä»¥ä»ç¼“å­˜ä¸­è¯»å–ã€‚\u003c/p\u003e\n\u003cp\u003eå¦‚æœ Service Host ç›´æ¥æ˜¯ IP åœ°å€ï¼Œåˆ™ä¸æ‰§è¡Œè´Ÿè½½å‡è¡¡ç­–ç•¥ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  -- ip åˆ™ç›´æ¥è¿”å›\n  if target.type ~= \"name\" then\n    -- it's an ip address (v4 or v6), so nothing we can do...\n    target.ip = target.host\n    target.port = target.port or 80 -- TODO: remove this fallback value\n    target.hostname = target.host\n    return true\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e8.4. balancer_by_lua é˜¶æ®µ\u003c/h3\u003e\n\u003cp\u003eä½¿ç”¨ \u003ccode\u003engx.balancer.set_more_tries()\u003c/code\u003e è®¾ç½®é”™è¯¯é‡è¯•æ¬¡æ•°ï¼Œä½¿ç”¨ \u003ccode\u003engx.balancer.get_last_failure()\u003c/code\u003e è·å–ä¸Šä¸€æ¬¡è¯·æ±‚é”™è¯¯è¯¦æƒ…ï¼Œåœ¨é”™è¯¯å¤„ç†ä¸­è¿›è¡Œå¯¹ä¸Šæ¸¸èŠ‚ç‚¹è¿›è¡Œè¢«åŠ¨å¥åº·æ£€æŸ¥ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  if balancer_data.try_count \u003e 1 then\n    -- only call balancer on retry, first one is done in `runloop.access.after`\n    -- which runs in the ACCESS context and hence has less limitations than\n    -- this BALANCER context where the retries are executed\n\n    -- record failure data\n    local previous_try = tries[balancer_data.try_count - 1]\n    previous_try.state, previous_try.code = get_last_failure()\n\n    -- Report HTTP status for health checks\n    local balancer = balancer_data.balancer\n    if balancer then\n      if previous_try.state == \"failed\" then\n        if previous_try.code == 504 then\n          balancer.report_timeout(balancer_data.balancer_handle)\n        else\n          balancer.report_tcp_failure(balancer_data.balancer_handle)\n        end\n\n      else\n        balancer.report_http_status(balancer_data.balancer_handle,\n                                    previous_try.code)\n      end\n    end\n\n    local ok, err, errcode = balancer_execute(balancer_data)\n    if not ok then\n      ngx_log(ngx_ERR, \"failed to retry the dns/balancer resolver for \",\n              tostring(balancer_data.host), \"' with: \", tostring(err))\n\n      ctx.KONG_BALANCER_ENDED_AT = get_now_ms()\n      ctx.KONG_BALANCER_TIME = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_BALANCER_START\n      ctx.KONG_PROXY_LATENCY = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_PROCESSING_START\n\n      return ngx.exit(errcode)\n    end\n\n  else\n    -- first try, so set the max number of retries\n    local retries = balancer_data.retries\n    if retries \u003e 0 then\n      set_more_tries(retries)\n    end\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè¯·æ±‚åˆ°æœ€ç»ˆè§£æçš„åç«¯æœåŠ¡ï¼Œä½¿ç”¨ \u003ccode\u003engx.balancer.set_current_peer()\u003c/code\u003e æ–¹æ³•è®¾ç½®è®¿é—®çš„åœ°å€ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  -- set the targets as resolved\n  ngx_log(ngx_DEBUG, \"setting address (try \", balancer_data.try_count, \"): \",\n                     balancer_data.ip, \":\", balancer_data.port)\n  -- æœ€ç»ˆè°ƒåº¦çš„åœ°å€\n  local ok, err = set_current_peer(balancer_data.ip, balancer_data.port, pool_opts)\n  if not ok then\n    ngx_log(ngx_ERR, \"failed to set the current peer (address: \",\n            tostring(balancer_data.ip), \" port: \", tostring(balancer_data.port),\n            \"): \", tostring(err))\n\n    ctx.KONG_BALANCER_ENDED_AT = get_now_ms()\n    ctx.KONG_BALANCER_TIME = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_BALANCER_START\n    ctx.KONG_PROXY_LATENCY = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_PROCESSING_START\n\n    return ngx.exit(500)\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e8.5. header_filter_by_lua é˜¶æ®µ\u003c/h3\u003e\n\u003cp\u003eæ­¤é˜¶æ®µåœ¨ Kong æ¥æ”¶å®Œä¸Šæ¸¸æœåŠ¡è¿”å›çš„ Header å­—æ®µåæ‰§è¡Œã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e      local upstream_status_header = constants.HEADERS.UPSTREAM_STATUS\n      if singletons.configuration.enabled_headers[upstream_status_header] then\n        header[upstream_status_header] = tonumber(sub(var.upstream_status or \"\", -3))\n        if not header[upstream_status_header] then\n          log(ERR, \"failed to set \", upstream_status_header, \" header\")\n        end\n      end\n\n      local hash_cookie = ctx.balancer_data.hash_cookie\n      if not hash_cookie then\n        return\n      end\n\n      local cookie = ck:new()\n      local ok, err = cookie:set(hash_cookie)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erunloop.header_filter.before\u003c/code\u003e ä¸­åœ¨è¿”å›ç»“æœçš„ header é‡ŒåŠ å…¥èŠ‚ç‚¹çŠ¶æ€ï¼Œä»¥åŠåˆ¤æ–­æ˜¯å¦éœ€è¦åŠ å…¥è´Ÿè½½å‡è¡¡å™¨ä¸€è‡´æ€§ç­–ç•¥çš„ Cookieã€‚\u003c/p\u003e\n\u003ch3\u003e8.6. body_filter_by_lua é˜¶æ®µ\u003c/h3\u003e\n\u003cp\u003eæ­¤é˜¶æ®µåœ¨æ¥æ”¶ä¸Šæ¸¸æœåŠ¡è¿”å›çš„ Body æ•°æ®æ—¶æ‰§è¡Œï¼Œæ ¹æ®æ•°æ®å¤§å°åˆ’åˆ† chunksï¼Œæ­¤é˜¶æ®µä¼šè¢«æ‰§è¡Œå¤šæ¬¡ã€‚\u003c/p\u003e\n\u003cp\u003eåœ¨ Openresty çš„ç”Ÿå‘½å‘¨æœŸé‡Œï¼Œ\u003ccode\u003ebody_filter_by_lua\u003c/code\u003e ä¸­ä½¿ç”¨ \u003ccode\u003engx.arg[1]\u003c/code\u003e è¯»å– chunkï¼Œä½¿ç”¨ \u003ccode\u003engx.arg[2]\u003c/code\u003e æ ‡è®° EOFã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e  -- è·å–åˆ°äº†æ‰€æœ‰çš„ body\n  if kong.ctx.core.response_body then\n    arg[1] = kong.ctx.core.response_body\n    arg[2] = true\n  end\n\n  if not arg[2] then\n    return\n  end\n\n  -- è·å–åˆ°æ‰€æœ‰çš„ body å\n  -- å†ç»Ÿè®¡æ‰§è¡Œæ—¶é—´\n  ctx.KONG_BODY_FILTER_ENDED_AT = get_now_ms()\n  ctx.KONG_BODY_FILTER_TIME = ctx.KONG_BODY_FILTER_ENDED_AT - ctx.KONG_BODY_FILTER_START\n\n  if ctx.KONG_PROXIED then\n    -- time spent receiving the response (header_filter + body_filter)\n    -- we could use $upstream_response_time but we need to distinguish the waiting time\n    -- from the receiving time in our logging plugins (especially ALF serializer).\n    ctx.KONG_RECEIVE_TIME = ctx.KONG_BODY_FILTER_ENDED_AT - (ctx.KONG_HEADER_FILTER_START or\n                                                             ctx.KONG_BALANCER_ENDED_AT or\n                                                             ctx.KONG_BALANCER_START or\n                                                             ctx.KONG_ACCESS_ENDED_AT)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e8.7. log_by_lua é˜¶æ®µ\u003c/h3\u003e\n\u003cp\u003eè°ƒç”¨ Lua çš„åƒåœ¾å›æ”¶å™¨ç»Ÿè®¡ Kong å ç”¨å†…å­˜æƒ…å†µï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal update_lua_mem\ndo\n  local pid = ngx.worker.pid\n  local kong_shm = ngx.shared.kong\n\n  local Lua_MEM_SAMPLE_RATE = 10 -- seconds\n  local last = ngx.time()\n\n  local collectgarbage = collectgarbage\n\n  update_lua_mem = function(force)\n    local time = ngx.time()\n\n    if force or time - last \u003e= Lua_MEM_SAMPLE_RATE then\n      local count = collectgarbage(\"count\")\n\n      local ok, err = kong_shm:safe_set(\"kong:mem:\" .. pid(), count)\n      if not ok then\n        log(ERR, \"could not record Lua VM allocated memory: \", err)\n      end\n\n      last = ngx.time()\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ ¹æ®å“åº”ç»“æœè°ƒç”¨è´Ÿè½½å‡è¡¡å™¨è°ƒæ•´ä¸Šæ¸¸èŠ‚ç‚¹çš„æƒé‡ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e      -- If response was produced by an upstream (ie, not by a Kong plugin)\n      -- Report HTTP status for health checks\n      local balancer_data = ctx.balancer_data\n      if balancer_data and balancer_data.balancer_handle then\n        local status = ngx.status\n        if status == 504 then\n          balancer_data.balancer.report_timeout(balancer_data.balancer_handle)\n        else\n          balancer_data.balancer.report_http_status(\n            balancer_data.balancer_handle, status)\n        end\n        -- release the handle, so the balancer can update its statistics\n        balancer_data.balancer_handle:release()\n      end\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e9. Admin API\u003c/h2\u003e\n\u003cp\u003eKong Admin API å…¥å£ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003efunction Kong.admin_content(options)\n  local ctx = ngx.ctx\n  if not ctx.workspace then\n    ctx.workspace = kong.default_workspace\n  end\n\n  return serve_content(\"kong.api\", options)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function serve_content(module, options)\n\n  -- CORS è·¨åŸŸç›¸å…³\n  header[\"Access-Control-Allow-Origin\"] = options.allow_origin or \"*\"\n\n  -- å¯åŠ¨ lapis\n  lapis.serve(module)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå…³äº \u003ca href=\"https://leafo.net/lapis/\"\u003eLapis\u003c/a\u003eï¼š\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLapis is a framework for building web applications using \u003ca href=\"https://moonscript.org\"\u003eMoonScript\u003c/a\u003e or \u003ca href=\"https://lua.org\"\u003eLua\u003c/a\u003e that runs inside of a customized version of \u003ca href=\"https://nginx.org\"\u003eNginx\u003c/a\u003e called \u003ca href=\"https://openresty.org\"\u003eOpenResty\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e# api/init.lua\n-- åŠ è½½å›ºå®šè·¯ç”±\n-- Load core routes\nfor _, v in ipairs({\"kong\", \"health\", \"cache\", \"config\", \"clustering\"}) do\n  local routes = require(\"kong.api.routes.\" .. v)\n  api_helpers.attach_routes(app, routes)\nend\n\n  local routes = {}\n\n  -- DAO Routes\n  for _, dao in pairs(singletons.db.daos) do\n    if dao.schema.generate_admin_api ~= false and not dao.schema.legacy then\n      routes = Endpoints.new(dao.schema, routes)\n    end\n  end\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåˆå§‹åŒ–æ„å»ºè·¯ç”±ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003e# api/endpoints.lua\n-- åˆ›å»ºåŸºç¡€è·¯ç”±\n-- Generates admin api endpoint functions\n--\n-- Examples:\n--\n-- /routes\n-- /routes/:routes\n-- /routes/:routes/service\n-- /services/:services/routes\n--\n-- and\n--\n-- /services\n-- /services/:services\n-- /services/:services/routes/:routes\nlocal function generate_endpoints(schema, endpoints)\n  -- list è·¯ç”±\n  -- e.g. /routes\n  generate_collection_endpoints(endpoints, schema)\n\n  -- å•ä½“è·¯ç”±\n  -- e.g. /routes/:routes\n  generate_entity_endpoints(endpoints, schema)\n\n  -- åˆ¤æ–­æ˜¯å¦æœ‰å…³è”å¯¹è±¡\n  -- ä¾‹å¦‚ route å…³è” services\n  for foreign_field_name, foreign_field in schema:each_field() do\n    -- å¤–é”®\n    if foreign_field.type == \"foreign\" and not foreign_field.schema.legacy then\n      -- e.g. /routes/:routes/service\n      generate_entity_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name, true)\n\n      -- e.g. /services/:services/routes\n      generate_collection_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name)\n\n      -- e.g. /services/:services/routes/:routes\n      generate_entity_endpoints(endpoints, foreign_field.schema, schema, foreign_field_name)\n    end\n  end\n\n  return endpoints\nend\n\n-- Generates admin api collection endpoint functions\n--\n-- Examples:\n--\n-- /routes\n-- /services/:services/routes\n--\n-- and\n--\n-- /services\nlocal function generate_collection_endpoints(endpoints, schema, foreign_schema, foreign_field_name)\n  local collection_path\n\n  -- å¤–é”®å…³è”\n  if foreign_schema then\n    collection_path = fmt(\"/%s/:%s/%s\", foreign_schema.admin_api_name or\n                                        foreign_schema.name,\n                                        foreign_schema.name,\n                                        schema.admin_api_nested_name or\n                                        schema.admin_api_name or\n                                        schema.name)\n\n  else\n    -- æ²¡æœ‰å¤–é”®å…³è”\n    collection_path = fmt(\"/%s\", schema.admin_api_name or\n                                 schema.name)\n  end\n\n  endpoints[collection_path] = {\n    schema  = schema,\n    methods = {\n      --OPTIONS = method_not_allowed,\n      --HEAD    = method_not_allowed,\n      GET     = get_collection_endpoint(schema, foreign_schema, foreign_field_name),\n      POST    = post_collection_endpoint(schema, foreign_schema, foreign_field_name),\n      --PUT     = method_not_allowed,\n      --PATCH   = method_not_allowed,\n      --DELETE  = method_not_allowed,\n    },\n  }\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåªå…³æ³¨ POST è¯·æ±‚å¤„ç†çš„éƒ¨åˆ†ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal function post_collection_endpoint(schema, foreign_schema, foreign_field_name, method)\n  return function(self, db, helpers, post_process)\n    if foreign_schema then\n      local foreign_entity, _, err_t = select_entity(self, db, foreign_schema)\n      if err_t then\n        return handle_error(err_t)\n      end\n\n      if not foreign_entity then\n        return not_found()\n      end\n\n      self.args.post[foreign_field_name] = foreign_schema:extract_pk_values(foreign_entity)\n    end\n\n    -- å¤„ç†è¯·æ±‚ï¼Œå‚æ•°æ ¡éªŒï¼Œæ’å…¥æ•°æ®\n    local entity, _, err_t = insert_entity(self, db, schema, method)\n    if err_t then\n      return handle_error(err_t)\n    end\n\n    -- å›è°ƒå‡½æ•°\n    if post_process then\n      entity, _, err_t = post_process(entity)\n      if err_t then\n        return handle_error(err_t)\n      end\n    end\n\n    return created(entity)\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAdmin API ä»…ä»…æ˜¯ä¸€å±‚ API å°è£…ï¼Œä¸è´Ÿè´£èƒŒåçš„äº‹ä»¶å¤„ç†å’Œæ•°æ®åŒæ­¥ï¼ŒèƒŒåçš„äº‹ä»¶å¤„ç†åœ¨æ–‡ç« äº‹ä»¶å¤„ç†éƒ¨åˆ†é˜è¿°è¿‡äº†ã€‚\u003c/p\u003e\n\u003ch2\u003e10. æ’ä»¶å¼€å‘\u003c/h2\u003e\n\u003cp\u003eç®€å•ä»‹ç»ä¸€ä¸‹æ’ä»¶å¼€å‘èƒ½ç”¨ä¸Šçš„ä¸€äº›å° Trickã€‚\u003c/p\u003e\n\u003ch3\u003e10.1. å¤šå±‚ Schema åµŒå¥—\u003c/h3\u003e\n\u003cp\u003eçœ‹ç€å¾ˆæ¶å¿ƒå§ï¼Œä½†è¿™æ˜¯å¤šå±‚ Schema åµŒå¥—çš„æ ·å­ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal schema = {\n    name = plugin_name,\n    fields = {\n        { consumer = typedefs.no_consumer },\n        { protocols = typedefs.protocols_http },\n        { config = {\n          type = \"record\",\n          fields = { {\n            rules = {\n              type = \"array\",\n              elements = {\n                type = \"record\",\n                fields = { {\n                  match = {\n                    type = \"array\",\n                    elements = {\n                      type = \"record\",\n                      fields = {\n                        { vars = { type = \"array\", elements = {\n                            type = \"array\",\n                            elements = { type = \"string\" }\n                        } } }\n                      }\n                    }\n                  }\n                } }\n              }\n            }\n          } },\n        } }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e10.2. è‡ªå®šä¹‰ Schema æ ¡éªŒå™¨\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal expr = require(\"resty.expr.v1\")\n\nlocal schema_validator = function(conf)\n    if conf.rules then\n        for _, rule in ipairs(conf.rules) do\n            if rule.match and type(rule.match) == \"table\" then\n                for _, m in pairs(rule.match) do\n                    local ok, err = expr.new(m.vars)\n                    if not ok then\n                        return false, \"failed to validate the 'vars' expression: \" .. err\n                    end\n                end\n            end\n        end\n    end\n\n    return true\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e10.3. æ—¥å¿—æ‰“å° Table\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003ekong.log.inspect.on()\nkong.log.debug(\"Lua table: \", t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e10.4. è‡ªå®šä¹‰æ—¥å¿—è¾“å‡º\u003c/h3\u003e\n\u003cp\u003e2.3.0 ç‰ˆæœ¬ä»¥ä¸Šå¯ç”¨ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-lua\"\u003elocal entry = {\n    entries = ctx.log_entries,\n    id = self.transaction_id,\n    action = action_name,\n}\n\nkong.log.set_serialize_value(\"waf\", entry)\n\u003c/code\u003e\u003c/pre\u003e\n\u003csection data-footnotes class=\"footnotes\"\u003e\u003ch2 class=\"sr-only\" id=\"footnote-label\"\u003eFootnotes\u003c/h2\u003e\n\u003col\u003e\n\u003cli id=\"user-content-fn-kong\"\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Kong/kong\"\u003eğŸ¦ The Cloud-Native API Gateway\u003c/a\u003e \u003ca href=\"#user-content-fnref-kong\" data-footnote-backref=\"\" aria-label=\"Back to reference 1\" class=\"data-footnote-backref\"\u003eâ†©\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]\n"])</script></body></html>