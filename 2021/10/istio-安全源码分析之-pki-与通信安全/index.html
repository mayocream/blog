<!doctype html><html lang=zh-hans><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Istio å®‰å…¨æºç åˆ†æä¹‹ PKI ä¸é€šä¿¡å®‰å…¨ - Mayo's Blog</title>
<meta name=description content="è¿™ç¯‡æ–‡ç« æ˜¯æˆ‘åœ¨å…¬å¸å†…éƒ¨æ¢ç´¢ä¸å®è·µç§æœ‰ CACertification Authority ä¸åŒå‘ TLSmutual TLS è®¤è¯ä½“ç³»æ—¶ï¼Œå­¦ä¹  Istio å®‰å…¨è®¤è¯æ¶æ„çš„ç¬”è®°ï¼Œæœ€åˆäº 2020.12.03 å‘è¡¨äºå›¢é˜Ÿå†…éƒ¨ï¼Œç°åœ¨çœ‹æ¥æ–‡å­—ç©ºæ´ä¹åŠ›ï¼Œæ‰€ä»¥æˆ‘">
<meta name=author content>
<link rel=preconnect href=https://cdn.jsdelivr.net>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Press+Start+2P" rel=stylesheet>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400&family=Noto+Sans+JP:wght@300;400&family=Noto+Sans+SC:wght@300;400&family=Noto+Serif:wght@300;400&family=Noto+Serif+JP:wght@300;400&family=Noto+Serif+SC:wght@300;400&family=Source+Code+Pro:wght@300;400" rel=stylesheet>
<link rel=stylesheet href="/bundle.css?v=1635677544" media=all>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.css>
<link rel=icon href=https://github.com/mayocream.png><meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://shoujo.ink/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-JKVXF5HSKT','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="Istio å®‰å…¨æºç åˆ†æä¹‹ PKI ä¸é€šä¿¡å®‰å…¨">
<meta property="og:description" content="è¿™ç¯‡æ–‡ç« æ˜¯æˆ‘åœ¨å…¬å¸å†…éƒ¨æ¢ç´¢ä¸å®è·µç§æœ‰ CACertification Authority ä¸åŒå‘ TLSmutual TLS è®¤è¯ä½“ç³»æ—¶ï¼Œå­¦ä¹  Istio å®‰å…¨è®¤è¯æ¶æ„çš„ç¬”è®°ï¼Œæœ€åˆäº 2020.12.03 å‘è¡¨äºå›¢é˜Ÿå†…éƒ¨ï¼Œç°åœ¨çœ‹æ¥æ–‡å­—ç©ºæ´ä¹åŠ›ï¼Œæ‰€ä»¥æˆ‘">
<meta property="og:type" content="article">
<meta property="og:url" content="https://shoujo.ink/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-26T23:00:00+08:00">
<meta property="article:modified_time" content="2021-10-26T23:00:00+08:00"><meta property="og:site_name" content="Mayo's Blog">
</head>
</html>
<body><script src=https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>const opts={bottom:'32px',right:'unset',left:'32px',time:'0.3s',mixColor:'#fff',backgroundColor:'#fff',buttonColorDark:'#100f2c',buttonColorLight:'#fff',saveInCookies:!0,label:'ğŸŒ“',autoMatchOsTheme:!0};let darkmode;window.matchMedia('only screen and (min-width: 680px)').matches?(darkmode=new Darkmode(opts),darkmode.showWidget()):(localStorage.removeItem('darkmode'),darkmode=new Darkmode(opts)),window.darkmode=darkmode,document.addEventListener('DOMContentLoaded',function(){document.body.style.opacity=1})</script>
<main class=page-content aria-label=Content>
<div class=wrapper><nav class=site-nav>
<a class=page-link href=/posts/>Posts</a>
<a class=page-link href=/about/>About</a>
</nav><header class=post-header>
<a class=site-title href=https://shoujo.ink>Mayo's Blog</a>
<h1 class="post-title baseline-fix typeface-sans" lang=zh-hans itemprop="name headline">Istio å®‰å…¨æºç åˆ†æä¹‹ PKI ä¸é€šä¿¡å®‰å…¨</h1>
</header>
<div class=post-cover aria-label=Cover>
<div class=post-cover-wrapper>
<img src alt>
</div>
<div class=cover-meta></div>
</div>
<div class=post-layout>
<article class="post typeface-sans" lang=zh-hans itemscope itemtype=http://schema.org/BlogPosting>
<div class=post-content itemprop=articleBody>
<p>è¿™ç¯‡æ–‡ç« æ˜¯æˆ‘åœ¨å…¬å¸å†…éƒ¨æ¢ç´¢ä¸å®è·µç§æœ‰ <ruby>CA<rt>Certification Authority</rt></ruby> ä¸<ruby>åŒå‘ TLS<rt>mutual TLS</rt></ruby> è®¤è¯ä½“ç³»æ—¶ï¼Œå­¦ä¹  Istio å®‰å…¨è®¤è¯æ¶æ„çš„ç¬”è®°ï¼Œæœ€åˆäº 2020.12.03 å‘è¡¨äºå›¢é˜Ÿå†…éƒ¨ï¼Œç°åœ¨çœ‹æ¥æ–‡å­—ç©ºæ´ä¹åŠ›ï¼Œæ‰€ä»¥æˆ‘å¯¹åŸæ–‡åšäº†è¾ƒå¤§çš„è°ƒæ•´ï¼Œè¡¥å……äº†æ›´å¤šå†…å®¹ã€‚</p>
<p>æœ¬æ–‡åŸºäº Istio 1.8 ç‰ˆæœ¬è¿›è¡Œæºç åˆ†æã€‚</p>
<p>åˆ†æè¿‡ç¨‹çš„ä»£ç æ³¨é‡Šåœ¨æˆ‘çš„ Github ä»“åº“ï¼š<a href=https://github.com/mayocream/istio/tree/citadel-review>mayocream/istio</a> citadel-review åˆ†æ”¯ã€‚</p>
<h2 id=1-èº«ä»½æ¨¡å‹>1. èº«ä»½æ¨¡å‹</h2>
<p>é›¶ä¿¡ä»»æ¶æ„ä¸‹ï¼Œéœ€è¦ä¸¥æ ¼åŒºåˆ†å·¥ä½œè´Ÿè½½çš„è¯†åˆ«å’Œä¿¡ä»»ï¼Œè€Œç­¾å‘ X.509 è¯ä¹¦æ˜¯æ¨èçš„ä¸€ç§è®¤è¯æ–¹å¼<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>ã€‚åœ¨ Kubernetes é›†ç¾¤ä¸­ï¼ŒæœåŠ¡é—´æ˜¯é€šè¿‡ DNS åç§°äº’ç›¸è®¿é—®çš„ï¼Œè€Œç½‘ç»œæµé‡å¯èƒ½è¢« DNS æ¬ºéª—ã€BGP/è·¯ç”±åŠ«æŒã€ARP æ¬ºéª—ç­‰æ‰‹æ®µåŠ«æŒï¼Œä¸ºäº†å°†æœåŠ¡åç§°ï¼ˆDNS åç§°ï¼‰ä¸æœåŠ¡èº«ä»½å¼ºå…³è”èµ·æ¥ï¼ŒIstio ä½¿ç”¨ç½®äº X.509 è¯ä¹¦ä¸­çš„å®‰å…¨å‘½åï¼ˆSecure namingï¼‰æœºåˆ¶<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>ã€‚</p>
<p>SPIFFE æ˜¯ Istio æ‰€é‡‡ç”¨çš„å®‰å…¨å‘½åçš„è§„èŒƒï¼Œå®ƒä¹Ÿæ˜¯äº‘åŸç”Ÿå®šä¹‰çš„ä¸€ç§æ ‡å‡†åŒ–çš„ã€å¯ç§»æ¤çš„å·¥ä½œè´Ÿè½½èº«ä»½è§„èŒƒã€‚<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p>
<h3 id=11-ä»‹ç»>1.1. ä»‹ç»</h3>
<p><a href=https://spiffe.io/>Secure Production Identity Framework For Everyone (SPIFFE)</a> æ˜¯ä¸€å¥—æœåŠ¡ä¹‹é—´ç›¸äº’è¿›è¡Œèº«ä»½è¯†åˆ«çš„æ ‡å‡†ï¼Œä¸»è¦åŒ…å«ä»¥ä¸‹å†…å®¹ï¼š</p>
<ul>
<li>SPIFFE ID æ ‡å‡†ï¼ŒSPIFFE ID æ˜¯æœåŠ¡çš„å”¯ä¸€æ ‡è¯†ï¼Œå…·ä½“å®ç°ä½¿ç”¨ URI èµ„æºæ ‡è¯†ç¬¦ã€‚</li>
<li>SPIFFE Verifiable Identity Document (SVID) æ ‡å‡†ï¼Œå°† SPIFFE ID ç¼–ç åˆ°ä¸€ä¸ªåŠ å¯†çš„å¯éªŒè¯çš„æ•°æ®æ ¼å¼ä¸­ã€‚</li>
<li>é¢å‘ä¸æ’¤é”€ SVID çš„ API æ ‡å‡†ã€‚</li>
</ul>
<p>SPIFFE ID è§„å®šäº†å½¢å¦‚ <code>spiffe://&lt;trust domain>/&lt;workload identifier></code> çš„ URI æ ¼å¼ï¼Œä½œä¸ºå·¥ä½œè´Ÿè½½ï¼ˆWorkloadï¼‰çš„å”¯ä¸€æ ‡è¯†ã€‚SVID æ˜¯ SPIFFE ID çš„è¯†åˆ«å‡­è¯ï¼Œæœ‰ X.509 å’Œ JWT ä¸¤ç§æ ¼å¼ã€‚</p>
<p>SPIFFE è§„èŒƒçš„å®ç°æœ‰ spiffe å®˜æ–¹çš„ <a href=https://github.com/spiffe/spire>Spire</a> é¡¹ç›®ï¼Œè€Œ Istio åœ¨è‡ªèº«çš„ç”Ÿæ€ä¸­åªä½¿ç”¨åˆ°äº† SPIFFE ID ä½œä¸ºå®‰å…¨å‘½åï¼Œå…¶æ•°æ®æ ¼å¼ç”±è‡ªå·±å®ç°ï¼Œé€šä¿¡æ ¼å¼é‡‡ç”¨ CNCF æ”¯æŒçš„ <a href=https://github.com/cncf/xds>xDS</a> åè®®è§„èŒƒï¼ˆè¯ä¹¦è®¤è¯é€šä¿¡æ›´å…·ä½“æ¥è¯´æ˜¯ xDS çš„ SDSï¼‰ã€‚</p>
<p>Istio ä½¿ç”¨å½¢å¦‚ <code>spiffe://&lt;trust_domain>/ns/&lt;namespace>/sa/&lt;service_account></code> æ ¼å¼çš„ SPIFFE ID ä½œä¸ºå®‰å…¨å‘½åï¼Œæ³¨å…¥åˆ° X.509 è¯ä¹¦çš„ subjectAltName æ‰©å±•ä¸­ã€‚å…¶ä¸­â€œtrust domainâ€å‚æ•°é€šè¿‡ Istiod ç¯å¢ƒå˜é‡ <code>TRUST_DOMAIN</code> æ³¨å…¥ï¼Œç”¨äºåœ¨å¤šé›†ç¾¤ç¯å¢ƒä¸­äº¤äº’ã€‚</p>
<p>
<figure class=image>
<img src=/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/images/istio-security-arch-sec.svg alt="Istio å®‰å…¨æ¶æ„" loading=lazy>
<figcaption>Istio å®‰å…¨æ¶æ„</figcaption>
</figure></p>
<h3 id=12-ä»£ç å®ç°>1.2. ä»£ç å®ç°</h3>
<p>SPIFFE å®˜æ–¹æä¾›äº† Go SDK <a href=https://github.com/spiffe/go-spiffe>go-spiffe</a>ï¼Œæä¾›ä¸€ç§æ ‡å‡†çš„ SPIFFE åè®®çš„å®¢æˆ·ç«¯å®ç°ã€‚
ç”±äº Istio ä»…ä»…ä½¿ç”¨äº† SPIFFE IDï¼Œæ²¡æœ‰å¿…è¦å¼•å…¥è¿™ä¸ª SDKï¼Œè¿˜å€¼å¾—ä¸€æçš„æ˜¯è¯¥ SDK å¼•å…¥äº† grpc åŒ…ï¼Œå¦‚æœä½ å’Œæˆ‘ä¸€æ ·è¸©è¿‡ grpc åŒ…å¼•ç”¨ç‰ˆæœ¬å†²çªçš„é—®é¢˜ï¼Œè¿˜èŠ±è´¹äº†ä¸€ä¸‹åˆçš„æ—¶é—´æ¥è§£å†³ï¼Œè¿™æ¬¡ä¸€å®šè¦ä¿æŒè­¦æƒ•ã€‚</p>
<p>Istio å°†è‡ªå·±å®ç°çš„ SPIFFE ç›¸å…³çš„ä»£ç å­˜æ”¾åœ¨ pkg ç›®å½•ä¸‹çš„ spiffe ç›®å½•ã€‚</p>
<h4 id=æ•°æ®ç»“æ„>æ•°æ®ç»“æ„</h4>
<p>è¿™é‡Œå†æä¸€æ¬¡æ•°æ®æ ¼å¼æ˜¯å½¢å¦‚ <code>spiffe://&lt;trust_domain>/ns/&lt;namespace>/sa/&lt;service_account></code> çš„ URI å­—ç¬¦ä¸²ã€‚è¿™ç±»èº«ä»½æ ‡è¯†å› ç³»ç»Ÿè®¾è®¡ä¸åŒï¼Œå®šä¹‰çš„æ ¼å¼ä¹Ÿå„ä¸ç›¸åŒï¼Œä¾‹å¦‚èš‚èšå†…éƒ¨ä½¿ç”¨çš„èº«ä»½æ ‡è¯†æ ¼å¼æ˜¯ <code>spiffe://&lt;domain>/cluster/&lt;cluster>/&lt;required_attr_1_name>/&lt;required_attr_1_value>/&lt;required_attr_2_name>/&lt;required_attr_2_value></code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>ã€‚
è€Œæ•å¸ä½¿ç”¨ <code>spiffe://&lt;site_id>/&lt;cluster_id>/&lt;unique_id></code> æ ¼å¼ï¼Œæ€ä¹ˆæ ·è¿˜æ˜¯ç®€æ´ç‚¹çœ‹èµ·æ¥èˆ’æœå§ã€‚</p>
<p>å®šä¹‰ SPIFFE çš„æ•°æ®ç»“æ„åŠå…¶è§£ææ–¹å¼ã€‚</p>
<pre><code class=language-go>type Identity struct {
    TrustDomain    string
    Namespace      string
    ServiceAccount string
}

func ParseIdentity(s string) (Identity, error) {
    if !strings.HasPrefix(s, URIPrefix) {
        return Identity{}, fmt.Errorf(&quot;identity is not a spiffe format: %v&quot;, s)
    }
    split := strings.Split(s[URIPrefixLen:], &quot;/&quot;)
    ...
    return Identity{
        TrustDomain:    split[0],
        Namespace:      split[2],
        ServiceAccount: split[4],
    }, nil
}

func (i Identity) String() string {
    return URIPrefix + i.TrustDomain + &quot;/ns/&quot; + i.Namespace + &quot;/sa/&quot; + i.ServiceAccount
}
</code></pre>
<p>ä¿¡ä»»åŸŸï¼ˆTrust Domainï¼‰æ˜¯ç”± Istiod ä¸»ç¨‹åºå¯åŠ¨æ—¶è°ƒç”¨ <code>spiffe.SetTrustDomain(s.environment.Mesh().GetTrustDomain())</code> å‡½æ•°æ–¹æ³•è®¾ç½®çš„ã€‚</p>
<h4 id=tls-éªŒè¯>TLS éªŒè¯</h4>
<p>Go å®˜æ–¹çš„ tls åŒ…æä¾›äº† <em>VerifyPeerCertificate</em> æ–¹æ³•ï¼Œè¯¥æ–¹æ³•é€šå¸¸ä¼šåœ¨æ ‡å‡†è¯ä¹¦æ ¡éªŒåï¼ˆéªŒè¯æœåŠ¡ç«¯ IP æˆ– DNS åç§°ä»¥åŠè¯ä¹¦é“¾æ ¡éªŒï¼‰è¢«è°ƒç”¨ï¼Œæä¾›é¢å¤–çš„è‡ªå®šä¹‰ Peer è¯ä¹¦éªŒè¯åŠŸèƒ½ã€‚</p>
<p>ç”±äº SPIFFE ID å±äºè¯ä¹¦æ‰©å±•å†…å®¹ï¼Œç¨‹åºéœ€è¦é¢å¤–æ ¡éªŒ SPIFFE èº«ä»½ã€‚</p>
<pre><code class=language-go>// pkg/spiffe/spiffe.go

func (v *PeerCertVerifier) VerifyPeerCert(rawCerts [][]byte, _ [][]*x509.Certificate) error {
    // ä¸‹æ¸¸æœåŠ¡è¯ä¹¦
    var peerCert *x509.Certificate
    // CA è¯ä¹¦é“¾
    intCertPool := x509.NewCertPool()
    for id, rawCert := range rawCerts {
        cert, err := x509.ParseCertificate(rawCert)
        if id == 0 {
            // ç¬¬ä¸€ä¸ªè¯ä¹¦ä¸º Workload è¯ä¹¦
            peerCert = cert
        } else {
            intCertPool.AddCert(cert)
        }
    }
    // ERROR: SAN URIs æ²¡æœ‰ SPIFFE ID
    if len(peerCert.URIs) != 1 {
        return fmt.Errorf(&quot;peer certificate does not contain 1 URI type SAN, detected %d&quot;, len(peerCert.URIs))
    }
    trustDomain, err := GetTrustDomainFromURISAN(peerCert.URIs[0].String())
    if err != nil {
        return err
    }
    // æ ¹è¯ä¹¦æ± 
    rootCertPool, ok := v.certPools[trustDomain]
    if !ok {
        return fmt.Errorf(&quot;no cert pool found for trust domain %s&quot;, trustDomain)
    }

    // éªŒè¯è¯ä¹¦æœ‰æ•ˆæ€§
    _, err = peerCert.Verify(x509.VerifyOptions{
        Roots:         rootCertPool,
        Intermediates: intCertPool,
    })
    return err
}
</code></pre>
<p>æ ¡éªŒè¿‡ç¨‹ä¼šæ£€æŸ¥ SPIFFE ID å­—æ®µæ˜¯å¦å­˜åœ¨ï¼Œä»¥åŠ CA è¯ä¹¦çš„ä¿¡ä»»åŸŸæ˜¯å¦ä¸å·¥ä½œè´Ÿè½½çš„è¯ä¹¦å¤„äºåŒä¸€æœ‰æ•ˆçš„ä¿¡ä»»åŸŸã€‚è‹¥æ ¡éªŒå¤±è´¥ï¼ŒTLS æ¡æ‰‹ä¼šä»¥å¤±è´¥å‘Šç»ˆã€‚</p>
<p>Istiod åœ¨ä¸»ç¨‹åºå¯åŠ¨æ—¶è°ƒç”¨ <em>setPeerCertVerifier</em> æ–¹æ³•ï¼Œè®¾ç½®é¢å¤–çš„ mTLS æ ¡éªŒæ–¹å¼ï¼Œä»¥åŠæ·»åŠ  CA è¯ä¹¦åˆ° Cert Pool é‡Œï¼š</p>
<pre><code class=language-go>// setPeerCertVerifier è®¾ç½® Istiod çš„ SPIFFE æ ¡éªŒæ–¹å¼
func (s *Server) setPeerCertVerifier(tlsOptions TLSOptions) error {
    // è°ƒç”¨ä¸Šè¿°çš„ spiffe åŒ…
    s.peerCertVerifier = spiffe.NewPeerCertVerifier()
    var rootCertBytes []byte
    var err error
    // CA è¯ä¹¦
    if tlsOptions.CaCertFile != &quot;&quot; {
        // ä¼ å…¥ CA è¯ä¹¦
        ...
    }

    // åŠ å…¥ CA æ ¹è¯ä¹¦åˆ° SPIFFIE çš„ä¿¡ä»»è¯ä¹¦é‡Œ
    if len(rootCertBytes) != 0 {
        err := s.peerCertVerifier.AddMappingFromPEM(spiffe.GetTrustDomain(), rootCertBytes)
    }
    return nil
}
</code></pre>
<h4 id=å¤–éƒ¨-ca>å¤–éƒ¨ CA</h4>
<p>Istio å®ç°äº† <a href=https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md>SPIFFE Bundle</a> åè®®ï¼Œè¯¥åè®®å…è®¸è®¿é—®å¤–éƒ¨ URI é€šè¿‡è§„å®šçš„ <a href=https://datatracker.ietf.org/doc/html/rfc7517>JWKï¼ˆJSON Web Keyï¼‰</a>æ•°æ®æ ¼å¼ï¼Œè·å–ä¿¡ä»»åŸŸå¯¹åº”çš„æ ¹è¯ä¹¦ï¼Œè€Œæ— éœ€å°†æ ¹è¯ä¹¦ç½®äºç¨‹åºå†…éƒ¨ã€‚</p>
<p>Istio å®šä¹‰çš„æ•°æ®æ ¼å¼ï¼š</p>
<ul>
<li><em>&lt;trustdomain, endpoint></em> å…ƒç»„ä»¥ || åˆ†å‰²</li>
<li>æ¯ä¸ªå…ƒç»„å†…ä½¿ç”¨ | åˆ†å‰² trustdomain å’Œ endpoint</li>
<li>ä¾‹å¦‚ï¼š<code>foo|https://url/for/foo||bar|https://url/for/bar</code></li>
</ul>
<p>ä¸‹è¿°æ–¹å¼ç”¨äºè·å–ä¿¡ä»»åŸŸå¯¹åº”çš„ X.509 CA è¯ä¹¦é“¾ï¼ˆå¯ä»¥æœ‰å¤šå±‚çº§ï¼‰ã€‚è¯¥æ–¹æ³•æ¥æ”¶ <code>foo|URL1||bar|URL2</code> æ ¼å¼çš„å‚æ•°ï¼Œç”¨ <code>||</code> åˆ†éš”åˆ‡ç‰‡ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸º trust domainï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º CA æœåŠ¡å™¨ URLã€‚</p>
<pre><code class=language-go>// RetrieveSpiffeBundleRootCertsFromStringInput ä» SPIFFE bundle ä¸­æ£€ç´¢å¯ä¿¡çš„ CA è¯ä¹¦ã€‚
// å®ƒå¯ä»¥ä½¿ç”¨ç³»ç»Ÿè¯ä¹¦å’Œæä¾›çš„è¯ä¹¦æ¥è¿›è¡ŒéªŒè¯ã€‚
// æ ¼å¼å¦‚ä¸‹ï¼š
// &quot;foo|URL1||bar|URL2||baz|URL3...&quot;
func RetrieveSpiffeBundleRootCertsFromStringInput(inputString string, extraTrustedCerts []*x509.Certificate) (
    map[string][]*x509.Certificate, error) {
    spiffeLog.Infof(&quot;Processing SPIFFE bundle configuration: %v&quot;, inputString)
    config := make(map[string]string)
    tuples := strings.Split(inputString, &quot;||&quot;)
    for _, tuple := range tuples {
        items := strings.Split(tuple, &quot;|&quot;)
        if len(items) != 2 {
            return nil, fmt.Errorf(&quot;config is invalid: %v. Expected &lt;trustdomain&gt;|&lt;url&gt;&quot;, tuple)
        }
        trustDomain := items[0]
        endpoint := items[1]
        config[trustDomain] = endpoint
    }
    // è°ƒç”¨ CA æœåŠ¡å™¨
    return RetrieveSpiffeBundleRootCerts(config, extraTrustedCerts)
}
</code></pre>
<p>å¤–éƒ¨æœåŠ¡å™¨è¿”å› JWK æ ¼å¼çš„æ•°æ®ï¼š</p>
<pre><code class=language-go>// pkg/spiffe/spiffe.go

// è¿”å›çš„ JSON ç»“æ„
type bundleDoc struct {
    jose.JSONWebKeySet
    Sequence    uint64 `json:&quot;spiffe_sequence,omitempty&quot;`
    RefreshHint int    `json:&quot;spiffe_refresh_hint,omitempty&quot;`
}

// JSONWebKey represents a public or private key in JWK format.
type JSONWebKey struct {
    // Cryptographic key, can be a symmetric or asymmetric key.
    Key interface{}
    // Key identifier, parsed from `kid` header.
    KeyID string
    // Key algorithm, parsed from `alg` header.
    Algorithm string
    // Key use, parsed from `use` header.
    Use string

    // X.509 certificate chain, parsed from `x5c` header.
    Certificates []*x509.Certificate
    // X.509 certificate URL, parsed from `x5u` header.
    CertificatesURL *url.URL
    // X.509 certificate thumbprint (SHA-1), parsed from `x5t` header.
    CertificateThumbprintSHA1 []byte
    // X.509 certificate thumbprint (SHA-256), parsed from `x5t#S256` header.
    CertificateThumbprintSHA256 []byte
}
</code></pre>
<p>å®é™…çš„æ•°æ®ç¤ºä¾‹å¦‚ä¸‹ã€‚</p>
<pre><code class=language-go>{
    &quot;spiffe_sequence&quot;: 1,
    &quot;spiffe_refresh_hint&quot;: 450000,
    &quot;keys&quot;: [
        {
        &quot;kty&quot;: &quot;RSA&quot;,
        &quot;use&quot;: &quot;x509-svid&quot;,
        &quot;n&quot;: &quot;&lt;è¯ä¹¦ç­¾å&gt;&quot;,
        &quot;e&quot;: &quot;AQAB&quot;,
        &quot;x5c&quot;: [&quot;&lt;X.509 è¯ä¹¦&gt;&quot;]
        }
    ]
}
</code></pre>
<h2 id=2-ç§æœ‰-pki>2. ç§æœ‰ PKI</h2>
<p>Istio å†…éƒ¨æœ‰ä¸€å¥—å†…ç½®çš„ PKI è¯ä¹¦åŸºç¡€è®¾æ–½ã€‚é›¶ä¿¡ä»»æ¶æ„ä¸­ï¼ŒPKI æ˜¯é›¶ä¿¡ä»»æ¨¡å‹èº«ä»½è®¤è¯çš„åŸºçŸ³ï¼Œå¤§å¤šæ•°é›¶ä¿¡ä»»ç½‘ç»œéƒ½é‡‡ç”¨ PKI æ¥è¯æ˜èº«ä»½çš„çœŸå®æ€§ã€‚é›¶ä¿¡ä»»ç½‘ç»œé¢å‘çš„è¯ä¹¦æ•°é‡å¯èƒ½ä¼šå¾ˆå¤šï¼Œå› æ­¤éå¸¸æœ‰å¿…è¦å¯¹è¯ä¹¦è¿›è¡Œè‡ªåŠ¨åŒ–ç®¡ç†ã€‚<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p>
<h3 id=21-istiod-é…ç½®>2.1. Istiod é…ç½®</h3>
<p>Istiod é»˜è®¤å¯ç”¨å†…ç½®çš„ CA æœåŠ¡å™¨ã€‚</p>
<pre><code class=language-go>// pilot/pkg/features/pilot.go

EnableCAServer = env.RegisterBoolVar(&quot;ENABLE_CA_SERVER&quot;, true,
        &quot;If this is set to false, will not create CA server in istiod.&quot;).Get()
</code></pre>
<p>è¯ä¹¦ç­¾åçš„é»˜è®¤é…ç½®é¡¹ï¼š</p>
<pre><code class=language-go>// pilot/pkg/bootstrap/istio_ca.go

// å…¼å®¹æŒ‚è½½åä¸º cacerts çš„ secret
// ä½†å·²ç»ä¸ä½¿ç”¨

// ä½¿ç”¨ &quot;istio-ca-secret&quot; æ¥åˆ›å»ºè¯ä¹¦
// å…¼å®¹æ—§ç‰ˆæœ¬

var (
    // æŒ‚è½½åä¸º cacerts çš„ secret çš„ç›®å½•ï¼ŒRead-only
    LocalCertDir = env.RegisterStringVar(&quot;ROOT_CA_DIR&quot;, &quot;./etc/cacerts&quot;,
        &quot;Location of a local or mounted CA root&quot;)
    
    // é»˜è®¤æœåŠ¡è¯ä¹¦ TTL
    workloadCertTTL = env.RegisterDurationVar(&quot;DEFAULT_WORKLOAD_CERT_TTL&quot;,
        cmd.DefaultWorkloadCertTTL,
        &quot;The default TTL of issued workload certificates. Applied when the client sets a &quot;+
            &quot;non-positive TTL in the CSR.&quot;)

    maxWorkloadCertTTL = env.RegisterDurationVar(&quot;MAX_WORKLOAD_CERT_TTL&quot;,
        cmd.DefaultMaxWorkloadCertTTL,
        &quot;The max TTL of issued workload certificates.&quot;)

    // è‡ªç­¾å CA è¯ä¹¦ TTL
    SelfSignedCACertTTL = env.RegisterDurationVar(&quot;CITADEL_SELF_SIGNED_CA_CERT_TTL&quot;,
        cmd.DefaultSelfSignedCACertTTL,
        &quot;The TTL of self-signed CA root certificate.&quot;)
</code></pre>
<p>Istio ä¸»ç¨‹åºä¼šæŒ‚è½½ä¸¤ä¸ª Secertï¼Œä¸€ä¸ªæ˜¯ <em>cacerts</em> Secretï¼Œç”¨äºæŒ‡å®š Istio å¯åŠ¨æ—¶ç”¨æˆ·å®šä¹‰çš„ CA è¯ä¹¦ï¼Œå¦ä¸€ä¸ªæ˜¯ <em>istio-ca-secret</em> Secretï¼Œç”¨äºå‚¨å­˜ Istio Pilot Discovery ç¨‹åºè‡ªç­¾åçš„ CA è¯ä¹¦åŠå…¶ç§é’¥ã€‚</p>
<pre><code class=language-go>    // CA è¯ä¹¦ä¸åº”è¯¥åœ¨ Workload è¯ä¹¦å¤±æ•ˆä¹‹å‰å°±å¤±æ•ˆ
    // æ‰€ä»¥æ­¤å¤„è®¾ç½®è¯ä¹¦çš„ç”Ÿå‘½å‘¨æœŸä¸ºè¯ä¹¦é“¾ä¸­çš„æœ€çŸ­çš„æ—¶æ•ˆæœŸ
    defaultCertTTL, err := ca.minTTL(opts.DefaultCertTTL)
    if err != nil {
        return ca, fmt.Errorf(&quot;failed to get default cert TTL %s&quot;, err.Error())
    }
    ca.defaultCertTTL = defaultCertTTL
</code></pre>
<p>CA è¯ä¹¦ä¸åº”è¯¥åœ¨ Workload è¯ä¹¦å¤±æ•ˆä¹‹å‰å°±å¤±æ•ˆï¼Œæ‰€ä»¥æ­¤å¤„è®¾ç½® Workload è¯ä¹¦çš„ç”Ÿå‘½å‘¨æœŸä¸º CA è¯ä¹¦é“¾ä¸­çš„æœ€çŸ­çš„æ—¶æ•ˆæœŸã€‚</p>
<p>Istio CA å®é™…æŒ‚è½½çš„ <em>istio-ca-secret</em> Secret æ•°æ®ç¤ºä¾‹ï¼š</p>
<pre><code class=language-yaml>kind: Secret
apiVersion: v1
metadata:
  name: istio-ca-secret
  namespace: istio-system
data:
  ca-cert.pem: &gt;-
LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMvRENDQWVTZ0F3SUJBZ0lRQWVMc3E2ZDVFN0ZheVY2U...
  ca-key.pem: &gt;-LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBd2JpOWtucHVPS1d6SUxkM...
  cert-chain.pem: ''
  key.pem: ''
  root-cert.pem: ''
type: istio.io/ca-root

</code></pre>
<h3 id=22-åˆå§‹åŒ–>2.2. åˆå§‹åŒ–</h3>
<h4 id=221-å…¥å£æµç¨‹>2.2.1. å…¥å£æµç¨‹</h4>
<pre><code class=language-go>// pilot/pkg/bootstrap/server.go

// maybeCreateCA creates and initializes CA Key if needed.
func (s *Server) maybeCreateCA(caOpts *caOptions) error {
    // é»˜è®¤å¯ç”¨
    if s.EnableCA() {
        log.Info(&quot;creating CA and initializing public key&quot;)
        var err error
        var corev1 v1.CoreV1Interface
        if s.kubeClient != nil {
            corev1 = s.kubeClient.CoreV1()
        }
        // ä»è¿œç¨‹ K8S é›†ç¾¤è·å–è¯ä¹¦ï¼Œé»˜è®¤ä¸å¯ç”¨
        if useRemoteCerts.Get() {
            if err = s.loadRemoteCACerts(caOpts, LocalCertDir.Get()); err != nil {
                return fmt.Errorf(&quot;failed to load remote CA certs: %v&quot;, err)
            }
        }

        // TODO: Issue #27606 If External CA is configured, use that to sign DNS Certs as well. IstioCA need not be initialized
        if s.CA, err = s.createIstioCA(corev1, caOpts); err != nil {
            return fmt.Errorf(&quot;failed to create CA: %v&quot;, err)
        }
        if err = s.initPublicKey(); err != nil {
            return fmt.Errorf(&quot;error initializing public key: %v&quot;, err)
        }
    }
    return nil
}
</code></pre>
<p><code>s.createIstioCA</code> é‡Œé¢è¯¦ç»†è¿›è¡Œ CA åˆå§‹åŒ–çš„æ“ä½œã€‚</p>
<pre><code class=language-go>// pilot/pkg/bootstrap/istio_ca.go

// createIstioCA initializes the Istio CA signing functionality.
func (s *Server) createIstioCA(client corev1.CoreV1Interface, opts *caOptions) (*ca.IstioCA, error) {
    var caOpts *ca.IstioCAOptions
    var err error

    // In pods, this is the optional 'cacerts' Secret.
    // TODO: also check for key.pem ( for interop )
    signingKeyFile := path.Join(LocalCertDir.Get(), &quot;ca-key.pem&quot;)

    // If not found, will default to ca-cert.pem. May contain multiple roots.
    rootCertFile := path.Join(LocalCertDir.Get(), &quot;root-cert.pem&quot;)
    if _, err := os.Stat(rootCertFile); err != nil {
        // å…¼å®¹ Istio è·å– Root cert è¯ä¹¦
        // In Citadel, normal self-signed doesn't use a root-cert.pem file for additional roots.
        // In Istiod, it is possible to provide one via &quot;cacerts&quot; secret in both cases, for consistency.
        rootCertFile = &quot;&quot;
    }
    if _, err := os.Stat(signingKeyFile); err != nil &amp;&amp; client != nil {
        // åœ¨ K8S é›†ç¾¤ä¸­åˆ›å»ºè‡ªç­¾åè¯ä¹¦
        // The user-provided certs are missing - create a self-signed cert.
        log.Info(&quot;Use self-signed certificate as the CA certificate&quot;)
        // Abort after 20 minutes.
        ctx, cancel := context.WithTimeout(context.Background(), time.Minute*20)
        defer cancel()
        // è·å–è¯ä¹¦æ“ä½œç¬¦
        // rootCertFile will be added to &quot;ca-cert.pem&quot;.
        // readSigningCertOnly set to false - it doesn't seem to be used in Citadel, nor do we have a way
        // to set it only for one job.
        caOpts, err = ca.NewSelfSignedIstioCAOptions(ctx,
            selfSignedRootCertGracePeriodPercentile.Get(), SelfSignedCACertTTL.Get(),
            selfSignedRootCertCheckInterval.Get(), workloadCertTTL.Get(),
            maxWorkloadCertTTL.Get(), opts.TrustDomain, true,
            opts.Namespace, -1, client, rootCertFile,
            enableJitterForRootCertRotator.Get(), caRSAKeySize.Get())
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to create a self-signed istiod CA: %v&quot;, err)
        }
    } else {
        ...
    }
    istioCA, err := ca.NewIstioCA(caOpts)
    if err != nil {
        return nil, fmt.Errorf(&quot;failed to create an istiod CA: %v&quot;, err)
    }
    istioCA.Run(rootCertRotatorChan)
    return istioCA, nil
}
</code></pre>
<p>æ•°æ®æ“ä½œæµç¨‹ï¼š</p>
<ol>
<li>
<p>é¦–å…ˆè¯»å– Kubernetes ä¸­â€œcacertsâ€çš„ secret æŒ‚è½½çš„æœ¬åœ°ç›®å½•ã€‚</p>
</li>
<li>
<p>è‹¥ä¸å­˜åœ¨åˆ™é€šè¿‡ go-client è·å– K8S ä¸­ &ldquo;istio-ca-cert&rdquo; çš„ secretï¼Œè¯¥ secret åŒ…å« CA çš„ç§é’¥åŠè¯ä¹¦ã€‚</p>
</li>
<li>
<p>K8s ä¸­æ²¡æœ‰ CA è¯ä¹¦ï¼Œåˆ™å¼€å§‹è‡ªç­¾åè¯ä¹¦æµç¨‹ã€‚</p>
</li>
</ol>
<h4 id=222-è‡ªç­¾å-ca-è¯ä¹¦>2.2.2. è‡ªç­¾å CA è¯ä¹¦</h4>
<p>ç­¾å‘ä¸è·å–è¯ä¹¦ç›¸å…³å‚æ•°é…ç½®å¯¹ç…§è¡¨å¦‚ä¸‹ï¼š</p>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>é»˜è®¤å€¼</th>
<th>å¤‡æ³¨</th>
</tr>
</thead>
<tbody>
<tr>
<td>DefaultSelfSignedCACertTTL</td>
<td>3650 * 24 * time.Hour</td>
<td>è‡ªç­¾å Root è¯ä¹¦é»˜è®¤çš„ TTL</td>
</tr>
<tr>
<td>DefaultSelfSignedRootCertCheckInterval</td>
<td>1 * time.Hour</td>
<td>è‡ªç­¾åè¯ä¹¦å®šæœŸæ£€æŸ¥è¯ä¹¦æœ‰æ•ˆæœŸæˆ–è¿›è¡Œè¯ä¹¦è½®æ¢æ£€æŸ¥çš„é»˜è®¤é—´éš”æ—¶é—´</td>
</tr>
<tr>
<td>DefaultRootCertGracePeriodPercentile</td>
<td>20</td>
<td>æ ¹è¯ä¹¦å¹³æ»‘è½®æ¢è¯ä¹¦çš„æœ‰æ•ˆæ—¶é•¿ç™¾åˆ†æ¯”ï¼Œç›¸å¯¹äºè¯ä¹¦çš„æœ‰æ•ˆå‘¨æœŸï¼ˆTTLï¼‰</td>
</tr>
<tr>
<td>ReadSigningCertRetryInterval</td>
<td>time.Second * 5</td>
<td>è¯»å–è¯ä¹¦ä¸ç§é’¥å¤±è´¥çš„é‡è¯•é—´éš”æ—¶é—´</td>
</tr>
<tr>
<td>ReadSigningCertRetryMax</td>
<td>time.Second * 30</td>
<td>è¯»å–è¯ä¹¦ä¸ç§é’¥å¤±è´¥çš„æœ€å¤§é‡è¯•æ¬¡æ•°</td>
</tr>
<tr>
<td>DefaultMaxWorkloadCertTTL</td>
<td>90 * 24 * time.Hour</td>
<td>ç­¾å‘å·¥ä½œè´Ÿè½½è¯ä¹¦çš„é»˜è®¤æœ€é•¿çš„ TTL</td>
</tr>
<tr>
<td>DefaultWorkloadCertTTL</td>
<td>24 * time.Hour</td>
<td>ç­¾å‘å·¥ä½œè´Ÿè½½è¯ä¹¦çš„é»˜è®¤çš„ TTL</td>
</tr>
</tbody>
</table>
<p>Istio æ˜¯å…·ä½“æ˜¯å¦‚ä½•ä½¿ç”¨ Go å®˜æ–¹åŒ…è‡ªç­¾åä¸€ä¸ª CA è¯ä¹¦çš„ï¼Ÿ
ä¸»è¦æµç¨‹ä¸ºï¼š</p>
<ol>
<li>åˆ›å»º RSA ç§é’¥ï¼ˆIstio è¿˜ä¸æ”¯æŒ ECDSA ç§é’¥ï¼‰</li>
<li>æ„å»º CSRï¼ˆCertificate signing requestï¼‰æ¨¡æ¿</li>
<li>å¡«å…… SPIFFE ID åˆ° CSR çš„æ‰©å±•å­—æ®µï¼ˆASN.1ï¼‰</li>
<li>è‡ªç­¾å CSR ç”Ÿæˆè¯ä¹¦</li>
<li>åˆ›å»º Kubernetes Secret èµ„æºå‚¨å­˜ CA è¯ä¹¦å’Œç§é’¥</li>
</ol>
<pre><code class=language-go>// security/pkg/pki/ca/ca.go

// K8S é›†ç¾¤å†…è‡ªç­¾åè¯ä¹¦
func NewSelfSignedIstioCAOptions(ctx context.Context,
    rootCertGracePeriodPercentile int, caCertTTL, rootCertCheckInverval, defaultCertTTL,
    maxCertTTL time.Duration, org string, dualUse bool, namespace string,
    readCertRetryInterval time.Duration, client corev1.CoreV1Interface,
    rootCertFile string, enableJitter bool, caRSAKeySize int) (caOpts *IstioCAOptions, err error) {
    // å¦‚æœè¯ä¹¦ä¸å­˜åœ¨åˆ™åˆ›å»ºè¯ä¹¦
    // åç»­è¯»å– secret è·å–
    // è·å– K8S istio-ca-secret secret èµ„æº
    caSecret, scrtErr := client.Secrets(namespace).Get(context.TODO(), CASecret, metav1.GetOptions{})
    // è·å– secret å¤±è´¥ï¼Œå°è¯•å¤šæ¬¡é‡æ–°è·å–
    // è‹¥è¶…æ—¶ä»ç„¶è·å–ä¸åˆ°ï¼Œåˆ™åˆ›å»ºè‡ªç­¾åè¯ä¹¦
    if scrtErr != nil &amp;&amp; readCertRetryInterval &gt; time.Duration(0) {
        pkiCaLog.Infof(&quot;Citadel in signing key/cert read only mode. Wait until secret %s:%s can be loaded...&quot;, namespace, CASecret)
        ticker := time.NewTicker(readCertRetryInterval)
        for scrtErr != nil {
            select {
            case &lt;-ticker.C:
                if caSecret, scrtErr = client.Secrets(namespace).Get(context.TODO(), CASecret, metav1.GetOptions{}); scrtErr == nil {
                    pkiCaLog.Infof(&quot;Citadel successfully loaded the secret.&quot;)
                }
            }
        }
    }

    caOpts = &amp;IstioCAOptions{
        CAType:         selfSignedCA, // 1 è‡ªç­¾åè¯ä¹¦ 2 ç”¨æˆ·è‡ªå®šä¹‰è¯ä¹¦
        DefaultCertTTL: defaultCertTTL,
        MaxCertTTL:     maxCertTTL,
        // CA è½®è½¬æ£€æŸ¥
        RotatorConfig: &amp;SelfSignedCARootCertRotatorConfig{
            CheckInterval:      rootCertCheckInverval,
            caCertTTL:          caCertTTL,
            retryInterval:      cmd.ReadSigningCertRetryInterval, // é»˜è®¤ 5 ç§’
            retryMax:           cmd.ReadSigningCertRetryMax, // é»˜è®¤ 30 ç§’
            certInspector:      certutil.NewCertUtil(rootCertGracePeriodPercentile),
            caStorageNamespace: namespace,
            dualUse:            dualUse, // é»˜è®¤ true
            org:                org,
            rootCertFile:       rootCertFile,
            enableJitter:       enableJitter,
            client:             client,
        },
    }
    // è·å–ä¸åˆ° secretï¼Œè‡ªç­¾ååˆ›å»º
    if scrtErr != nil {
        pkiCaLog.Infof(&quot;Failed to get secret (error: %s), will create one&quot;, scrtErr)

        options := util.CertOptions{
            TTL:          caCertTTL,
            Org:          org,
            IsCA:         true, // è¯ä¹¦æ ‡è¯†ä¸º CA
            IsSelfSigned: true,
            RSAKeySize:   caRSAKeySize,
            // Whether this certificate is for dual-use clients (SAN+CN).
            IsDualUse:    dualUse, // è¿™ä¸ªé€‰é¡¹å…¶å®æ²¡æœ‰ç”¨åˆ°
        }
        pemCert, pemKey, ckErr := util.GenCertKeyFromOptions(options)
        if ckErr != nil {
            return nil, fmt.Errorf(&quot;unable to generate CA cert and key for self-signed CA (%v)&quot;, ckErr)
        }

        // è·å– RootCertFile åŠ å…¥æ ¹è¯ä¹¦é“¾
        rootCerts, err := util.AppendRootCerts(pemCert, rootCertFile)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to append root certificates (%v)&quot;, err)
        }

        // æ„å»ºå‚¨å­˜è¯ä¹¦é“¾çš„å¹¶å‘å®‰å…¨çš„æ•°æ®ç»“æ„ä½“
        if caOpts.KeyCertBundle, err = util.NewVerifiedKeyCertBundleFromPem(pemCert, pemKey, nil, rootCerts); err != nil {
            return nil, fmt.Errorf(&quot;failed to create CA KeyCertBundle (%v)&quot;, err)
        }

        // åœ¨ K8S ä¸­åˆ›å»º secret å‚¨å­˜è¯ä¹¦
        // Write the key/cert back to secret so they will be persistent when CA restarts.
        secret := k8ssecret.BuildSecret(&quot;&quot;, CASecret, namespace, nil, nil, nil, pemCert, pemKey, istioCASecretType)
        if _, err = client.Secrets(namespace).Create(context.TODO(), secret, metav1.CreateOptions{}); err != nil {
            ...
        }
    } else {
        ...
        // ä»æœ¬åœ°è¯»å– CA è¯ä¹¦
    }
    // è¿”å›è¯ä¹¦æ“ä½œç¬¦
    return caOpts, nil
}
</code></pre>
<p>é»˜è®¤ä½¿ç”¨ RSA 2048 size ç”Ÿæˆç§é’¥ï¼š</p>
<pre><code class=language-go>// security/pkg/pki/util/generate_cert.go

// GenCertKeyFromOptions generates a X.509 certificate and a private key with the given options.
func GenCertKeyFromOptions(options CertOptions) (pemCert []byte, pemKey []byte, err error) {
    // é»˜è®¤å¿½ç•¥ï¼Œä½¿ç”¨ RSA ç®—æ³•
    if options.ECSigAlg != &quot;&quot; {
        ...
    }

    // ç”Ÿæˆ RSA å¯†é’¥
    rsaPriv, err := rsa.GenerateKey(rand.Reader, options.RSAKeySize)
    // ç”Ÿæˆè¯ä¹¦
    return genCert(options, rsaPriv, &amp;rsaPriv.PublicKey)
}
</code></pre>
<p>åˆ›å»ºä¸€ä¸ªè¯ä¹¦æ¨¡æ¿ï¼Œéšåä¼šä»æ¨¡æ¿åˆ›å»º CSRï¼š</p>
<pre><code class=language-go>// security/pkg/pki/util/generate_cert.go

// genCertTemplateFromoptions generates a certificate template with the given options.
func genCertTemplateFromOptions(options CertOptions) (*x509.Certificate, error) {
    var keyUsage x509.KeyUsage
    if options.IsCA {
        // If the cert is a CA cert, the private key is allowed to sign other certificates.
        keyUsage = x509.KeyUsageCertSign
    } else {
        // Otherwise the private key is allowed for digital signature and key encipherment.
        keyUsage = x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment
    }

    subject := pkix.Name{
        Organization: []string{options.Org},
    }

    // å¡«å……æ‰©å±•å­—æ®µ
    exts := []pkix.Extension{}
    if h := options.Host; len(h) &gt; 0 {
        // ç”Ÿæˆ SAN
        s, err := BuildSubjectAltNameExtension(h)
        if err != nil {
            return nil, err
        }
        if options.IsDualUse {
            // è·å– common name
            cn, err := DualUseCommonName(h)
            if err != nil {
                ...
            } else {
                subject.CommonName = cn
            }
        }
        exts = []pkix.Extension{*s}
    }

    return &amp;x509.Certificate{
        SerialNumber:          serialNum,
        Subject:               subject,
        NotBefore:             notBefore,
        NotAfter:              notBefore.Add(options.TTL),
        KeyUsage:              keyUsage,
        ExtKeyUsage:           extKeyUsages,
        IsCA:                  options.IsCA,
        BasicConstraintsValid: true,
        ExtraExtensions:       exts}, nil
}
</code></pre>
<p>æ³¨å…¥ SPIFFE å·¥ä½œè´Ÿè½½èº«ä»½æ ‡è¯†ï¼š</p>
<pre><code class=language-go>// security/pkg/pki/util/san.go

// BuildSubjectAltNameExtension builds the SAN extension for the certificate.
func BuildSubjectAltNameExtension(hosts string) (*pkix.Extension, error) {
    ids := []Identity{}
    for _, host := range strings.Split(hosts, &quot;,&quot;) {
        if ip := net.ParseIP(host); ip != nil {
            // Use the 4-byte representation of the IP address when possible.
            if eip := ip.To4(); eip != nil {
                ip = eip
            }
            ids = append(ids, Identity{Type: TypeIP, Value: ip})
        } else if strings.HasPrefix(host, spiffe.URIPrefix) {
            ids = append(ids, Identity{Type: TypeURI, Value: []byte(host)})
        } else {
            ids = append(ids, Identity{Type: TypeDNS, Value: []byte(host)})
        }
    }

    san, err := BuildSANExtension(ids)
    if err != nil {
        return nil, fmt.Errorf(&quot;SAN extension building failure (%v)&quot;, err)
    }

    return san, nil
}

// BuildSANExtension builds a `pkix.Extension` of type &quot;Subject
// Alternative Name&quot; based on the given identities.
func BuildSANExtension(identites []Identity) (*pkix.Extension, error) {
    ...
    // å¦‚æœ subject çš„ä¿¡æ¯ä»…å­˜åœ¨äº subjectAltName æ‰©å±•ä¸­(ä»…äºEmailåœ°å€æˆ–URIç›¸å…³)
    // åˆ™ subject name å¿…é¡»ä¸ºéç©ºç»“æ„ä¸” subjectAltName æ‰©å±•å¿…é¡»ä¸º criticalã€‚
    // SAN is Critical because the subject is empty. This is compliant with X.509 and SPIFFE standards.
    return &amp;pkix.Extension{Id: oidSubjectAlternativeName, Critical: true, Value: bs}, nil
}
</code></pre>
<p>SPIFFE ID å‚¨å­˜åœ¨ X.509 è¯ä¹¦çš„ SAN URI å­—æ®µä¸­ã€‚</p>
<h4 id=223-å‚¨å­˜è¯ä¹¦>2.2.3. å‚¨å­˜è¯ä¹¦</h4>
<p>Istiod çš„ CA è¯ä¹¦åŒæ—¶ä¹Ÿä¼šå‚¨å­˜åˆ°æœ¬åœ°ä¸€ä»½ã€‚</p>
<pre><code class=language-go>// Save the root public key file and initialize the path the the file, to be used by other components.
func (s *Server) initPublicKey() error {
    // Setup the root cert chain and caBundlePath - before calling initDNSListener.
    if features.PilotCertProvider.Get() == IstiodCAProvider {
        signingKeyFile := path.Join(LocalCertDir.Get(), &quot;ca-key.pem&quot;)
        if _, err := os.Stat(signingKeyFile); err != nil {
            // When Citadel is configured to use self-signed certs, keep a local copy so other
            // components can load it via file (e.g. webhook config controller).
            if err := os.MkdirAll(dnsCertDir, 0700); err != nil {
                return err
            }
            // We have direct access to the self-signed
            internalSelfSignedRootPath := path.Join(dnsCertDir, &quot;self-signed-root.pem&quot;)

            rootCert := s.CA.GetCAKeyCertBundle().GetRootCertPem()
            if err = ioutil.WriteFile(internalSelfSignedRootPath, rootCert, 0600); err != nil {
                return err
            }
            ...
            s.caBundlePath = internalSelfSignedRootPath
        }
    }
    return nil
}
</code></pre>
<p>å‚¨å­˜åˆ°æœ¬åœ°ç›®çš„æ˜¯ä¸ºäº†è®©å„ä¸ªç‹¬ç«‹çš„ç»„ä»¶ï¼ˆè™½ç„¶åˆå¹¶åˆ° Istiod ç¨‹åºä¸­ï¼‰éƒ½è¯»å–åˆ° CA è¯ä¹¦ã€‚
åŒæ—¶è¿˜ä¼šç›‘å¬æ–‡ä»¶ç³»ç»Ÿçš„å˜åŒ–ï¼ŒåŠæ—¶æ›¿æ¢è¯ä¹¦ã€‚</p>
<pre><code class=language-go>// initCertificateWatches sets up  watches for the certs.
func (s *Server) initCertificateWatches(tlsOptions TLSOptions) error {
    // load the cert/key and setup a persistent watch for updates.
    ...
}
</code></pre>
<h3 id=23-ca-è¯ä¹¦è½®æ¢>2.3. CA è¯ä¹¦è½®æ¢</h3>
<p>CA è¯ä¹¦è½®æ¢çš„ä»£ç ä½äº <code>security/pkg/pki/ca/selfsignedcarootcertrotator.go</code> æ–‡ä»¶ä¸­ã€‚</p>
<p>è¯¥æ¨¡å—å®šæœŸæ£€æŸ¥ CA è¯ä¹¦æœ‰æ•ˆæ€§ï¼Œæ¯”å¯¹ Kubernetes çš„ Secret èµ„æºä¸­çš„ CA è¯ä¹¦ä¸å†…å­˜ä¸­å‚¨å­˜çš„ CA è¯ä¹¦æ˜¯å¦ä¸€è‡´ã€‚
è‹¥è¯ä¹¦å³å°†è¿‡æœŸï¼Œåˆ™ä½¿ç”¨ç§é’¥é‡æ–°ç­¾åï¼Œä»¥é¢å‘æ–°çš„å¯ç”¨çš„ CA è¯ä¹¦ã€‚</p>
<pre><code class=language-go>// NewSelfSignedCARootCertRotator returns a new root cert rotator instance that
// rotates self-signed root cert periodically.
func NewSelfSignedCARootCertRotator(config *SelfSignedCARootCertRotatorConfig,
    ca *IstioCA) *SelfSignedCARootCertRotator {
    rotator := &amp;SelfSignedCARootCertRotator{
        caSecretController: controller.NewCaSecretController(config.client),
        config:             config,
        ca:                 ca,
    }
    ...
    return rotator
}
</code></pre>
<p>è¯¥è¯ä¹¦è½®æ¢å™¨å¸¦æœ‰æŒ‡æ•°é€€é¿ç®—æ³•ï¼Œä»¥æ›´ä¼˜é›…åœ°å®šæœŸé”™è¯¯é‡è¯•ã€‚</p>
<pre><code class=language-go>// Run refreshes root certs and updates config map accordingly.
func (rotator *SelfSignedCARootCertRotator) Run(stopCh chan struct{}) {
    ...
    ticker := time.NewTicker(rotator.config.CheckInterval)
    for {
        select {
        case &lt;-ticker.C:
            rootCertRotatorLog.Info(&quot;Check and rotate root cert.&quot;)
            rotator.checkAndRotateRootCert()
        }
    }
}
</code></pre>
<p><code>checkAndRotateRootCert</code> å‡½æ•°å®šæ—¶è¢«æ‰§è¡Œï¼Œä»¥ç¡®è®¤è¯ä¹¦çš„æœ‰æ•ˆæ€§æŒ‡æ ‡ã€‚
<em>Citadel</em> æ˜¯ Istio ä¸­ä¸“é—¨è´Ÿè´£è®¤è¯ç›¸å…³çš„ç»„ä»¶ï¼Œè™½ç„¶åˆå¹¶åˆ° Istiod ä¸­ï¼Œ
åœ¨ä»£ç ä¸­å®ƒè¿˜æ˜¯è¢«å•ç‹¬å½’ç±»ã€‚</p>
<pre><code class=language-go>// checkAndRotateRootCert decides whether root cert should be refreshed, and rotates
// root cert for self-signed Citadel.
func (rotator *SelfSignedCARootCertRotator) checkAndRotateRootCert() {
    // å¸¦å¤±è´¥é‡è¯•è·å– CA è¯ä¹¦çš„ K8s secret
    caSecret, scrtErr := rotator.caSecretController.LoadCASecretWithRetry(CASecret,
        rotator.config.caStorageNamespace, rotator.config.retryInterval, rotator.config.retryMax)

    if scrtErr != nil {
        ...
    } else {
        rotator.checkAndRotateRootCertForSigningCertCitadel(caSecret)
    }
}

// checkAndRotateRootCertForSigningCertCitadel checks root cert secret and rotates
// root cert if the current one is about to expire. The rotation uses existing
// root private key to generate a new root cert, and updates root cert secret.
func (rotator *SelfSignedCARootCertRotator) checkAndRotateRootCertForSigningCertCitadel(
    caSecret *v1.Secret) {
    // Check root certificate expiration time in CA secret
    waitTime, err := rotator.config.certInspector.GetWaitTime(caSecret.Data[caCertID], time.Now(), time.Duration(0))
    if err == nil &amp;&amp; waitTime &gt; 0 {
        rootCertRotatorLog.Info(&quot;Root cert is not about to expire, skipping root cert rotation.&quot;)
        caCertInMem, _, _, _ := rotator.ca.GetCAKeyCertBundle().GetAllPem()
        // æ¯”è¾ƒå†…å­˜ä¸­çš„è¯ä¹¦ä¸ K8S ä¸­çš„è¯ä¹¦æ˜¯å¦ä¸€è‡´
        // If CA certificate is different from the CA certificate in local key
        // cert bundle, it implies that other Citadels have updated istio-ca-secret.
        // Reload root certificate into key cert bundle.
        if !bytes.Equal(caCertInMem, caSecret.Data[caCertID]) {
            // æ ¡éªŒè¯ä¹¦å¹¶å°†è¯ä¹¦åŠ è½½åˆ°å†…å­˜ä¸­ç¼“å­˜
            if err := rotator.ca.GetCAKeyCertBundle().VerifyAndSetAll(caSecret.Data[caCertID],
                caSecret.Data[caPrivateKeyID], nil, rootCerts); err != nil {
                rootCertRotatorLog.Errorf(&quot;failed to reload root cert into KeyCertBundle (%v)&quot;, err)
            } else {
                rootCertRotatorLog.Info(&quot;Successfully reloaded root cert into KeyCertBundle.&quot;)
            }
        }
        return
    }

    rootCertRotatorLog.Infof(&quot;Refresh root certificate, root cert is about to expire: %s&quot;, err.Error())


    options := util.CertOptions{
        TTL:           rotator.config.caCertTTL,
        SignerPrivPem: caSecret.Data[caPrivateKeyID],
        Org:           rotator.config.org,
        IsCA:          true,
        IsSelfSigned:  true,
        RSAKeySize:    rotator.ca.caRSAKeySize,
        IsDualUse:     rotator.config.dualUse,
    }
    // options should be consistent with the one used in NewSelfSignedIstioCAOptions().
    // This is to make sure when rotate the root cert, we don't make unnecessary changes
    // to the certificate or add extra fields to the certificate.
    options = util.MergeCertOptions(options, oldCertOptions)
    // é‡æ–°ç­¾å‘è¯ä¹¦
    pemCert, pemKey, ckErr := util.GenRootCertFromExistingKey(options)
    if ckErr != nil {
        rootCertRotatorLog.Errorf(&quot;unable to generate CA cert and key for self-signed CA: %s&quot;, ckErr.Error())
        return
    }

    ...
    // åœ¨ K8S åŠå†…å­˜ä¸­æ›´æ–°è¯ä¹¦
    if rollback, err := rotator.updateRootCertificate(caSecret, true, pemCert, pemKey, pemRootCerts); err != nil {
        ...
        // caSecret is out-of-date. Need to load the latest istio-ca-secret to roll back root certificate.
        _, err = rotator.updateRootCertificate(nil, false, oldCaCert, oldCaPrivateKey, oldRootCerts)
        if err != nil {
            rootCertRotatorLog.Errorf(&quot;Failed to roll backward root certificate (error: %s).&quot;, err.Error())
        }
        return
    }
    rootCertRotatorLog.Info(&quot;Root certificate rotation is completed successfully.&quot;)
}
</code></pre>
<p>åŒæ—¶è¯ä¹¦æ›´æ–°æ›¿æ¢æ—¶ä¹Ÿæœ‰å¤±è´¥å›æ»šæœºåˆ¶ï¼ŒCA è¯ä¹¦è½®æ¢å Istio ä¼šæ›´æ–° Kubernetes ä¸­ Secret èµ„æºï¼Œä»¥åŠå†…å­˜ä¸­ç¼“å­˜çš„è¯ä¹¦èµ„æºã€‚
è¿™ç±»è¯ä¹¦è½®æ¢å‡½æ•°ï¼Œè¿è¡Œåœ¨ç‹¬ç«‹çš„åç¨‹ä¸­ã€‚</p>
<pre><code class=language-go>func (ca *IstioCA) Run(stopChan chan struct{}) {
    if ca.rootCertRotator != nil {
        // Start root cert rotator in a separate goroutine.
        go ca.rootCertRotator.Run(stopChan)
    }
}
</code></pre>
<h3 id=24-ç­¾å‘-workload-è¯ä¹¦>2.4. ç­¾å‘ Workload è¯ä¹¦</h3>
<p>ä»¥ä¸Šéƒ¨åˆ†æ˜¯ Istio å¦‚ä½•ç­¾å‘ CA ä¸è½®æ¢ CA è¯ä¹¦ï¼Œå› ä¸ºè¯ä¹¦éƒ½æ˜¯åœ¨åŒä¸€ä¸ªè¿›ç¨‹ä¸­ç­¾å‘ä¸æ›¿æ¢ï¼Œä¸æ¶‰åŠé¢å¤–çš„ç½‘ç»œæ“ä½œï¼Œ
ç›¸å¯¹æµç¨‹æ¯”è¾ƒæ¸…æ™°ã€‚Workload è¯ä¹¦ç­¾å‘æ˜¯ç”±ç‹¬ç«‹è¿è¡Œçš„å·¥ä½œè´Ÿè½½çš„ Pod ä¸­çš„ Agent è¿›ç¨‹å‘ Kubernetes è¿›è¡Œè®¤è¯åï¼Œ
å‘é€ CSR è¯·æ±‚ç»™ Istio CA æœåŠ¡å™¨è¿›è¡Œç­¾åçš„ã€‚å®ƒè¿˜æ‹¥æœ‰ä¸€å¥—ç‰¹æ®Šçš„é€šä¿¡åè®®ã€‚</p>
<h4 id=241-å¯åŠ¨-ca-æœåŠ¡å™¨>2.4.1. å¯åŠ¨ CA æœåŠ¡å™¨</h4>
<p>Istiod å¯åŠ¨ CA æœåŠ¡å™¨ï¼Œå“åº”å·¥ä½œè´Ÿè½½ç­¾å‘ç¬¦åˆè‡ªèº«æƒé™èº«ä»½çš„ CSR è¯·æ±‚ã€‚</p>
<pre><code class=language-go>// StartCA starts the CA or RA server if configured.
func (s *Server) startCA(caOpts *caOptions) {
   s.addStartFunc(func(stop &lt;-chan struct{}) error {
      grpcServer := s.secureGrpcServer
      if s.secureGrpcServer == nil {
         grpcServer = s.grpcServer
      }
      // Start the RA server if configured, else start the CA server
      if s.RA != nil {
        ...
      } else if s.CA != nil {
         log.Infof(&quot;Starting IstioD CA&quot;)
         s.RunCA(grpcServer, s.CA, caOpts)
      }
      return nil
   })
}
</code></pre>
<p>CA æœåŠ¡å™¨çš„æ¥å£æ³¨å†Œåœ¨ grpc æœåŠ¡å™¨ä¸Šï¼Œæ³¨æ„è¿™é‡Œå¼€å¯äº† TLSï¼Œé€šä¿¡åè®®æ˜¯ grpcsã€‚</p>
<pre><code class=language-go>// åœ¨ GRPCS æœåŠ¡å™¨ä¸Šå¼€å¯ CA
// RunCA will start the cert signing GRPC service on an existing server.
// Protected by installer options: the CA will be started only if the JWT token in /var/run/secrets
// is mounted. If it is missing - for example old versions of K8S that don't support such tokens -
// we will not start the cert-signing server, since pods will have no way to authenticate.
func (s *Server) RunCA(grpc *grpc.Server, ca caserver.CertificateAuthority, opts *caOptions) {
    iss := trustedIssuer.Get() // é»˜è®¤ä¸ºç©º
    aud := audience.Get() // é»˜è®¤ä¸ºç©º

    // å¡«å…… iss å’Œ aud
    // é»˜è®¤è·å– K8S SA Token
    // &quot;/var/run/secrets/kubernetes.io/serviceaccount/token&quot;
    token, err := ioutil.ReadFile(s.jwtPath)
    if err == nil {
        // è·å– JWT Payload
        tok, err := detectAuthEnv(string(token))
        if err != nil {
            log.Warn(&quot;Starting with invalid K8S JWT token&quot;, err, string(token))
        } else {
            if iss == &quot;&quot; {
                iss = tok.Iss
            }
            if len(tok.Aud) &gt; 0 &amp;&amp; len(aud) == 0 {
                aud = tok.Aud[0]
            }
        }
    }

    // The CA API uses cert with the max workload cert TTL.
    // 'hostlist' must be non-empty - but is not used since a grpc server is passed.
    // Adds client cert auth and kube (sds enabled)
    // åˆ›å»ºç»™ Workload é¢å‘è¯ä¹¦çš„ CA
    caServer, startErr := caserver.New(ca, maxWorkloadCertTTL.Get(), opts.Authenticators)
    if startErr != nil {
        log.Fatalf(&quot;failed to create istio ca server: %v&quot;, startErr)
    }

    // æ³¨å†Œ GRPC PB
    caServer.Register(grpc)

    log.Info(&quot;Istiod CA has started&quot;)
}
</code></pre>
<p>Kubernetes Serivce Account Token åŒ…å«çš„ Payload æ•°æ®ç¤ºä¾‹ï¼š</p>
<pre><code class=language-json>{
  &quot;iss&quot;: &quot;kubernetes/serviceaccount&quot;,
  &quot;kubernetes.io/serviceaccount/namespace&quot;: &quot;istio-system&quot;,
  &quot;kubernetes.io/serviceaccount/secret.name&quot;: &quot;istio-reader-service-account-token-zmks5&quot;,
  &quot;kubernetes.io/serviceaccount/service-account.name&quot;: &quot;istio-reader-service-account&quot;,
  &quot;kubernetes.io/serviceaccount/service-account.uid&quot;: &quot;9a544d83-ed88-474f-967c-27473357ee95&quot;,
  &quot;sub&quot;: &quot;system:serviceaccount:istio-system:istio-reader-service-account&quot;
}
</code></pre>
<p>é»˜è®¤é…ç½®ä¸­ï¼Œç­¾å‘ç»™ Workload çš„è¯ä¹¦çš„æœ‰æ•ˆæœŸæ˜¯ 90 å¤©ã€‚</p>
<pre><code class=language-go>// security/pkg/server/ca/server.go
// Register registers a GRPC server on the specified port.
func (s *Server) Register(grpcServer *grpc.Server) {
    pb.RegisterIstioCertificateServiceServer(grpcServer, s)
}

// istio.io\api@v0.0.0-20201125194658-3cee6a1d3ab4\security\v1alpha1\ca.pb.go
// IstioCertificateServiceServer is the server API for IstioCertificateService service.
type IstioCertificateServiceServer interface {
    // Using provided CSR, returns a signed certificate.
    CreateCertificate(context.Context, *IstioCertificateRequest) (*IstioCertificateResponse, error)
}
</code></pre>
<p>CA æœåŠ¡å™¨çš„ grpc æ¥å£åªæœ‰ä¸€ä¸ª <code>CreateCertificate</code> æ–¹æ³•ï¼Œè°ƒç”¨è¯¥æ–¹æ³•å¤„ç† CSR è¯·æ±‚ã€‚</p>
<h4 id=242-ç­¾å‘è¯ä¹¦>2.4.2. ç­¾å‘è¯ä¹¦</h4>
<p>é€šè¿‡ grpcs åè®®æ¥æ”¶åˆ° CSR è¯·æ±‚æ—¶ï¼Œé¦–å…ˆä¼šè¿›è¡Œè®¤è¯ï¼š</p>
<p>Istio æ”¯æŒå¤šç§æ–¹å¼è¿›è¡Œè®¤è¯ï¼Œä¾‹å¦‚å®¢æˆ·ç«¯è¯ä¹¦ã€K8s JWTã€ID Token ç­‰ï¼ŒIstio è®¤è¯æ–¹æ³•ä¸­ä¼šå°è¯•ä»å¤šä¸ªè®¤è¯æºè¿›è¡Œè®¤è¯ï¼Œ
é€‰æ‹©å‡ºèƒ½å¤ŸéªŒè¯å®¢æˆ·ç«¯èº«ä»½çš„ä¸€ç§æ–¹å¼ï¼Œå½“ç„¶è®¤è¯å¤±è´¥å°±å¤±è´¥äº†ã€‚</p>
<pre><code class=language-go>// authenticate goes through a list of authenticators (provided client cert, k8s jwt, and ID token)
// and authenticates if one of them is valid.
func (s *Server) authenticate(ctx context.Context) *authenticate.Caller {
    // TODO: apply different authenticators in specific order / according to configuration.
    var errMsg string
    for id, authn := range s.Authenticators {
        u, err := authn.Authenticate(ctx)
        ...
    }
    serverCaLog.Warnf(&quot;Authentication failed for %v: %s&quot;, getConnectionAddress(ctx), errMsg)
    return nil
}
</code></pre>
<p>å…·ä½“å¤„ç† CSR åˆ›å»ºè¯ä¹¦çš„æ¥å£é€»è¾‘ï¼š</p>
<pre><code class=language-go>// CreateCertificate handles an incoming certificate signing request (CSR). It does
// authentication and authorization. Upon validated, signs a certificate that:
// the SAN is the identity of the caller in authentication result.
// the subject public key is the public key in the CSR.
// the validity duration is the ValidityDuration in request, or default value if the given duration is invalid.
// it is signed by the CA signing key.
func (s *Server) CreateCertificate(ctx context.Context, request *pb.IstioCertificateRequest) (
    *pb.IstioCertificateResponse, error) {
    // metrics
    s.monitoring.CSR.Increment()
    // ä» GRPC CTX è·å– TLS Info é‡Œé¢çš„ SPIFFE ID
    caller := s.authenticate(ctx)
    if caller == nil {
        // ç¼ºå°‘ TLS Info çš„å®¢æˆ·ç«¯è¯ä¹¦çš„ SAN URI å­—æ®µ
        s.monitoring.AuthnError.Increment()
        return nil, status.Error(codes.Unauthenticated, &quot;request authenticate failure&quot;)
    }

    // TODO: Call authorizer.

    _, _, certChainBytes, rootCertBytes := s.ca.GetCAKeyCertBundle().GetAll()
    // ç­¾å‘è¯ä¹¦
    cert, signErr := s.ca.Sign(
        []byte(request.Csr), caller.Identities, time.Duration(request.ValidityDuration)*time.Second, false)
    
    respCertChain := []string{string(cert)}
    if len(certChainBytes) != 0 {
        // åŠ å…¥è¯ä¹¦é“¾
        respCertChain = append(respCertChain, string(certChainBytes))
    }
    respCertChain = append(respCertChain, string(rootCertBytes))
    response := &amp;pb.IstioCertificateResponse{
        CertChain: respCertChain,
    }
    s.monitoring.Success.Increment()
    serverCaLog.Debug(&quot;CSR successfully signed.&quot;)
    return response, nil
}
</code></pre>
<h3 id=25-raæ³¨å†Œæœºæ„>2.5. RAï¼ˆæ³¨å†Œæœºæ„ï¼‰</h3>
<blockquote>
<p>Istio å¸¦æœ‰ç°æˆçš„è¯ä¹¦é¢å‘æœºæ„ï¼ˆCAï¼‰ï¼Œä½†ä¸å°‘ç”¨æˆ·ä¹Ÿå¸Œæœ›èƒ½å¤Ÿæ¥å…¥ç°æœ‰ CAã€‚
åœ¨ä¹‹å‰çš„ç‰ˆæœ¬ä¸­ï¼Œæ‚¨éœ€è¦å®ç° Istio CSR API å¹¶è‡ªè¡Œç¼–å†™ç¬¬ä¸‰æ–¹é›†æˆã€‚
åœ¨ Istio 1.8 ä¸­ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€ç§ä½¿ç”¨ Kubernetes CSR API çš„æ–°æ–¹æ³•ï¼Œæ­¤æ–¹æ³•å¯ä¸ä»»ä½•èƒ½å¤Ÿä½¿ç”¨æ­¤APIçš„å·¥å…·ç›¸é›†æˆã€‚
Istiod å°†å……å½“æ³¨å†Œæœºæ„ï¼ˆRAï¼‰è§’è‰²ï¼Œè´Ÿè´£å¯¹å·¥ä½œè´Ÿè½½è¿›è¡Œèº«ä»½éªŒè¯åŠæˆæƒï¼Œè€Œååˆ›å»ºã€æ‰¹å‡†å¹¶ç›‘æ§ CSR èµ„æºçš„æ›´æ–°ã€‚
æ¥ä¸‹æ¥ï¼Œç¬¬ä¸‰æ–¹å·¥å…·ï¼ˆä¾‹å¦‚cert-managerï¼‰å³å¯ä½¿ç”¨æ­£ç¡®çš„ç­¾åç¨‹åºåˆ›å»ºå…·æœ‰é€‚å½“åç«¯ CA çš„ç­¾åè¯ä¹¦ã€‚
æ­¤åŠŸèƒ½ç›®å‰å°šå¤„äºè¯•éªŒé˜¶æ®µã€‚<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p>
</blockquote>
<pre><code class=language-go>// pilot/pkg/bootstrap/server.go

func (s *Server) maybeCreateCA(caOpts *caOptions) error {
    if s.EnableCA() {
        ...
        if caOpts.ExternalCAType != &quot;&quot; {
            if s.RA, err = s.createIstioRA(s.kubeClient, caOpts); err != nil {
                return fmt.Errorf(&quot;failed to create RA: %v&quot;, err)
            }
        }
        ...
    }
}
</code></pre>
<p>å¦‚æœé…ç½®äº†è‡ªå®šä¹‰ CAï¼Œåˆ™å¯ç”¨ RA åŠŸèƒ½ã€‚</p>
<pre><code class=language-go>// pilot/pkg/bootstrap/istio_ca.go

// createIstioRA initializes the Istio RA signing functionality.
// the caOptions defines the external provider
func (s *Server) createIstioRA(client kubelib.Client,
   opts *caOptions) (ra.RegistrationAuthority, error) {

   caCertFile := path.Join(ra.DefaultExtCACertDir, constants.CACertNamespaceConfigMapDataName)
   if _, err := os.Stat(caCertFile); err != nil {
      caCertFile = defaultCACertPath
   }
   raOpts := &amp;ra.IstioRAOptions{
      ExternalCAType: opts.ExternalCAType,
      DefaultCertTTL: workloadCertTTL.Get(),
      MaxCertTTL:     maxWorkloadCertTTL.Get(),
      CaSigner:       opts.ExternalCASigner,
      CaCertFile:     caCertFile,
      VerifyAppendCA: true,
      K8sClient:      client.CertificatesV1beta1(),
   }
   return ra.NewIstioRA(raOpts)

}

// security/pkg/pki/ra/common.go

// NewIstioRA is a factory method that returns an RA that implements the RegistrationAuthority functionality.
// the caOptions defines the external provider
func NewIstioRA(opts *IstioRAOptions) (RegistrationAuthority, error) {
    if opts.ExternalCAType == ExtCAK8s {
        istioRA, err := NewKubernetesRA(opts)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to create an K8s CA: %v&quot;, err)
        }
        return istioRA, err
    }
    return nil, fmt.Errorf(&quot;invalid CA Name %s&quot;, opts.ExternalCAType)
}

</code></pre>
<p>çœ‹ä¸Šå» RA ç±»å‹ç°åœ¨åªæ”¯æŒ Kubernetes ä¸€ç§ã€‚</p>
<p>RA é»˜è®¤ä¸å¯ç”¨ï¼ŒåŒæ—¶å¤„äºè¯•éªŒé˜¶æ®µï¼Œè¿™é‡Œä¸åŠ ä»¥åˆ†æã€‚</p>
<h2 id=3-é€šä¿¡å®‰å…¨>3. é€šä¿¡å®‰å…¨</h2>
<p>åŠ å¯†å’Œè®¤è¯é€šå¸¸æ˜¯ç´§å¯†ç›¸å…³çš„ï¼Œåœ¨é›¶ä¿¡ä»»æµé‡å®‰å…¨ä¸­ï¼Œ
å¯¹äºå®¢æˆ·ç«¯/æœåŠ¡å™¨çš„äº¤äº’ï¼Œä½¿ç”¨åŒå‘è®¤è¯çš„ TLS åè®®æ˜¯ä¸€ç§çš„åˆç†çš„ç½‘ç»œå®‰å…¨æ–¹æ¡ˆï¼Œ
è¿™ç§æ–¹æ¡ˆé€šå¸¸åŒ…æ‹¬é…ç½®å®¢æˆ·ç«¯å¹¶å°†å®¢æˆ·ç«¯è¯ä¹¦æä¾›ç»™æœåŠ¡å™¨ç«¯è®¿é—®ä»£ç†ï¼Œä»¥ç¡®ä¿è¿æ¥ç»è¿‡è®¤è¯å’Œæˆæƒ<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>ã€‚</p>
<h3 id=31-åŠ å¯†ä¸è®¤è¯>3.1. åŠ å¯†ä¸è®¤è¯</h3>
<h4 id=311-tls-éªŒè¯>3.1.1. TLS éªŒè¯</h4>
<p>åˆå§‹åŒ–æœåŠ¡ç«¯çš„ TLS çš„æ ¡éªŒæ–¹å¼ã€‚</p>
<pre><code class=language-go>// pilot/pkg/bootstrap/server.go

    cfg := &amp;tls.Config{
        GetCertificate: s.getIstiodCertificate,
        ClientAuth:     tls.VerifyClientCertIfGiven,
        ClientCAs:      s.peerCertVerifier.GetGeneralCertPool(),
        VerifyPeerCertificate: func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error {
            // ä½¿ç”¨ SPIFFE åŒ…æ ¡éªŒ TLS è¯ä¹¦æœ‰æ•ˆæ€§
            err := s.peerCertVerifier.VerifyPeerCert(rawCerts, verifiedChains)
            if err != nil {
                log.Infof(&quot;Could not verify certificate: %v&quot;, err)
            }
            return err
        },
    }
</code></pre>
<p>ClientAuth æœ‰äº”ç§ç±»å‹ï¼Œå„è‡ªçš„å«ä¹‰æ˜¯ï¼š</p>
<ul>
<li>
<p>NoClientCertï¼šå¿½ç•¥ä»»ä½•å®¢æˆ·ç«¯è¯ä¹¦ï¼Œå³å®¢æˆ·ç«¯å¯ä»¥ä¸æä¾›è¯ä¹¦ã€‚</p>
</li>
<li>
<p>RequestClientCerï¼šè¦æ±‚å®¢æˆ·ç«¯æä¾›è¯ä¹¦ï¼Œä½†æ˜¯å¦‚æœå®¢æˆ·ç«¯æ²¡æœ‰æä¾›è¯ä¹¦ï¼ŒæœåŠ¡ç«¯è¿˜æ˜¯ä¼šç»§ç»­å¤„ç†è¯·æ±‚ã€‚</p>
</li>
<li>
<p>RequireAnyClientCertï¼šéœ€è¦å®¢æˆ·ç«¯æä¾›è¯ä¹¦ï¼Œä½†ä¸ç”¨ClientCAæ¥éªŒè¯è¯ä¹¦çš„æœ‰æ•ˆæ€§ã€‚</p>
</li>
<li>
<p>VerifyClientCertIfGivenï¼šå¦‚æœå®¢æˆ·ç«¯æä¾›äº†è¯ä¹¦ï¼Œåˆ™ç”¨ClientCAæ¥éªŒè¯è¯ä¹¦çš„æœ‰æ•ˆæ€§ã€‚ å¦‚æœå®¢æˆ·ç«¯æ²¡æä¾›ï¼Œåˆ™ä¼šç»§ç»­å¤„ç†è¯·æ±‚ã€‚</p>
</li>
<li>
<p>RequireAndVerifyClientCertï¼šéœ€è¦å®¢æˆ·ç«¯æä¾›è¯ä¹¦ï¼Œä¸”ä¼šç”¨ClientCAæ¥éªŒè¯è¯ä¹¦çš„æœ‰æ•ˆæ€§ã€‚</p>
</li>
</ul>
<p>åœ¨ tlsConfig ä¸­å¦‚æœä¸æ˜¾å¼çš„æŒ‡å®š ClientAuthï¼Œåˆ™é»˜è®¤å€¼æ˜¯ NoClientCertã€‚å³ä½¿ Server ç«¯é…ç½®äº† CAï¼Œä¹Ÿä¸ä¼šæ ¡éªŒå®¢æˆ·ç«¯è¯ä¹¦ã€‚</p>
<h4 id=312-èº«ä»½è®¤è¯>3.1.2. èº«ä»½è®¤è¯</h4>
<p>é…ç½®æœåŠ¡ç«¯å¯¹å®¢æˆ·ç«¯è¿›è¡Œèº«ä»½è®¤è¯çš„æ–¹å¼ï¼Œé»˜è®¤å¯ç”¨å®¢æˆ·ç«¯è¯ä¹¦ï¼Œä»¥åŠ K8s JWTã€‚</p>
<pre><code class=language-go> // pilot/pkg/bootstrap/server.go
 
     // Notice that the order of authenticators matters, since at runtime
     // authenticators are activated sequentially and the first successful attempt
     // is used as the authentication result.
     // The JWT authenticator requires the multicluster registry to be initialized, so we build this later
     authenticators := []authenticate.Authenticator{
         &amp;authenticate.ClientCertAuthenticator{},
         kubeauth.NewKubeJWTAuthenticator(s.kubeClient, s.clusterID, s.multicluster.GetRemoteKubeClient, spiffe.GetTrustDomain(), features.JwtPolicy.Get()),
     }
 
     // é»˜è®¤å¯ç”¨
     caOpts.Authenticators = authenticators
     if features.XDSAuth {
         s.XDSServer.Authenticators = authenticators
     }
</code></pre>
<p>æ— è®ºæ˜¯ grpcsï¼Œè¿˜æ˜¯ grpc åè®®éƒ½ä¼šå¯ç”¨å¼ºè®¤è¯ã€‚</p>
<pre><code class=language-go>// security/pkg/server/ca/authenticate/model.go

// Caller carries the identity and authentication source of a caller.
type Caller struct {
    AuthSource AuthSource
    Identities []string
}

type Authenticator interface {
    Authenticate(ctx context.Context) (*Caller, error)
    AuthenticatorType() string
}

</code></pre>
<p>å®ç°äº† Authenticator æ¥å£çš„è®¤è¯å™¨è°ƒç”¨ Authenticate æ–¹æ³•ä» grpc è¯·æ±‚çš„ä¸Šä¸‹æ–‡ Metadata å­—æ®µä¸­è·å– Caller ä¿¡æ¯ï¼Œæ ¡éªŒå¤±è´¥åˆ™è¿”å›é”™è¯¯ã€‚</p>
<h5 id=å®¢æˆ·ç«¯è¯ä¹¦è®¤è¯>å®¢æˆ·ç«¯è¯ä¹¦è®¤è¯</h5>
<pre><code class=language-go>// security/pkg/server/ca/authenticate/cert_authenticator.go

// ClientCertAuthenticator extracts identities from client certificate.
type ClientCertAuthenticator struct{}

var _ Authenticator = &amp;ClientCertAuthenticator{}

func (cca *ClientCertAuthenticator) AuthenticatorType() string {
    return ClientCertAuthenticatorType
}

// Authenticate extracts identities from presented client certificates. This
// method assumes that certificate chain has been properly validated before
// this method is called. In other words, this method does not do certificate
// chain validation itself.
func (cca *ClientCertAuthenticator) Authenticate(ctx context.Context) (*Caller, error) {
    // ä» GRPC è¿æ¥è·å– peer ä¿¡æ¯
    peer, ok := peer.FromContext(ctx)
    if !ok || peer.AuthInfo == nil {
        return nil, fmt.Errorf(&quot;no client certificate is presented&quot;)
    }

    // è¿æ¥å¿…é¡»ä¸º TLS
    if authType := peer.AuthInfo.AuthType(); authType != &quot;tls&quot; {
        return nil, fmt.Errorf(&quot;unsupported auth type: %q&quot;, authType)
    }

    tlsInfo := peer.AuthInfo.(credentials.TLSInfo)
    chains := tlsInfo.State.VerifiedChains
    if len(chains) == 0 || len(chains[0]) == 0 {
        return nil, fmt.Errorf(&quot;no verified chain is found&quot;)
    }

    ids, err := util.ExtractIDs(chains[0][0].Extensions)
    if err != nil {
        return nil, err
    }

    return &amp;Caller{
        AuthSource: AuthSourceClientCertificate,
        Identities: ids, // id åº”è¯¥å°±æ˜¯ SPIFFE ID
    }, nil
}

</code></pre>
<p>grpc TLS åŒ…ä¼šåœ¨ TLS æ¡æ‰‹é˜¶æ®µè·å– SPIFFIE IDï¼š</p>
<pre><code class=language-go>// grpc@v1.33.1\credentials\tls.go

// TLSInfo contains the auth information for a TLS authenticated connection.
// It implements the AuthInfo interface.
type TLSInfo struct {
    State tls.ConnectionState
    CommonAuthInfo
    // This API is experimental.
    SPIFFEID *url.URL
}

func (c *tlsCreds) ServerHandshake(rawConn net.Conn) (net.Conn, AuthInfo, error) {
    conn := tls.Server(rawConn, c.config)
    if err := conn.Handshake(); err != nil {
        conn.Close()
        return nil, nil, err
    }
    tlsInfo := TLSInfo{
        State: conn.ConnectionState(),
        CommonAuthInfo: CommonAuthInfo{
            SecurityLevel: PrivacyAndIntegrity,
        },
    }
    id := credinternal.SPIFFEIDFromState(conn.ConnectionState())
    if id != nil {
        tlsInfo.SPIFFEID = id
    }
    return credinternal.WrapSyscallConn(rawConn, conn), tlsInfo, nil
}

// grpc@v1.33.1\internal\credentials\spiffe.go

// SPIFFEIDFromState parses the SPIFFE ID from State. If the SPIFFE ID format
// is invalid, return nil with warning.
func SPIFFEIDFromState(state tls.ConnectionState) *url.URL {
    if len(state.PeerCertificates) == 0 || len(state.PeerCertificates[0].URIs) == 0 {
        return nil
    }
    var spiffeID *url.URL
    for _, uri := range state.PeerCertificates[0].URIs {
        if uri == nil || uri.Scheme != &quot;spiffe&quot; || uri.Opaque != &quot;&quot; || (uri.User != nil &amp;&amp; uri.User.Username() != &quot;&quot;) {
            continue
        }
        // From this point, we assume the uri is intended for a SPIFFE ID.
        if len(uri.String()) &gt; 2048 {
            logger.Warning(&quot;invalid SPIFFE ID: total ID length larger than 2048 bytes&quot;)
            return nil
        }
        if len(uri.Host) == 0 || len(uri.RawPath) == 0 || len(uri.Path) == 0 {
            logger.Warning(&quot;invalid SPIFFE ID: domain or workload ID is empty&quot;)
            return nil
        }
        if len(uri.Host) &gt; 255 {
            logger.Warning(&quot;invalid SPIFFE ID: domain length larger than 255 characters&quot;)
            return nil
        }
        // A valid SPIFFE certificate can only have exactly one URI SAN field.
        if len(state.PeerCertificates[0].URIs) &gt; 1 {
            logger.Warning(&quot;invalid SPIFFE ID: multiple URI SANs&quot;)
            return nil
        }
        spiffeID = uri
    }
    return spiffeID
}

</code></pre>
<h5 id=k8s-jwt-è®¤è¯>K8s JWT è®¤è¯</h5>
<pre><code class=language-go>// security/pkg/server/ca/authenticate/kubeauth/kube_jwt.go

// KubeJWTAuthenticator authenticates K8s JWTs.
type KubeJWTAuthenticator struct {
    trustDomain string
    jwtPolicy   string

    // Primary cluster kube client
    kubeClient kubernetes.Interface
    // Primary cluster ID
    clusterID string

    // remote cluster kubeClient getter
    remoteKubeClientGetter RemoteKubeClientGetter
}

var _ authenticate.Authenticator = &amp;KubeJWTAuthenticator{}

// Authenticate authenticates the call using the K8s JWT from the context.
// The returned Caller.Identities is in SPIFFE format.
func (a *KubeJWTAuthenticator) Authenticate(ctx context.Context) (*authenticate.Caller, error) {
    // ä» HTTP Authenticate å­—æ®µè·å– JWT Token
    targetJWT, err := authenticate.ExtractBearerToken(ctx)
    clusterID := extractClusterID(ctx)
    var id []string

    kubeClient := a.GetKubeClient(clusterID)
    
    id, err = tokenreview.ValidateK8sJwt(kubeClient, targetJWT, aud)
    ...
    callerNamespace := id[0]
    callerServiceAccount := id[1]
    return &amp;authenticate.Caller{
        AuthSource: authenticate.AuthSourceIDToken,
        Identities: []string{fmt.Sprintf(authenticate.IdentityTemplate, a.trustDomain, callerNamespace, callerServiceAccount)},
    }, nil
}
</code></pre>
<p>ä» grpc é€šä¿¡ Metadata ä¸­è·å– JWT Tokenï¼Œä¸ K8s API Server é€šä¿¡è®¤è¯ Tokenï¼š</p>
<pre><code class=language-go>func ValidateK8sJwt(kubeClient kubernetes.Interface, targetToken string, aud []string) ([]string, error) {
    tokenReview := &amp;k8sauth.TokenReview{
        Spec: k8sauth.TokenReviewSpec{
            Token: targetToken,
        },
    }
    reviewRes, err := kubeClient.AuthenticationV1().TokenReviews().Create(context.TODO(), tokenReview, metav1.CreateOptions{})
    ...
    return getTokenReviewResult(reviewRes)
}
</code></pre>
<p>ä»ä»£ç æ³¨é‡Šä¸­å¯ä»¥çœ‹åˆ°è¯·æ±‚å’Œè¿”å›çš„ç¤ºä¾‹æ•°æ®ï¼š</p>
<pre><code class=language-go>    // An example SA token:
    // {&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}
    // {&quot;iss&quot;:&quot;kubernetes/serviceaccount&quot;,
    //  &quot;kubernetes.io/serviceaccount/namespace&quot;:&quot;default&quot;,
    //  &quot;kubernetes.io/serviceaccount/secret.name&quot;:&quot;example-pod-sa-token-h4jqx&quot;,
    //  &quot;kubernetes.io/serviceaccount/service-account.name&quot;:&quot;example-pod-sa&quot;,
    //  &quot;kubernetes.io/serviceaccount/service-account.uid&quot;:&quot;ff578a9e-65d3-11e8-aad2-42010a8a001d&quot;,
    //  &quot;sub&quot;:&quot;system:serviceaccount:default:example-pod-sa&quot;
    //  }

    // An example token review status
    // &quot;status&quot;:{
    //   &quot;authenticated&quot;:true,
    //   &quot;user&quot;:{
    //     &quot;username&quot;:&quot;system:serviceaccount:default:example-pod-sa&quot;,
    //     &quot;uid&quot;:&quot;ff578a9e-65d3-11e8-aad2-42010a8a001d&quot;,
    //     &quot;groups&quot;:[&quot;system:serviceaccounts&quot;,&quot;system:serviceaccounts:default&quot;,&quot;system:authenticated&quot;]
    //    }
    // }
</code></pre>
<h3 id=32-xds-é€šä¿¡åè®®>3.2. xDS é€šä¿¡åè®®</h3>
<p>SDS åè®®æ˜¯ xDS åè®®çš„ä¸€ç±»ï¼Œåœ¨ Istio ä¸­ï¼ŒSDS ç”¨äºä¼ è¾“è¯ä¹¦æ•°æ®ã€‚</p>
<pre><code class=language-mermaid>graph LR
    A[Discovery] &lt;-- SDS --&gt; B[pilot-agent] &lt;-- &quot;SDS (UDS)&quot; --&gt; C[Envoy]
</code></pre>
<p><em>pilot-agent</em> åŸæœ¬å« Node Agentï¼Œè´Ÿè´£è½¬å‘ Envoy çš„ SDS è¯·æ±‚ï¼Œä»¥åŠè´Ÿè´£ç”Ÿæˆ CSR è¯·æ±‚åˆ° discoveryã€‚</p>
<p>ä¸ºäº†é¿å…æ··æ·†ï¼Œæ³¨æ˜é•œåƒåï¼š</p>
<ul>
<li>pilot-agent: <code>istio/proxyv2:1.8.0</code> ä¸­çš„ <code>pilot-agent proxy sidecar</code></li>
<li>discovery: <code>istio/pilot:1.8.0</code></li>
</ul>
<h4 id=321-server>3.2.1. Server</h4>
<h5 id=äº‹ä»¶å¹¿æ’­>äº‹ä»¶å¹¿æ’­</h5>
<p>Discovery åˆå§‹åŒ– SDS æœåŠ¡å™¨ï¼š</p>
<pre><code class=language-go>// initSDSServer starts the SDS server
func (s *Server) initSDSServer(args *PilotArgs) {
    if s.kubeClient != nil {
        if !features.EnableXDSIdentityCheck {
            // Make sure we have security
            log.Warnf(&quot;skipping Kubernetes credential reader; PILOT_ENABLE_XDS_IDENTITY_CHECK must be set to true for this feature.&quot;)
        } else {
            // å¯ç”¨ XDS Namespace è®¤è¯
            // é»˜è®¤æ˜¯ istio-system Namespace
            // ç›‘å¬ K8S Secrets å˜åŒ–
            sc := kubesecrets.NewMulticluster(s.kubeClient, s.clusterID, args.RegistryOptions.ClusterRegistriesNamespace)
            sc.AddEventHandler(func(name, namespace string) {
                s.XDSServer.ConfigUpdate(&amp;model.PushRequest{
                    Full: false,
                    ConfigsUpdated: map[model.ConfigKey]struct{}{
                        {
                            Kind:      gvk.Secret,
                            Name:      name,
                            Namespace: namespace,
                        }: {},
                    },
                    Reason: []model.TriggerReason{model.SecretTrigger},
                })
            })
            // XDS Generator
            s.XDSServer.Generators[v3.SecretType] = xds.NewSecretGen(sc, s.XDSServer.Cache)
        }
    }
}
</code></pre>
<p><code>SecretController</code> ä¼šç›‘è§† K8s é›†ç¾¤ä¸­ç‰¹æ®Šç±»å‹ï¼ˆIstio å¤šé›†ç¾¤ï¼‰çš„ Secret èµ„æºå˜åŒ–ï¼Œå¹¶é€šè¿‡ xDS å¹¿æ’­ï¼š</p>
<pre><code class=language-go>// pkg/kube/secretcontroller/secretcontroller.go

    secretsInformer := cache.NewSharedIndexInformer(
        &amp;cache.ListWatch{
            ListFunc: func(opts meta_v1.ListOptions) (runtime.Object, error) {
                // é™å®š Label ä¸º &quot;istio/multiCluster=true&quot;
                opts.LabelSelector = MultiClusterSecretLabel + &quot;=true&quot;
                return kubeclientset.CoreV1().Secrets(namespace).List(context.TODO(), opts)
            },
            WatchFunc: func(opts meta_v1.ListOptions) (watch.Interface, error) {
                opts.LabelSelector = MultiClusterSecretLabel + &quot;=true&quot;
                return kubeclientset.CoreV1().Secrets(namespace).Watch(context.TODO(), opts)
            },
        },
        &amp;corev1.Secret{}, 0, cache.Indexers{},
    )
</code></pre>
<h5 id=gateway-è¯ä¹¦>Gateway è¯ä¹¦</h5>
<p><code>Generate</code> æ–¹æ³•ä»…ä»…åœ¨ pilot-agent ç±»å‹ä¸º routerï¼ˆå³ Gatewayï¼‰çš„æ—¶å€™ç”Ÿæˆ Envoy ä½¿ç”¨çš„è¯ä¹¦è¿”å›ã€‚</p>
<pre><code class=language-go>// pilot/pkg/xds/sds.go

// ä¸ Node Agent ä¹Ÿå°±æ˜¯ Istio Proxy è¿›è¡Œé€šä¿¡è¿”å›çš„æ–¹æ³•
func (s *SecretGen) Generate(proxy *model.Proxy, _ *model.PushContext, w *model.WatchedResource, req *model.PushRequest) model.Resources {
  ...
   // è°ƒç”¨ K8S API Server ç¡®è®¤èº«ä»½ SA æ˜¯å¦æœ‰æƒé™è®¿é—® secrets
   if err := secrets.Authorize(proxy.VerifiedIdentity.ServiceAccount, proxy.VerifiedIdentity.Namespace); err != nil {
      adsLog.Warnf(&quot;proxy %v is not authorized to receive secrets: %v&quot;, proxy.ID, err)
      return nil
   }
   // å¦‚æœä¸æ˜¯ gateway åˆ™è¿”å› nil
   if req == nil || !needsUpdate(proxy, req.ConfigsUpdated) {
      return nil
   }
   var updatedSecrets map[model.ConfigKey]struct{}
   if !req.Full {
      updatedSecrets = model.ConfigsOfKind(req.ConfigsUpdated, gvk.Secret)
   }
   results := model.Resources{}
   for _, resource := range w.ResourceNames {
      ...
      isCAOnlySecret := strings.HasSuffix(sr.Name, GatewaySdsCaSuffix)
      if isCAOnlySecret {
         secret := secrets.GetCaCert(sr.Name, sr.Namespace)
         if secret != nil {
            res := toEnvoyCaSecret(sr.ResourceName, secret)
            results = append(results, res)
            s.cache.Add(sr, res)
         } else {
            adsLog.Warnf(&quot;failed to fetch ca certificate for %v&quot;, sr.ResourceName)
         }
      } else {
          // ç”Ÿæˆå¯†é’¥å’Œè¯ä¹¦
         key, cert := secrets.GetKeyAndCert(sr.Name, sr.Namespace)
         if key != nil &amp;&amp; cert != nil {
            res := toEnvoyKeyCertSecret(sr.ResourceName, key, cert)
            results = append(results, res)
            s.cache.Add(sr, res)
         } else {
            adsLog.Warnf(&quot;failed to fetch key and certificate for %v&quot;, sr.ResourceName)
         }
      }
   }
   return results
}
</code></pre>
<h4 id=322-client>3.2.2. Client</h4>
<h5 id=åˆå§‹åŒ–-sds>åˆå§‹åŒ– SDS</h5>
<p>é…ç½®é¡¹ï¼š</p>
<pre><code class=language-go>// pilot-agent æ›´æ–°è¯ä¹¦å‘¨æœŸæ˜¯ 24 å°æ—¶
secretTTLEnv = env.RegisterDurationVar(&quot;SECRET_TTL&quot;, 24*time.Hour,
        &quot;The cert lifetime requested by istio agent&quot;).Get()
</code></pre>
<pre><code class=language-go>// pkg/istio-agent/agent.go

func (sa *Agent) Start(isSidecar bool, podNamespace string) (*sds.Server, error) {

    // æœ¬åœ°è¿›ç¨‹è¯ä¹¦ç¼“å­˜
    // TODO: remove the caching, workload has a single cert
    if sa.WorkloadSecrets == nil {
        sa.WorkloadSecrets, _ = sa.newWorkloadSecretCache()
    }

    server, err := sds.NewServer(sa.secOpts, sa.WorkloadSecrets)


    // Start the local XDS generator.
    if sa.localXDSGenerator != nil {
        err = sa.startXDSGenerator(sa.proxyConfig, sa.WorkloadSecrets, podNamespace)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to start local xds generator: %v&quot;, err)
        }
    }

    if err = sa.initLocalDNSServer(isSidecar); err != nil {
        return nil, fmt.Errorf(&quot;failed to start local DNS server: %v&quot;, err)
    }
    if sa.cfg.ProxyXDSViaAgent {
        sa.xdsProxy, err = initXdsProxy(sa)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to start xds proxy: %v&quot;, err)
        }
    }
    return server, nil
}
</code></pre>
<p>æ­¤éƒ¨åˆ†æœ‰å¼‚å¸¸å¤šæ—§ä»£ç ä»¥åŠ TODOï¼Œæ¨æµ‹æ˜¯åŸæ¥æ¶æ„æœ‰ DaemonSet éƒ¨ç½²çš„ Node Agentï¼Œç›®å‰æ¶æ„ä¸­å»é™¤äº†ï¼ŒNode Agent çš„å·¥ä½œç”± pilot-agent å®Œæˆï¼Œåªå¤„ç†è‡ªèº«å®¹å™¨å†… Envoy çš„è¯·æ±‚ï¼Œè‡ªç„¶ä¸éœ€è¦å¤šå¤æ‚çš„ç¼“å­˜æœºåˆ¶ã€‚</p>
<pre><code class=language-go>// security/pkg/nodeagent/sds/server.go

// NewServer creates and starts the Grpc server for SDS.
func NewServer(options *ca2.Options, workloadSecretCache ca2.SecretManager) (*Server, error) {
    s := &amp;Server{
        workloadSds: newSDSService(workloadSecretCache, options, options.FileMountedCerts),
    }
    if options.EnableWorkloadSDS {
        if err := s.initWorkloadSdsService(options); err != nil {
            sdsServiceLog.Errorf(&quot;Failed to initialize secret discovery service for workload proxies: %v&quot;, err)
            return nil, err
        }
    }
    return s, nil
}

func (s *Server) initWorkloadSdsService(options *ca2.Options) error { //nolint: unparam
    if options.GrpcServer != nil {
        s.grpcWorkloadServer = options.GrpcServer
        s.workloadSds.register(s.grpcWorkloadServer)
        return nil
    }
    s.grpcWorkloadServer = grpc.NewServer(s.grpcServerOptions(options)...)
    s.workloadSds.register(s.grpcWorkloadServer)

    var err error
    // Unix Domain Socket SDS é€šä¿¡
    s.grpcWorkloadListener, err = uds.NewListener(options.WorkloadUDSPath)
    if err != nil {
        sdsServiceLog.Errorf(&quot;Failed to set up UDS path: %v&quot;, err)
    }

    go func() {
        sdsServiceLog.Info(&quot;Start SDS grpc server&quot;)
        ...
    }()

    return nil
}
</code></pre>
<p>è¿™é‡Œå¯ä»¥çœ‹åˆ°æœ¬åœ°ç›‘å¬ UDSï¼Œä¸ Envoy é€šä¿¡ã€‚</p>
<h5 id=æ„å»º-csr>æ„å»º CSR</h5>
<pre><code class=language-go>// pkg/istio-agent/agent.go

        ...
            // è·å– Istio CA çš„è¯ä¹¦ï¼ŒæŒ‚è½½çš„ Configmap
            caCertFile := sa.FindRootCAForCA()
        ...
             // ä¸ Istio CA å»ºç«‹è¿æ¥
        caClient, err = citadel.NewCitadelClient(sa.secOpts.CAEndpoint, tls, rootCert, sa.secOpts.ClusterID)
</code></pre>
<pre><code class=language-go>// security/pkg/nodeagent/cache/secretcache.go

// GenerateSecret generates new secret and cache the secret, this function is called by SDS.StreamSecrets
// and SDS.FetchSecret. Since credential passing from client may change, regenerate secret every time
// instead of reading from cache.
func (sc *SecretCache) GenerateSecret(ctx context.Context, connectionID, resourceName, token string) (*security.SecretItem, error) {

   // First try to generate secret from file.
   sdsFromFile, ns, err := sc.generateFileSecret(connKey, token)

   return ns, nil
}

func (sc *SecretCache) generateSecret(ctx context.Context, token string, connKey ConnKey, t time.Time) (*security.SecretItem, error) {
    ...
    // æ„å»º SPIFFE SAN å­—æ®µ
    csrHostName := &amp;spiffe.Identity{
        TrustDomain:    sc.configOptions.TrustDomain,
        Namespace:      sc.configOptions.WorkloadNamespace,
        ServiceAccount: sc.configOptions.ServiceAccount,
    }

    // æ„å»º CSR å‚æ•°
    options := pkiutil.CertOptions{
        Host:       csrHostName.String(),
        RSAKeySize: keySize,
        PKCS8Key:   sc.configOptions.Pkcs8Keys,
        ECSigAlg:   pkiutil.SupportedECSignatureAlgorithms(sc.configOptions.ECCSigAlg),
    }

    // Generate the cert/key, send CSR to CA.
    csrPEM, keyPEM, err := pkiutil.GenCSR(options)

    // è°ƒç”¨ Istio CA å‘é€ CSR è¯·æ±‚
    certChainPEM, err := sc.sendRetriableRequest(ctx, csrPEM, exchangedToken, connKey, true)
...
}
</code></pre>
<p>æµç¨‹ï¼š</p>
<ol>
<li>æ£€æŸ¥/åˆ›å»ºç§é’¥</li>
<li>æ„å»º CSRï¼ˆCSR çš„ Host æ˜¯ SAN URIï¼Œå³ SPIFFE IDï¼‰</li>
<li>è¯·æ±‚ Istio CA</li>
</ol>
<h5 id=è¯ä¹¦è½®æ¢>è¯ä¹¦è½®æ¢</h5>
<p>ä¸¤ç§æƒ…å†µï¼š</p>
<ol>
<li>Workload è¯ä¹¦å®šæœŸæ›´æ–°</li>
<li>CA è¯ä¹¦æ”¹å˜</li>
</ol>
<pre><code class=language-go>// security/pkg/nodeagent/cache/secretcache.go

func (sc *SecretCache) shouldRotate(secret *security.SecretItem) bool {
    // secret should be rotated before it expired.
    secretLifeTime := secret.ExpireTime.Sub(secret.CreatedTime)
    gracePeriod := time.Duration(sc.configOptions.SecretRotationGracePeriodRatio * float64(secretLifeTime))
    rotate := time.Now().After(secret.ExpireTime.Add(-gracePeriod))
    cacheLog.Debugf(&quot;Secret %s: lifetime: %v, graceperiod: %v, expiration: %v, should rotate: %v&quot;,
        secret.ResourceName, secretLifeTime, gracePeriod, secret.ExpireTime, rotate)
    return rotate
}
</code></pre>
<p>é»˜è®¤ Workload è¯ä¹¦ 24 å°æ—¶è½®æ¢ã€‚</p>
<pre><code class=language-go>// security/pkg/nodeagent/cache/secretcache.go

func (sc *SecretCache) addFileWatcher(file string, token string, connKey ConnKey) {
    ...

    if err := sc.certWatcher.Add(file); err != nil {
        ...
    }
    go func() {
        var timerC &lt;-chan time.Time
        for {
            select {
            case &lt;-timerC:
                timerC = nil
                // TODO(ramaraochavali): Remove the watchers for unused keys and certs.
                sc.certMutex.RLock()
                connKeys := sc.fileCerts[npath]
                sc.certMutex.RUnlock()
                // Update all connections that use this file.
                for ckey := range connKeys {
                    if _, ok := sc.secrets.Load(ckey); ok {
                        // Regenerate the Secret and trigger the callback that pushes the secrets to proxy.
                        // é‡æ–°ç”Ÿæˆè¯ä¹¦
                        sc.generateFileSecret(ckey, token)
                    }
                }
            }
        }
    }()
}
</code></pre>
<p>ç›‘å¬æ ¹è¯ä¹¦æ–‡ä»¶çš„å˜åŒ–ï¼š</p>
<pre><code class=language-go>// security/pkg/nodeagent/cache/secretcache.go        
    if sitem, err = sc.generateRootCertFromExistingFile(sc.existingRootCertFile, token, connKey, true); err == nil {
            sc.addFileWatcher(sc.existingRootCertFile, token, connKey)
        }
</code></pre>
<p>é™„ Istio è¯ä¹¦ä½“ç³»ç›¸å…³æµç¨‹å›¾<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>ï¼š</p>
<p>
<figure class=image>
<img src=/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/images/cert-flow.png alt loading=lazy>
</figure></p>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>æ‘˜è‡ªã€Šé›¶ä¿¡ä»»ç½‘ç»œ : åœ¨ä¸å¯ä¿¡ç½‘ç»œä¸­æ„å»ºå®‰å…¨ç³»ç»Ÿã€‹ç¬¬ 6 ç« â€”å»ºç«‹ç”¨æˆ·ä¿¡ä»»&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p><a href=https://istio.io/latest/docs/concepts/security/#secure-naming>Istio / Security - Secure naming</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p><a href=https://github.com/spiffe/spiffe/blob/main/standards/SPIFFE.md#1-introduction>Secure Production Identity Framework for Everyone (SPIFFE) - 1. Introduction</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p><a href=https://developer.aliyun.com/article/740195>Kubernetes ä¸‹é›¶ä¿¡ä»»å®‰å…¨æ¶æ„åˆ†æ - èš‚èšé›¶ä¿¡ä»»æ¶æ„ä½“ç³»è½åœ°æœ€ä½³å®è·µ</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p>æ‘˜è‡ªã€Šé›¶ä¿¡ä»»ç½‘ç»œ : åœ¨ä¸å¯ä¿¡ç½‘ç»œä¸­æ„å»ºå®‰å…¨ç³»ç»Ÿã€‹ç¬¬ 2 ç« â€”ä¿¡ä»»ç®¡ç†&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:6 role=doc-endnote>
<p><a href=https://istio.io/latest/news/releases/1.8.x/announcing-1.8/>Announcing Istio 1.8</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:7 role=doc-endnote>
<p>æ‘˜è‡ªã€Šé›¶ä¿¡ä»»ç½‘ç»œ : åœ¨ä¸å¯ä¿¡ç½‘ç»œä¸­æ„å»ºå®‰å…¨ç³»ç»Ÿã€‹ç¬¬ 8 ç« â€”å»ºç«‹æµé‡ä¿¡ä»»&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:8 role=doc-endnote>
<p><a href=https://blog.csdn.net/yevvzi/article/details/107863433>Istio è¯ä¹¦ç­¾å‘æµç¨‹</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<div class=post-meta>
<time datetime=" 2021-10-26" itemprop=datePublished>Oct 26, 2021</time>
</div>
</footer>
</article>
<script src=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.min.js></script>
<aside class=typeface-sans lang=zh-hans>
<nav class=toc></nav>
</aside>
<script>tocbot.init({tocSelector:'.toc',contentSelector:'article',headingSelector:'h1, h2, h3, h4, h5',hasInnerContainers:!0,collapseDepth:"3",positionFixedSelector:".toc",headingsOffset:10})</script>
</div><script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/filter-highlight-all/prism-filter-highlight-all.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script>Prism.plugins.filterHighlightAll.add(function(a){return a.language!=="mermaid"})</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.init({startOnLoad:!0},"pre code.language-mermaid",function(){const a=document.querySelectorAll('code.language-mermaid');for(const c of a){c.style.backgroundColor='initial';const b=c.parentNode;b.style.border='none',b.style.textAlign='center',window.darkmode&&!window.darkmode.isActivated()&&(b.style.backgroundColor='initial')}})</script>
</div>
</main><footer class=site-footer>
<div class=wrapper>
<div class=social-links>
<a class="social-link social-github" href=https://github.com/mayocream><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5C9.34 21.58 9.5 21.27 9.5 21 9.5 20.77 9.5 20.14 9.5 19.31 6.73 19.91 6.14 17.97 6.14 17.97c-.46-1.16-1.11-1.47-1.11-1.47C4.12 15.88 5.1 15.9 5.1 15.9 6.1 15.97 6.63 16.93 6.63 16.93 7.5 18.45 8.97 18 9.54 17.76 9.63 17.11 9.89 16.67 10.17 16.42c-2.22-.25-4.55-1.11-4.55-4.92.0-1.11.38-2 1.03-2.71C6.55 8.54 6.2 7.5 6.75 6.15c0 0 .84-.27 2.75 1.02C10.29 6.95 11.15 6.84 12 6.84s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02C17.8 7.5 17.45 8.54 17.35 8.79 18 9.5 18.38 10.39 18.38 11.5c0 3.82-2.34 4.66-4.57 4.91C14.17 16.72 14.5 17.33 14.5 18.26c0 1.34.0 2.42.0 2.74.0.27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg>
</a>
<a class="social-link social-rss" href=/index.xml target=_blank><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M6.18 15.64a2.18 2.18.0 012.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18.0 012.18-2.18M4 4.44A15.56 15.56.0 0119.56 20H16.73A12.73 12.73.0 004 7.27V4.44M4 10.1A9.9 9.9.0 0113.9 20H11.07A7.07 7.07.0 004 12.93V10.1z"/></svg>
</a>
</div>
<div class=credits>
Theme KAGAMI by Kamikat
</div>
</div>
</footer><script>(function(a){for(var a=Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')),b=0,c;b!=a.length;b++)c=a[b],c.innerHTML=c.innerHTML.replace(/[\u2000-\u206eâ¸€-\u2e7eâº€-\u2efeâ¼€-\u2fdeâ¿°-\u2ffe\u3000-ã€¾\u3040-ã‚ã‚ -ãƒ¾\u3100-\u312e\u3130-ã†ã†-ã†ã† -\u31beã‡€-\u31eeã‡°-ã‡¾ãˆ€-ã‹¾ãŒ€-ã¾ã€-\u4dbeä¸€-\u9ffe\ua960-\ua97eê°€-\ud7ae\ud7b0-\ud7feï¤€-\ufafeï¸°-ï¹\uff00-ï¿®]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud82c[\udc00-\udcfe]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e]/g,function(a){return'<span class="baseline-fix-block">'+a+'<'+'/span>'}),c.classList.remove('baseline-fix')})(Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')))</script>
<script type=text/javascript>const resize=function(){this.width=.5*(this.naturalWidth||this.width)};Array.prototype.forEach.call(document.querySelectorAll('.half-size, .retina2x'),function(a){a.naturalWidth?resize.call(a):a.onload=resize})</script>
<script src=https://cdn.jsdelivr.net/npm/twemoji@13.1.0/dist/twemoji.min.js></script>
<script>twemoji.parse(document.body,{folder:'svg',ext:'.svg'})</script>
</body>