<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/c3b55921f92a131e.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-072f062dc024cc52.js"/><script src="/_next/static/chunks/f4f1b8d9-0107da81548bf985.js" async=""></script><script src="/_next/static/chunks/435-d305dd8b5fb158de.js" async=""></script><script src="/_next/static/chunks/main-app-3958e659bb0a464b.js" async=""></script><title>Mayo Rocks!</title><meta name="description" content="Mayo&#x27;s Blog"/><link rel="icon" href="/icon.png?14d5a92fbe70e82a" type="image/png" sizes="460x460"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased"><article><p>è¿™ç¯‡æºç é˜…è¯»ç¼–å†™äº 2020 å¹´ 12 æœˆï¼ŒåŸæœ¬å‡ºäºè‡ªå·±æƒ³å®ç°ä¸€ä¸ª Go è¯­è¨€çš„é™æ€åšå®¢ç”Ÿæˆå™¨ï¼Œå¼€å§‹é˜…è¯» Hugo çš„æºç ï¼Œäº†è§£ä¸€äº›å®ç°çš„ç»†èŠ‚ä¸éœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼Œé€”ä¸­å‘ç°ä»£ç é‡å·¨å¤§ï¼Œè€Œä¸”å†…éƒ¨å®ç°é€»è¾‘è¾ƒä¸ºå¤æ‚ï¼Œåœ¨è¿™é‡Œä¹Ÿåªå¯¹éƒ¨åˆ†é€»è¾‘è¿›è¡Œäº†æ¢³ç†ï¼ˆåªæ˜¯å†°å±±ä¸€è§’ï¼‰ã€‚</p>
<h2>1. æ¦‚è¿°</h2>
<p>æˆ‘é˜…è¯»å¹¶ä½œå‡ºä¸­æ–‡æ³¨é‡Šçš„ Commits å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ï¼š
<a href="https://github.com/mayocream/hugo/commits?author=mayocream">https://github.com/mayocream/hugo/commits?author=mayocream</a></p>
<p>é˜…è¯»æºç çš„è¿‡ç¨‹ä¸­ä¹Ÿå½“ typofix æœºå™¨äººæäº† <a href="https://github.com/gohugoio/hugo/pull/8034">PR</a>ï¼Œæ¯•ç«Ÿè‡ªå·±ç¡®å®æ²¡æœ‰èƒ½è´¡çŒ®çš„åœ°æ–¹ã€‚ä¸è¿‡é˜…è¯»æºç å¹¶æ³¨é‡Šå¸®åŠ©ç†è§£ï¼Œæ–¹ä¾¿æ•´ç†ä¹Ÿæ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ï¼Œåœ¨å·¥ä½œä¸­æˆ‘é€æ¸å­¦ä¼šäº†ã€‚</p>
<p>æ ¹æ® <a href="https://en.wikipedia.org/wiki/Hugo_(software)">Wikipedia</a> çš„è®°è½½ï¼ŒHugo æ—©åœ¨ 2013 å¹´å°±å‘å¸ƒäº†ï¼Œç›´åˆ°å»å¹´æˆ‘ä¸€ç›´æ²¡æœ‰ä½¿ç”¨è¿‡ï¼Œå¯èƒ½æ˜¯å®ƒæ²¡æœ‰å®˜æ–¹çš„ä¸­æ–‡æ–‡æ¡£ï¼ŒGo è¯­è¨€å¯¹å½“æ—¶æˆ‘ä¹Ÿå¤ªç”Ÿç–ï¼Œè€Œä¸” Hugo çš„æ¨¡æ¿è¯­æ³•å’Œ Hexo ä¸ Jekyll ä¹Ÿä¸ä¸€æ ·ï¼Œè€Œä¸”å®˜æ–¹æ¨èç”¨ Theme çš„æ–¹å¼æ˜¯ Git Submoduleï¼Œç›¸æ¯”äº Hexo ä¸Šæ‰‹éš¾åº¦è¿˜æ˜¯é«˜ä¸€äº›ã€‚</p>
<p>ç°åœ¨ä½œä¸ºä½¿ç”¨è€…æ¥è¯´ï¼ŒHugo ä½¿ç”¨çš„ Go æ¨¡æ¿è¯­æ³•å¾ˆå¥½ç”¨ï¼ŒHugo åŸºäºæ¨¡æ¿çš„ Pipeline å®ç°çš„æ•°æ®é¢„å¤„ç†ä¹Ÿéå¸¸æ–¹ä¾¿ï¼Œç”¨äº†å°±åœä¸ä¸‹æ¥äº†ã€‚è€Œä¸”åŸºäº <a href="https://github.com/evanw/esbuild">esbuild</a> çš„æ‰“åŒ…ä½¿å¾—é™æ€èµ„æºçš„æ„å»ºä¹Ÿå¾ˆæ–¹ä¾¿ï¼Œç»ˆäºè„±ç¦» Webpack äº†ã€‚æˆ‘è¿˜æœ‰ä¸€ä¸ªå¼ƒå‘çš„é¡¹ç›® <a href="https://github.com/mayocream/material-design-blog">material-design-blog</a> ä¹Ÿæ˜¯ä½¿ç”¨çš„ Snowpack (esbuild) è¿›è¡Œé™æ€èµ„æºçš„æ‰“åŒ…ï¼Œä¸çŸ¥é“éƒ½å·²ç»æ˜¯ 2021 å¹´æœ«äº†ï¼Œä¸ºä»€ä¹ˆå…¬å¸çš„é‚£ç¾¤äººè¿˜è¦ä½¿ç”¨ Webpack ç¼“æ…¢åœ°æ„å»ºå‘¢ã€‚</p>
<p>Hugo ç°åœ¨åŸºæœ¬ä¸Š Github ä¸Šå¼€æºé¡¹ç›®æ–‡æ¡£å‘å¸ƒçš„æ ‡é…ï¼Œä¸è¿‡ Cloudflare çš„å¼€å‘è€…æ–‡æ¡£æ˜¯ä½¿ç”¨ <a href="https://www.gatsbyjs.com/">Gatsby</a> å‘å¸ƒçš„ï¼Œå¯èƒ½ Cloudflare å†…éƒ¨ JavaScript ç”¨å¾—ä¹Ÿå¤šå§ï¼ŒWorker å¯¹äº Go å°±<a href="https://community.cloudflare.com/t/native-golang-support-for-workers/65896">æ²¡æœ‰åŸç”Ÿæ”¯æŒ</a>ã€‚</p>
<p>åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­æˆ‘è¿˜æ˜¯å°½é‡å…‹åˆ¶è‡ªå·±ä½¿ç”¨ Hugo <a href="https://gohugo.io/content-management/shortcodes/">Shortcodes</a>ï¼Œä¸€ä¸ª Markdown æ–‡æ¡£åº”è¯¥ä¿æŒçº¯å‡€ï¼Œé™¤äº† Markdown æ‰©å±•è¯­æ³•ä»¥å¤–éƒ½ä¸è¦ä½¿ç”¨ï¼Œéœ€è¦ç‰¹æ®Šå®ç°çš„ä¹Ÿä½¿ç”¨åŸç”Ÿ HTML æ ‡ç­¾ï¼Œè¿™æ ·æ–¹ä¾¿å°†å†™ä½œå’Œ Blog å‘å¸ƒåˆ†ç¦»ã€‚</p>
<p>æˆ‘è‡ªå·±ç”¨åœ¨ <a href="https://github.com/mayocream/Translations">Translations</a> é¡¹ç›®ä¸­çš„ Hugo çš„ Shortcode æ˜¯ï¼š</p>
<pre><code class="language-html">&#x3C;figure class="manga">
    &#x3C;img src="https://cdn.jsdelivr.net/gh/mayocream/Translations@gh-pages/raw/{{ .Get "src" }}" alt="" loading="lazy">
    &#x3C;figcaption>{{ .Get "alt" }}&#x3C;/figcaption>
&#x3C;/figure>
</code></pre>
<p>ä¸ºäº†åˆ©ç”¨ä¸Š Figure æ ‡ç­¾ä¸ jsDelivr çš„ CDNï¼Œä½¿ç”¨äº† Shortcodeï¼Œä¸è¿‡è¯¥é¡¹ç›®ä¸­é‡‡ç”¨ Hugo æ˜¯ä¸“é—¨ä¸ºäº†è¿›è¡Œå‘å¸ƒç®¡ç†çš„ï¼Œå…³äºè¿™ä¸ªå¦‚æœæˆ‘è¿˜æœ‰æ—¶é—´åšæ›´å¤šç¿»è¯‘çš„è¯ï¼Œå¯èƒ½ä¼šå†™ä¸€ç¯‡æ–‡ç« æ¥ä»‹ç»ç¿»è¯‘å°å·¥ç¨‹çš„å·¥ä½œæµ ğŸ¤¹ã€‚</p>
<h3>1.1. ç›®å½•ç»“æ„</h3>
<p>Hugo çš„å¼€å‘æ—¶é—´è¾ƒæ—©ï¼Œæ‰€ä»¥ç›®å½•ç»“æ„è¾ƒä¸ºåˆ†æ•£ï¼Œä¸ <a href="https://github.com/golang-standards/project-layout">Standard Go Project Layout</a> å·®å¼‚è¾ƒå¤§ï¼Œå½“ç„¶è¿™ä¸ªç¤¾åŒºæå‡ºçš„ç›®å½•è§„èŒƒå»ºè®®ï¼Œä¹Ÿå­˜åœ¨ç€äº‰è®®ï¼Œä¸è¿‡ Google çš„ä¸å°‘é¡¹ç›®éƒ½æ˜¯éµå¾ªè¿™ä¸ªè§„èŒƒçš„ï¼Œä¾‹å¦‚ <a href="https://github.com/kubernetes/kubernetes">Kubernetes</a> å’Œ <a href="https://github.com/grpc/grpc-go">grpc-go</a>ã€‚</p>
<pre><code class="language-bash">$ tree -L 1 -d
.
â”œâ”€â”€ commands   // CLI å…¥å£, è§£æ flags
â”œâ”€â”€ common     // å·¥å…·ç±»
â”œâ”€â”€ hugofs     // FS å°è£…, åŸºäº afero/fs
â”œâ”€â”€ hugolib    // ç¨‹åºä¸»é€»è¾‘
â”œâ”€â”€ lazy       // æ‡’åŠ è½½å·¥å…·åŒ…
â”œâ”€â”€ livereload // Live é¢„è§ˆ, åŸºäº Service Worker
â”œâ”€â”€ markup     // Markdown è§£æç›¸å…³
â”œâ”€â”€ parser     // è§£ææ–‡ä»¶å¤´
...

40 directories
</code></pre>
<h2>2. ç¨‹åºæµç¨‹</h2>
<h3>2.1. æµç¨‹å®šä¹‰</h3>
<h4>2.1.1. é”™è¯¯çŠ¶æ€ç </h4>
<pre><code class="language-go">func main() {
	resp := commands.Execute(os.Args[1:])

	if resp.Err != nil {
		if resp.IsUserError() {
			resp.Cmd.Println("")
			resp.Cmd.Println(resp.Cmd.UsageString())
		}
		os.Exit(-1)
	}
}
</code></pre>
<p><code>os.Exit(-1)</code> ç¨‹åºçš„é€€å‡ºçŠ¶æ€ç ä¸åœ¨ 0~255 ä¹‹é—´ï¼Œä¼šè‡ªåŠ¨åšè½¬æ¢ï¼Œè½¬æ¢çš„è§„åˆ™å¦‚ä¸‹<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref aria-describedby="footnote-label">1</a></sup>ï¼š</p>
<ul>
<li>å½“æŒ‡å®šçš„é€€å‡ºæ—¶çŠ¶æ€ç ä¸ºè´Ÿæ•°:</li>
</ul>
<pre><code class="language-fallback">256 - (|code| % 256)
</code></pre>
<ul>
<li>å½“æŒ‡å®šçš„é€€å‡ºæ—¶çŠ¶æ€ç ä¸ºæ­£æ•°:</li>
</ul>
<pre><code class="language-fallback">code % 256
</code></pre>
<p>ç”±æ­¤ç¨‹åºé€€å‡ºçš„çŠ¶æ€ç ä¸º 255ã€‚</p>
<h4>2.1.2. CLI å‘½ä»¤</h4>
<pre><code class="language-go">// commands/commands.go
func (b *commandsBuilder) addAll() *commandsBuilder {
   b.addCommands(
      b.newServerCmd(),
      newVersionCmd(),
      newEnvCmd(),
      b.newConfigCmd(),
      newCheckCmd(),
      b.newDeployCmd(),
      b.newConvertCmd(),
      b.newNewCmd(),
      b.newListCmd(),
      newImportCmd(),
      newGenCmd(),
      createReleaser(),
      b.newModCmd(),
   )

   return b
}
</code></pre>
<p>æ‰€æœ‰çš„ cmd handler ç»§æ‰¿è‡ª basecmdï¼Œå®ç°äº† cmder æ¥å£ï¼š</p>
<pre><code class="language-go">// commands/helpers.go
type cmder interface {
	flagsToConfig(cfg config.Provider)
	getCommand() *cobra.Command
}
</code></pre>
<p><img src="/images/2020-12-01-02.png" alt=""></p>
<pre><code class="language-go">// commands/commands.go
func (b *commandsBuilder) addAll() *commandsBuilder {
	b.addCommands(
		b.newServerCmd(),
		newVersionCmd(),
		newEnvCmd(),
		b.newConfigCmd(),
		newCheckCmd(),
		b.newDeployCmd(),
		b.newConvertCmd(),
		b.newNewCmd(),
		b.newListCmd(),
		newImportCmd(),
		newGenCmd(),
		createReleaser(),
		b.newModCmd(),
	)

	return b
}

func (b *commandsBuilder) build() *hugoCmd {
	// æ·»åŠ ä¸» hugo å‘½ä»¤
	h := b.newHugoCmd()
	// å°†å‘½ä»¤æ•°ç»„æ·»åŠ è¿› cobra çš„ Root Command ä¸­, ä½œä¸ºå­å‘½ä»¤
	addCommands(h.getCommand(), b.commands...)
	return h
}
</code></pre>
<h3>2.2. æ¸²æŸ“åˆå§‹åŒ–</h3>
<blockquote>
<p>æ‰§è¡Œ Hugo å‘½ä»¤æ—¶è¿›è¡Œçš„åˆå§‹åŒ–åŠ è½½</p>
</blockquote>
<pre><code class="language-go">// åˆ›å»º hugoCmd å°è£…å—
func (b *commandsBuilder) newHugoCmd() *hugoCmd {
	cc := &#x26;hugoCmd{}

	cc.baseBuilderCmd = b.newBuilderCmd(&#x26;cobra.Command{
		Use:   "hugo",
		Short: "hugo builds your site",
		Long: `hugo is the main command, used to build your Hugo site.

Hugo is a Fast and Flexible Static Site Generator
built with love by spf13 and friends in Go.

Complete documentation is available at http://gohugo.io/.`,

		// æ‰§è¡Œæ¸²æŸ“æ“ä½œ
		RunE: func(cmd *cobra.Command, args []string) error {
			// è®°å½•å…¨å±€æ“ä½œè€—æ—¶
			defer cc.timeTrack(time.Now(), "Total")
			cfgInit := func(c *commandeer) error {
				if cc.buildWatch {
					// å¦‚æœå¼€å¯äº† watch æ¨¡å¼åˆ™å…³é—­åŠ¨æ€é‡è½½
					c.Set("disableLiveReload", true)
				}
				return nil
			}

			// åˆå§‹åŒ–é…ç½®
			c, err := initializeConfig(true, cc.buildWatch, &#x26;cc.hugoBuilderCommon, cc, cfgInit)
			if err != nil {
				return err
			}
			cc.c = c

			// ç¼–è¯‘æ“ä½œ
			return c.build()
		},
	})

    ...
</code></pre>
<h4>2.2.1. é…ç½®æ–‡ä»¶åŠ è½½</h4>
<pre><code class="language-go">// hugolib/config.go

	for _, configDir := range configDirs {
		err := afero.Walk(sourceFs, configDir, func(path string, fi os.FileInfo, err error) error {
			if fi == nil || err != nil {
				return nil
			}

			if fi.IsDir() {
				dirnames = append(dirnames, path)
				return nil
			}

			// æ£€æŸ¥æ–‡ä»¶åç¼€æ˜¯å¦æ˜¯æ”¯æŒçš„æ ¼å¼
			if !config.IsValidConfigFilename(path) {
				return nil
			}

			// æ–‡ä»¶å, ç§»é™¤æ–‡ä»¶åç¼€
			name := helpers.Filename(filepath.Base(path))

			// åŠ è½½æ–‡ä»¶å†…å®¹åˆ° map
			item, err := metadecoders.Default.UnmarshalFileToMap(sourceFs, path)
			if err != nil {
				return l.wrapFileError(err, path)
			}

			var keyPath []string

			// å¦‚æœä¸æ˜¯ hugo çš„ config æ–‡ä»¶
			if name != "config" {
				// Can be params.jp, menus.en etc.
				// å¦‚æœæ–‡ä»¶è¿˜æœ‰åç¼€, å¯èƒ½æ˜¯è¯­è¨€åç¼€
				name, lang := helpers.FileAndExtNoDelimiter(name)

				keyPath = []string{name}

				// å¦‚æœè¯­è¨€åç¼€å­˜åœ¨
				if lang != "" {
					// å¡«å……è¯­è¨€æ–‡ä»¶å¤¹è·¯å¾„
					keyPath = []string{"languages", lang}
					switch name {
					case "menu", "menus":
						keyPath = append(keyPath, "menus")
					case "params":
						keyPath = append(keyPath, "params")
					}
				}
			}

			root := item
			if len(keyPath) > 0 {
				root = make(map[string]interface{})
				m := root

				// éå†å½¢æˆå±‚çº§å…³ç³»

				// éå†è¯­è¨€æ–‡ä»¶å¤¹çš„è·¯å¾„
				// i ä» 0 å¼€å§‹
				for i, key := range keyPath {
					// å¦‚æœ i >= æœ€åä¸€ä¸ªå…ƒç´ çš„ index
					if i >= len(keyPath)-1 {
						// å°†æ–‡ä»¶å†…å®¹å¡«å……åˆ° key ä¸‹é¢
						m[key] = item
					} else {
						nm := make(map[string]interface{})
						m[key] = nm
						m = nm
					}
				}
			}

			// Migrate menu => menus etc.
			config.RenameKeys(root)

			// åˆå¹¶é…ç½®æ–‡ä»¶
			if err := v.MergeConfigMap(root); err != nil {
				return l.wrapFileError(err, path)
			}

			return nil
		})
</code></pre>
<p>éå†é…ç½®æ–‡ä»¶å¤¹ã€ä»¥åŠåŠ è½½é…ç½®æ–‡ä»¶ï¼ˆyaml/toml/json åç¼€ï¼‰åˆ° Map ä¸­ï¼Œä½¿ç”¨ Viper çš„ <code>MergeConfigMap</code> è½½å…¥é…ç½®ï¼ŒåŒ…å«è¯­è¨€ã€èœå•é…ç½®ã€‚</p>
<pre><code class="language-go">// hugolib/hugo_sites.go
// åˆ›å»º sites çš„é…ç½®
func createSitesFromConfig(cfg deps.DepsCfg) ([]*Site, error) {
	var sites []*Site

	// è·å–å¤šè¯­è¨€é…ç½®
	languages := getLanguages(cfg.Cfg)

	for _, lang := range languages {
		if lang.Disabled {
			continue
		}
		var s *Site
		var err error
		cfg.Language = lang
		// ä¸ºæ¯ä¸ªè¯­è¨€åˆ›å»ºä¸€ä¸ª site
		s, err = newSite(cfg)

		if err != nil {
			return nil, err
		}

		sites = append(sites, s)
	}

	return sites, nil
}
</code></pre>
<p>ä¸ºæ¯ä¸ªè¯­è¨€ç”Ÿæˆä¸€ä¸ª Siteã€‚</p>
<h4>2.2.2. å†…å®¹åŠ è½½</h4>
<p>æ³¨å†Œå›è°ƒå‡½æ•°:</p>
<pre><code class="language-go">// hugolib/site.go
// åˆå§‹åŒ–
func (s *Site) prepareInits() {
	s.init = &#x26;siteInit{}

	var init lazy.Init

	// å›è°ƒå‡½æ•°
	s.init.prevNext = init.Branch(func() (interface{}, error) {
		// è·å– pages
		regularPages := s.RegularPages()
		for i, p := range regularPages {
			np, ok := p.(nextPrevProvider)
			if !ok {
				continue
			}

			pos := np.getNextPrev()
			if pos == nil {
				continue
			}

			pos.nextPage = nil
			pos.prevPage = nil

			if i > 0 {
				pos.nextPage = regularPages[i-1]
			}

			if i &#x3C; len(regularPages)-1 {
				pos.prevPage = regularPages[i+1]
			}
		}
		return nil, nil
	})

	s.init.prevNextInSection = init.Branch(func() (interface{}, error) {
		var sections page.Pages
		s.home.treeRef.m.collectSectionsRecursiveIncludingSelf(pageMapQuery{Prefix: s.home.treeRef.key}, func(n *contentNode) {
			sections = append(sections, n.p)
		})

		setNextPrev := func(pas page.Pages) {
			for i, p := range pas {
				np, ok := p.(nextPrevInSectionProvider)
				if !ok {
					continue
				}

				pos := np.getNextPrevInSection()
				if pos == nil {
					continue
				}

				pos.nextPage = nil
				pos.prevPage = nil

				if i > 0 {
					pos.nextPage = pas[i-1]
				}

				if i &#x3C; len(pas)-1 {
					pos.prevPage = pas[i+1]
				}
			}
		}

		for _, sect := range sections {
			treeRef := sect.(treeRefProvider).getTreeRef()

			var pas page.Pages
			treeRef.m.collectPages(pageMapQuery{Prefix: treeRef.key + cmBranchSeparator}, func(c *contentNode) {
				pas = append(pas, c.p)
			})
			page.SortByDefault(pas)

			setNextPrev(pas)
		}

		// The root section only goes one level down.
		treeRef := s.home.getTreeRef()

		var pas page.Pages
		treeRef.m.collectPages(pageMapQuery{Prefix: treeRef.key + cmBranchSeparator}, func(c *contentNode) {
			pas = append(pas, c.p)
		})
		page.SortByDefault(pas)

		setNextPrev(pas)

		return nil, nil
	})

	s.init.menus = init.Branch(func() (interface{}, error) {
		s.assembleMenus()
		return nil, nil
	})

	s.init.taxonomies = init.Branch(func() (interface{}, error) {
		err := s.pageMap.assembleTaxonomies()
		return nil, err
	})
}
</code></pre>
<h2>3. æ€§èƒ½ä¼˜åŒ–ç»†èŠ‚</h2>
<h3>3.1. interface å®ç°çº¦æŸ</h3>
<p>ä»£ç ä¸­æœ‰å¤šå¤„ä½¿ç”¨å¦‚ä¸‹æ–¹å¼åœ¨ç¼–è¯‘æ—¶çº¦æŸ interface è¢«å®ç°ã€‚</p>
<pre><code class="language-go">var _ cmder = (*newCmd)(nil)
</code></pre>
<p>å…¶ä»–å¼€æºé¡¹ç›®ä¸­æœ‰ä¹Ÿæœ‰è¿™ç§å†™æ³•çš„ï¼š</p>
<pre><code class="language-go">var _ cmder = &#x26;newCmd{}
var _ cmder = newCmd{}
</code></pre>
<h3>3.2. é˜²æŠ–</h3>
<pre><code class="language-go">package debounce

import (
	"sync"
	"time"
)

// New returns a debounced function that takes another functions as its argument.
// This function will be called when the debounced function stops being called
// for the given duration.
// The debounced function can be invoked with different functions, if needed,
// the last one will win.
func New(after time.Duration) func(f func()) {
	d := &#x26;debouncer{after: after}

	return func(f func()) {
		d.add(f)
	}
}

type debouncer struct {
	mu    sync.Mutex
	after time.Duration
	timer *time.Timer
}

func (d *debouncer) add(f func()) {
	d.mu.Lock()
	defer d.mu.Unlock()

    // å¦‚æœæ­£åœ¨å»¶æ—¶ä¸­ï¼Œå–æ¶ˆå½“å‰å»¶æ—¶ï¼Œæ·»åŠ æ–°çš„å»¶æ—¶
	if d.timer != nil {
		d.timer.Stop()
	}
	d.timer = time.AfterFunc(d.after, f)
}
</code></pre>
<p>é˜²æŠ–å‡½æ•°çš„ä½¿ç”¨ç±»ä¼¼ React Hooksã€‚</p>
<pre><code class="language-go">f := func()
run := debounce.New(f)
run()
</code></pre>
<p>åœ¨ Istio æºç ä¸­ï¼Œå¤„ç† XDS æ¨æµæ—¶ä¹Ÿä¼šè¿›è¡Œé˜²æŠ–å¤„ç†ã€‚</p>
<h3>3.2. LIFO é˜Ÿåˆ—</h3>
<pre><code class="language-go">// LIFO é˜Ÿåˆ—ï¼Œæº¢å‡ºçš„å…ƒç´ ä¼šä»é¡¶éƒ¨ç§»é™¤
// æ²¡æœ‰ä¸»åŠ¨åˆ é™¤å…ƒç´ çš„æ–¹æ³•
// EvictingStringQueue is a queue which automatically evicts elements from the head of
// the queue when attempting to add new elements onto the queue and it is full.
// This queue orders elements LIFO (last-in-first-out). It throws away duplicates.
// Note: This queue currently does not contain any remove (poll etc.) methods.
type EvictingStringQueue struct {
	size int
	vals []string // å‚¨å­˜çœŸå®çš„æ•°æ®
	set  map[string]bool // è¡¨ç¤ºæ˜¯å¦å·²ç»å­˜åœ¨
	mu   sync.Mutex
}

// NewEvictingStringQueue creates a new queue with the given size.
func NewEvictingStringQueue(size int) *EvictingStringQueue {
	return &#x26;EvictingStringQueue{size: size, set: make(map[string]bool)}
}

// Add adds a new string to the tail of the queue if it's not already there.
func (q *EvictingStringQueue) Add(v string) {
	q.mu.Lock()
	// å·²ç»å­˜åœ¨
	if q.set[v] {
		q.mu.Unlock()
		return
	}

	// æ•°é‡è¾¾åˆ°æœ€å¤§é™åˆ¶
	if len(q.set) == q.size {
		// Full
		// ç§»é™¤äº† 0 å·å…ƒç´ çš„å ä½ç¬¦
		delete(q.set, q.vals[0])
		// :0 å–ç©ºæ•°ç»„ï¼Œ1:å–ä¸åŒ…å«ç¬¬ä¸€ä¸ªå…ƒç´ çš„å…¶ä½™å…ƒç´ 
		// ç§»é™¤äº†æ•°ç»„ 0 å·å…ƒç´ 
		q.vals = append(q.vals[:0], q.vals[1:]...)
	}
	// è¡¨ç¤ºå­˜åœ¨
	q.set[v] = true
	// æœ€æ–°æ’å…¥çš„å€¼åœ¨æ•°ç»„æœ€å
	// æ˜¯é˜Ÿåˆ—ç»“æ„
	q.vals = append(q.vals, v)
	q.mu.Unlock()
}

// Contains returns whether the queue contains v.
func (q *EvictingStringQueue) Contains(v string) bool {
	q.mu.Lock()
	defer q.mu.Unlock()
	return q.set[v]
}

// Peek looks at the last element added to the queue.
func (q *EvictingStringQueue) Peek() string {
	q.mu.Lock()
	l := len(q.vals)
	// å¤„ç†è¾¹ç•Œæ¡ä»¶
	if l == 0 {
		q.mu.Unlock()
		return ""
	}
	// å–æœ€åä¸€ä¸ªå…ƒç´ 
	elem := q.vals[l-1]
	q.mu.Unlock()
	return elem
}

// PeekAll looks at all the elements in the queue, with the newest first.
func (q *EvictingStringQueue) PeekAll() []string {
	q.mu.Lock()
	vals := make([]string, len(q.vals))
	copy(vals, q.vals)
	q.mu.Unlock()
	// i ä»å¤´å¼€å§‹å¾ªç¯ j ä»å°¾å¾ªç¯
	// äº¤æ¢ i j å…ƒç´ ä½ç½®
	// æ•°ç»„ reverse
	// æœ€åæ’å…¥çš„åœ¨æœ€å‰é¢
	for i, j := 0, len(vals)-1; i &#x3C; j; i, j = i+1, j-1 {
		vals[i], vals[j] = vals[j], vals[i]
	}
	return vals
}

// PeekAllSet returns PeekAll as a set.
func (q *EvictingStringQueue) PeekAllSet() map[string]bool {
	all := q.PeekAll()
	set := make(map[string]bool)
	for _, v := range all {
		set[v] = true
	}

	return set
}
</code></pre>
<h3>3.3. åŒæ­¥ä¿¡å·é‡</h3>
<p><code>golang.org/x/sync/semaphore</code> æ‰©å±•åŒæ­¥åŸè¯­ã€‚</p>
<h3>3.4. Command</h3>
<h4>3.4.1. CLI è‡ªåŠ¨è¡¥å…¨</h4>
<p><img src="/images/2020-12-01-01.png" alt=""></p>
<p>Hugo çš„ä½¿ç”¨æ–¹å¼æœ‰ä¸¤ç§ï¼š</p>
<pre><code class="language-go">// "-config" flag è‡ªåŠ¨è¡¥å…¨æŒ‡å®šåç¼€æ–‡ä»¶å
_ = cc.cmd.PersistentFlags().SetAnnotation("config", cobra.BashCompFilenameExt, config.ValidConfigFileExtensions)

// "-source" flag è‡ªåŠ¨è¡¥å…¨å­æ–‡ä»¶å¤¹å
cmd.PersistentFlags().SetAnnotation("source", cobra.BashCompSubdirsInDir, []string{})
</code></pre>
<h3>3.5. å¹¶å‘æ§åˆ¶</h3>
<h4>3.5.1. ç¼“å†²é€šé“æ§åˆ¶å¹¶å‘</h4>
<pre><code class="language-go">// common/para/para.go
// Package para implements parallel execution helpers.
package para

import (
	"context"

	"golang.org/x/sync/errgroup"
)

// Workers configures a task executor with the most number of tasks to be executed in parallel.
type Workers struct {
	sem chan struct{}
}

// Runner wraps the lifecycle methods of a new task set.
//
// Run wil block until a worker is available or the context is cancelled,
// and then run the given func in a new goroutine.
// Wait will wait for all the running goroutines to finish.
type Runner interface {
	Run(func() error)
	Wait() error
}

type errGroupRunner struct {
	*errgroup.Group
	w   *Workers
	ctx context.Context
}

func (g *errGroupRunner) Run(fn func() error) {
	select {
	// åˆ†é…ä¸€ä¸ªä¿¡å·, å¦‚æœ chan è¢«å…³é—­åˆ™é€€å‡º
	case g.w.sem &#x3C;- struct{}{}:
	case &#x3C;-g.ctx.Done():
		return
	}

	g.Go(func() error {
		err := fn()
		// æ‰§è¡Œå®Œåæ¶ˆè´¹ä¿¡å·é‡, é€šè¿‡ç¼“å­˜é€šé“ä¿è¯å¹¶å‘æ‰§è¡Œçš„åç¨‹æ•°é‡
		&#x3C;-g.w.sem
		return err
	})
}

// New creates a new Workers with the given number of workers.
func New(numWorkers int) *Workers {
	return &#x26;Workers{
		// ç¼“å†²é€šé“, å¹¶å‘å†™å…¥
		sem: make(chan struct{}, numWorkers),
	}
}

// Start starts a new Runner.
func (w *Workers) Start(ctx context.Context) (Runner, context.Context) {
	g, ctx := errgroup.WithContext(ctx)
	return &#x26;errGroupRunner{
		Group: g,
		ctx:   ctx,
		w:     w,
	}, ctx
}

</code></pre>
<p>Playground æµ‹è¯•ç¤ºä¾‹: <a href="https://play.golang.org/p/4AJtyVnlSOd">https://play.golang.org/p/4AJtyVnlSOd</a></p>
<pre><code class="language-go">func main() {
	w := para.New(10)
	runner, _ := w.Start(context.TODO())
	runner.Run(func() error {
		fmt.Println("fucking")
		return nil
	})
	time.Sleep(2 * time.Second)
}
</code></pre>
<h3>3.6. æ‡’åŠ è½½</h3>
<blockquote>
<p>Lazy åŒ…</p>
</blockquote>
<h4>3.6.1. onceMore</h4>
<pre><code class="language-go">package lazy

import (
	"sync"
	"sync/atomic"
)

// onceMore is similar to sync.Once.
//
// Additional features are:
// * it can be reset, so the action can be repeated if needed
// * it has methods to check if it's done or in progress
//
type onceMore struct {
	mu   sync.Mutex
	lock uint32
	done uint32
}

func (t *onceMore) Do(f func()) {
	if atomic.LoadUint32(&#x26;t.done) == 1 {
		return
	}

	// f may call this Do and we would get a deadlock.
	locked := atomic.CompareAndSwapUint32(&#x26;t.lock, 0, 1)
	if !locked {
		// æ²¡æœ‰æŠ¢åˆ°åŸå­æ“ä½œ
		return
	}
	// é‡Šæ”¾åŸå­é”
	// defer æ˜¯ FILO, è¯¥åŸå­é”ä¼šæœ€åæ‰é‡Šæ”¾
	defer atomic.StoreUint32(&#x26;t.lock, 0)

	// å¹¶å‘é”, ä¿è¯ t.done å€¼çš„è¯»å–ä¸ä¼šäº§ç”Ÿç«äº‰
	t.mu.Lock()
	defer t.mu.Unlock()

	// Double check
	if t.done == 1 {
		return
	}
	defer atomic.StoreUint32(&#x26;t.done, 1)
	f()
}

func (t *onceMore) InProgress() bool {
	return atomic.LoadUint32(&#x26;t.lock) == 1
}

func (t *onceMore) Done() bool {
	return atomic.LoadUint32(&#x26;t.done) == 1
}

func (t *onceMore) ResetWithLock() *sync.Mutex {
	t.mu.Lock()
	defer atomic.StoreUint32(&#x26;t.done, 0)
	return &#x26;t.mu
}

</code></pre>
<h4>3.6.2. init</h4>
<pre><code class="language-go">package lazy

import (
	"context"
	"sync"
	"time"

	"github.com/pkg/errors"
)

// New creates a new empty Init.
func New() *Init {
	return &#x26;Init{}
}

// Init holds a graph of lazily initialized dependencies.
type Init struct {
	mu sync.Mutex // å¹¶å‘ä¿®æ”¹å›¾çš„é”

	prev     *Init
	children []*Init

	init onceMore // ä¿è¯åªæ‰§è¡Œä¸€æ¬¡çš„é”
	out  interface{} // æ‰§è¡Œç»“æœ
	err  error // æ‰§è¡Œé”™è¯¯
	f    func() (interface{}, error) // å›è°ƒå‡½æ•°
}

// Add adds a func as a new child dependency.
func (ini *Init) Add(initFn func() (interface{}, error)) *Init {
	if ini == nil {
		ini = New()
	}
	return ini.add(false, initFn)
}

// AddWithTimeout is same as Add, but with a timeout that aborts initialization.
func (ini *Init) AddWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init {
	return ini.Add(func() (interface{}, error) {
		return ini.withTimeout(timeout, f)
	})
}

// Branch creates a new dependency branch based on an existing and adds
// the given dependency as a child.
func (ini *Init) Branch(initFn func() (interface{}, error)) *Init {
	if ini == nil {
		ini = New()
	}
	return ini.add(true, initFn)
}

// BranchdWithTimeout is same as Branch, but with a timeout.
func (ini *Init) BranchWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init {
	return ini.Branch(func() (interface{}, error) {
		return ini.withTimeout(timeout, f)
	})
}

// Do initializes the entire dependency graph.
func (ini *Init) Do() (interface{}, error) {
	if ini == nil {
		panic("init is nil")
	}

	// è°ƒç”¨ onceMore åº“ä¿è¯åªæ‰§è¡Œä¸€æ¬¡
	ini.init.Do(func() {
		// è·å–çˆ¶èŠ‚ç‚¹
		prev := ini.prev
		if prev != nil {
			// A branch. Initialize the ancestors.
			// è‹¥çˆ¶èŠ‚ç‚¹è¿˜æ²¡æœ‰å®Œæˆåˆå§‹åŒ–, å¹¶ä¸”æ²¡æœ‰æ­£åœ¨æ‰§è¡Œçš„å›è°ƒå‡½æ•°, æ‰§è¡Œ
			if prev.shouldInitialize() {
				_, err := prev.Do()
				if err != nil {
					ini.err = err
					return
				}
			} else if prev.inProgress() {
				// Concurrent initialization. The following init func
				// may depend on earlier state, so wait.
				// ç­‰å¾…ä¸€å®šæ—¶é—´, è‹¥æ²¡æœ‰æ‰§è¡Œå®Œ, panic
				prev.wait()
			}
		}

		// æ‰§è¡Œå›è°ƒå‡½æ•°
		if ini.f != nil {
			ini.out, ini.err = ini.f()
		}

		// å¾ªç¯æ‰§è¡Œå­èŠ‚ç‚¹çš„å›è°ƒå‡½æ•°
		// ä¸ºä»€ä¹ˆä¸å¹¶å‘æ‰§è¡Œ ?
		for _, child := range ini.children {
			if child.shouldInitialize() {
				_, err := child.Do()
				if err != nil {
					ini.err = err
					return
				}
			}
		}
	})

	ini.wait()

	return ini.out, ini.err
}

// TODO(bep) investigate if we can use sync.Cond for this.
func (ini *Init) wait() {
	var counter time.Duration
	for !ini.init.Done() {
		counter += 10
		if counter > 600000000 {
			panic("BUG: timed out in lazy init")
		}
		time.Sleep(counter * time.Microsecond)
	}
}

func (ini *Init) inProgress() bool {
	return ini != nil &#x26;&#x26; ini.init.InProgress()
}

// è‹¥ æ²¡æœ‰æ³¨å†Œäº†å›è°ƒå‡½æ•° | å·²ç»å®Œæˆ | æ­£åœ¨æ‰§è¡Œ, ä¸è¿›è¡Œåˆå§‹åŒ–
func (ini *Init) shouldInitialize() bool {
	return !(ini == nil || ini.init.Done() || ini.init.InProgress())
}

// Reset resets the current and all its dependencies.
func (ini *Init) Reset() {
	mu := ini.init.ResetWithLock()
	defer mu.Unlock()
	for _, d := range ini.children {
		d.Reset()
	}
}

// æ·»åŠ å›¾çš„èŠ‚ç‚¹
func (ini *Init) add(branch bool, initFn func() (interface{}, error)) *Init {
	ini.mu.Lock()
	defer ini.mu.Unlock()

	// å¦‚æœæ˜¯æ–°å»ºåˆ†æ”¯
	if branch {
		return &#x26;Init{
			f:    initFn,
			prev: ini, // çˆ¶èŠ‚ç‚¹
		}
	}

	// å¦‚æœæ˜¯æ·»åŠ å­èŠ‚ç‚¹
	// å¦‚æœå·²ç»è¢«æ‰§è¡Œ, panic
	ini.checkDone()
	// æ·»åŠ å­èŠ‚ç‚¹
	ini.children = append(ini.children, &#x26;Init{
		f: initFn,
	})

	// é‡Šæ”¾é”
	return ini
}

func (ini *Init) checkDone() {
	if ini.init.Done() {
		panic("init cannot be added to after it has run")
	}
}

// callback å‡½æ•°, æœ‰è¶…æ—¶æ—¶é—´
func (ini *Init) withTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) (interface{}, error) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	// ç¼“å­˜é€šé“, é˜²æ­¢é˜»å¡
	c := make(chan verr, 1)

	go func() {
		v, err := f(ctx)
		select {
		case &#x3C;-ctx.Done():
			return
		default:
			c &#x3C;- verr{v: v, err: err}
		}
	}()

	select {
	case &#x3C;-ctx.Done():
		return nil, errors.New("timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file.")
	case ve := &#x3C;-c:
		return ve.v, ve.err
	}
}

type verr struct {
	v   interface{}
	err error
}

</code></pre>
<section data-footnotes class="footnotes"><h2 class="sr-only" id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-1">
<p><a href="https://imroc.io/posts/kubernetes/analysis-exitcode/">Kubernetes é—®é¢˜å®šä½æŠ€å·§ï¼šåˆ†æ ExitCode - imroc.io|rocçš„åšå®¢|Cloud Native|Kubernetes|Go|Golang</a> <a href="#user-content-fnref-1" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">â†©</a></p>
</li>
</ol>
</section></article><script src="/_next/static/chunks/webpack-072f062dc024cc52.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5803,[],\"\"]\n3:I[695,[],\"\"]\n5:I[2576,[],\"OutletBoundary\"]\n7:I[2576,[],\"MetadataBoundary\"]\n9:I[2576,[],\"ViewportBoundary\"]\nb:I[7614,[],\"\"]\n:HL[\"/_next/static/css/c3b55921f92a131e.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"n66w3jQXdD0TOkFlxRfSe\",\"p\":\"\",\"c\":[\"\",\"2020\",\"12\",\"hugo-source-code-reading\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(posts)\",{\"children\":[[\"year\",\"2020\",\"d\"],{\"children\":[[\"month\",\"12\",\"d\"],{\"children\":[[\"slug\",\"hugo-source-code-reading\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/c3b55921f92a131e.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"(posts)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:style\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:1:props:style\",\"children\":404}],[\"$\",\"div\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:2:props:style\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:1:props:children:props:children:2:props:children:props:style\",\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"year\",\"2020\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"month\",\"12\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"hugo-source-code-reading\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(posts)\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:0\",\"children\",\"$0:f:0:1:2:children:2:children:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"75xEPbe_eIvxZtHlxQnX8\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],null]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Mayo Rocks!\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Mayo's Blog\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/icon.png?14d5a92fbe70e82a\",\"type\":\"image/png\",\"sizes\":\"460x460\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script><script>self.__next_f.push([1,"c:T6348,"])</script><script>self.__next_f.push([1,"\u003cp\u003eè¿™ç¯‡æºç é˜…è¯»ç¼–å†™äº 2020 å¹´ 12 æœˆï¼ŒåŸæœ¬å‡ºäºè‡ªå·±æƒ³å®ç°ä¸€ä¸ª Go è¯­è¨€çš„é™æ€åšå®¢ç”Ÿæˆå™¨ï¼Œå¼€å§‹é˜…è¯» Hugo çš„æºç ï¼Œäº†è§£ä¸€äº›å®ç°çš„ç»†èŠ‚ä¸éœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼Œé€”ä¸­å‘ç°ä»£ç é‡å·¨å¤§ï¼Œè€Œä¸”å†…éƒ¨å®ç°é€»è¾‘è¾ƒä¸ºå¤æ‚ï¼Œåœ¨è¿™é‡Œä¹Ÿåªå¯¹éƒ¨åˆ†é€»è¾‘è¿›è¡Œäº†æ¢³ç†ï¼ˆåªæ˜¯å†°å±±ä¸€è§’ï¼‰ã€‚\u003c/p\u003e\n\u003ch2\u003e1. æ¦‚è¿°\u003c/h2\u003e\n\u003cp\u003eæˆ‘é˜…è¯»å¹¶ä½œå‡ºä¸­æ–‡æ³¨é‡Šçš„ Commits å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ï¼š\n\u003ca href=\"https://github.com/mayocream/hugo/commits?author=mayocream\"\u003ehttps://github.com/mayocream/hugo/commits?author=mayocream\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eé˜…è¯»æºç çš„è¿‡ç¨‹ä¸­ä¹Ÿå½“ typofix æœºå™¨äººæäº† \u003ca href=\"https://github.com/gohugoio/hugo/pull/8034\"\u003ePR\u003c/a\u003eï¼Œæ¯•ç«Ÿè‡ªå·±ç¡®å®æ²¡æœ‰èƒ½è´¡çŒ®çš„åœ°æ–¹ã€‚ä¸è¿‡é˜…è¯»æºç å¹¶æ³¨é‡Šå¸®åŠ©ç†è§£ï¼Œæ–¹ä¾¿æ•´ç†ä¹Ÿæ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ï¼Œåœ¨å·¥ä½œä¸­æˆ‘é€æ¸å­¦ä¼šäº†ã€‚\u003c/p\u003e\n\u003cp\u003eæ ¹æ® \u003ca href=\"https://en.wikipedia.org/wiki/Hugo_(software)\"\u003eWikipedia\u003c/a\u003e çš„è®°è½½ï¼ŒHugo æ—©åœ¨ 2013 å¹´å°±å‘å¸ƒäº†ï¼Œç›´åˆ°å»å¹´æˆ‘ä¸€ç›´æ²¡æœ‰ä½¿ç”¨è¿‡ï¼Œå¯èƒ½æ˜¯å®ƒæ²¡æœ‰å®˜æ–¹çš„ä¸­æ–‡æ–‡æ¡£ï¼ŒGo è¯­è¨€å¯¹å½“æ—¶æˆ‘ä¹Ÿå¤ªç”Ÿç–ï¼Œè€Œä¸” Hugo çš„æ¨¡æ¿è¯­æ³•å’Œ Hexo ä¸ Jekyll ä¹Ÿä¸ä¸€æ ·ï¼Œè€Œä¸”å®˜æ–¹æ¨èç”¨ Theme çš„æ–¹å¼æ˜¯ Git Submoduleï¼Œç›¸æ¯”äº Hexo ä¸Šæ‰‹éš¾åº¦è¿˜æ˜¯é«˜ä¸€äº›ã€‚\u003c/p\u003e\n\u003cp\u003eç°åœ¨ä½œä¸ºä½¿ç”¨è€…æ¥è¯´ï¼ŒHugo ä½¿ç”¨çš„ Go æ¨¡æ¿è¯­æ³•å¾ˆå¥½ç”¨ï¼ŒHugo åŸºäºæ¨¡æ¿çš„ Pipeline å®ç°çš„æ•°æ®é¢„å¤„ç†ä¹Ÿéå¸¸æ–¹ä¾¿ï¼Œç”¨äº†å°±åœä¸ä¸‹æ¥äº†ã€‚è€Œä¸”åŸºäº \u003ca href=\"https://github.com/evanw/esbuild\"\u003eesbuild\u003c/a\u003e çš„æ‰“åŒ…ä½¿å¾—é™æ€èµ„æºçš„æ„å»ºä¹Ÿå¾ˆæ–¹ä¾¿ï¼Œç»ˆäºè„±ç¦» Webpack äº†ã€‚æˆ‘è¿˜æœ‰ä¸€ä¸ªå¼ƒå‘çš„é¡¹ç›® \u003ca href=\"https://github.com/mayocream/material-design-blog\"\u003ematerial-design-blog\u003c/a\u003e ä¹Ÿæ˜¯ä½¿ç”¨çš„ Snowpack (esbuild) è¿›è¡Œé™æ€èµ„æºçš„æ‰“åŒ…ï¼Œä¸çŸ¥é“éƒ½å·²ç»æ˜¯ 2021 å¹´æœ«äº†ï¼Œä¸ºä»€ä¹ˆå…¬å¸çš„é‚£ç¾¤äººè¿˜è¦ä½¿ç”¨ Webpack ç¼“æ…¢åœ°æ„å»ºå‘¢ã€‚\u003c/p\u003e\n\u003cp\u003eHugo ç°åœ¨åŸºæœ¬ä¸Š Github ä¸Šå¼€æºé¡¹ç›®æ–‡æ¡£å‘å¸ƒçš„æ ‡é…ï¼Œä¸è¿‡ Cloudflare çš„å¼€å‘è€…æ–‡æ¡£æ˜¯ä½¿ç”¨ \u003ca href=\"https://www.gatsbyjs.com/\"\u003eGatsby\u003c/a\u003e å‘å¸ƒçš„ï¼Œå¯èƒ½ Cloudflare å†…éƒ¨ JavaScript ç”¨å¾—ä¹Ÿå¤šå§ï¼ŒWorker å¯¹äº Go å°±\u003ca href=\"https://community.cloudflare.com/t/native-golang-support-for-workers/65896\"\u003eæ²¡æœ‰åŸç”Ÿæ”¯æŒ\u003c/a\u003eã€‚\u003c/p\u003e\n\u003cp\u003eåœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­æˆ‘è¿˜æ˜¯å°½é‡å…‹åˆ¶è‡ªå·±ä½¿ç”¨ Hugo \u003ca href=\"https://gohugo.io/content-management/shortcodes/\"\u003eShortcodes\u003c/a\u003eï¼Œä¸€ä¸ª Markdown æ–‡æ¡£åº”è¯¥ä¿æŒçº¯å‡€ï¼Œé™¤äº† Markdown æ‰©å±•è¯­æ³•ä»¥å¤–éƒ½ä¸è¦ä½¿ç”¨ï¼Œéœ€è¦ç‰¹æ®Šå®ç°çš„ä¹Ÿä½¿ç”¨åŸç”Ÿ HTML æ ‡ç­¾ï¼Œè¿™æ ·æ–¹ä¾¿å°†å†™ä½œå’Œ Blog å‘å¸ƒåˆ†ç¦»ã€‚\u003c/p\u003e\n\u003cp\u003eæˆ‘è‡ªå·±ç”¨åœ¨ \u003ca href=\"https://github.com/mayocream/Translations\"\u003eTranslations\u003c/a\u003e é¡¹ç›®ä¸­çš„ Hugo çš„ Shortcode æ˜¯ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;figure class=\"manga\"\u003e\n    \u0026#x3C;img src=\"https://cdn.jsdelivr.net/gh/mayocream/Translations@gh-pages/raw/{{ .Get \"src\" }}\" alt=\"\" loading=\"lazy\"\u003e\n    \u0026#x3C;figcaption\u003e{{ .Get \"alt\" }}\u0026#x3C;/figcaption\u003e\n\u0026#x3C;/figure\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eä¸ºäº†åˆ©ç”¨ä¸Š Figure æ ‡ç­¾ä¸ jsDelivr çš„ CDNï¼Œä½¿ç”¨äº† Shortcodeï¼Œä¸è¿‡è¯¥é¡¹ç›®ä¸­é‡‡ç”¨ Hugo æ˜¯ä¸“é—¨ä¸ºäº†è¿›è¡Œå‘å¸ƒç®¡ç†çš„ï¼Œå…³äºè¿™ä¸ªå¦‚æœæˆ‘è¿˜æœ‰æ—¶é—´åšæ›´å¤šç¿»è¯‘çš„è¯ï¼Œå¯èƒ½ä¼šå†™ä¸€ç¯‡æ–‡ç« æ¥ä»‹ç»ç¿»è¯‘å°å·¥ç¨‹çš„å·¥ä½œæµ ğŸ¤¹ã€‚\u003c/p\u003e\n\u003ch3\u003e1.1. ç›®å½•ç»“æ„\u003c/h3\u003e\n\u003cp\u003eHugo çš„å¼€å‘æ—¶é—´è¾ƒæ—©ï¼Œæ‰€ä»¥ç›®å½•ç»“æ„è¾ƒä¸ºåˆ†æ•£ï¼Œä¸ \u003ca href=\"https://github.com/golang-standards/project-layout\"\u003eStandard Go Project Layout\u003c/a\u003e å·®å¼‚è¾ƒå¤§ï¼Œå½“ç„¶è¿™ä¸ªç¤¾åŒºæå‡ºçš„ç›®å½•è§„èŒƒå»ºè®®ï¼Œä¹Ÿå­˜åœ¨ç€äº‰è®®ï¼Œä¸è¿‡ Google çš„ä¸å°‘é¡¹ç›®éƒ½æ˜¯éµå¾ªè¿™ä¸ªè§„èŒƒçš„ï¼Œä¾‹å¦‚ \u003ca href=\"https://github.com/kubernetes/kubernetes\"\u003eKubernetes\u003c/a\u003e å’Œ \u003ca href=\"https://github.com/grpc/grpc-go\"\u003egrpc-go\u003c/a\u003eã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ tree -L 1 -d\n.\nâ”œâ”€â”€ commands   // CLI å…¥å£, è§£æ flags\nâ”œâ”€â”€ common     // å·¥å…·ç±»\nâ”œâ”€â”€ hugofs     // FS å°è£…, åŸºäº afero/fs\nâ”œâ”€â”€ hugolib    // ç¨‹åºä¸»é€»è¾‘\nâ”œâ”€â”€ lazy       // æ‡’åŠ è½½å·¥å…·åŒ…\nâ”œâ”€â”€ livereload // Live é¢„è§ˆ, åŸºäº Service Worker\nâ”œâ”€â”€ markup     // Markdown è§£æç›¸å…³\nâ”œâ”€â”€ parser     // è§£ææ–‡ä»¶å¤´\n...\n\n40 directories\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. ç¨‹åºæµç¨‹\u003c/h2\u003e\n\u003ch3\u003e2.1. æµç¨‹å®šä¹‰\u003c/h3\u003e\n\u003ch4\u003e2.1.1. é”™è¯¯çŠ¶æ€ç \u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main() {\n\tresp := commands.Execute(os.Args[1:])\n\n\tif resp.Err != nil {\n\t\tif resp.IsUserError() {\n\t\t\tresp.Cmd.Println(\"\")\n\t\t\tresp.Cmd.Println(resp.Cmd.UsageString())\n\t\t}\n\t\tos.Exit(-1)\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eos.Exit(-1)\u003c/code\u003e ç¨‹åºçš„é€€å‡ºçŠ¶æ€ç ä¸åœ¨ 0~255 ä¹‹é—´ï¼Œä¼šè‡ªåŠ¨åšè½¬æ¢ï¼Œè½¬æ¢çš„è§„åˆ™å¦‚ä¸‹\u003csup\u003e\u003ca href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e1\u003c/a\u003e\u003c/sup\u003eï¼š\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eå½“æŒ‡å®šçš„é€€å‡ºæ—¶çŠ¶æ€ç ä¸ºè´Ÿæ•°:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-fallback\"\u003e256 - (|code| % 256)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eå½“æŒ‡å®šçš„é€€å‡ºæ—¶çŠ¶æ€ç ä¸ºæ­£æ•°:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-fallback\"\u003ecode % 256\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eç”±æ­¤ç¨‹åºé€€å‡ºçš„çŠ¶æ€ç ä¸º 255ã€‚\u003c/p\u003e\n\u003ch4\u003e2.1.2. CLI å‘½ä»¤\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// commands/commands.go\nfunc (b *commandsBuilder) addAll() *commandsBuilder {\n   b.addCommands(\n      b.newServerCmd(),\n      newVersionCmd(),\n      newEnvCmd(),\n      b.newConfigCmd(),\n      newCheckCmd(),\n      b.newDeployCmd(),\n      b.newConvertCmd(),\n      b.newNewCmd(),\n      b.newListCmd(),\n      newImportCmd(),\n      newGenCmd(),\n      createReleaser(),\n      b.newModCmd(),\n   )\n\n   return b\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ‰€æœ‰çš„ cmd handler ç»§æ‰¿è‡ª basecmdï¼Œå®ç°äº† cmder æ¥å£ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// commands/helpers.go\ntype cmder interface {\n\tflagsToConfig(cfg config.Provider)\n\tgetCommand() *cobra.Command\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/images/2020-12-01-02.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// commands/commands.go\nfunc (b *commandsBuilder) addAll() *commandsBuilder {\n\tb.addCommands(\n\t\tb.newServerCmd(),\n\t\tnewVersionCmd(),\n\t\tnewEnvCmd(),\n\t\tb.newConfigCmd(),\n\t\tnewCheckCmd(),\n\t\tb.newDeployCmd(),\n\t\tb.newConvertCmd(),\n\t\tb.newNewCmd(),\n\t\tb.newListCmd(),\n\t\tnewImportCmd(),\n\t\tnewGenCmd(),\n\t\tcreateReleaser(),\n\t\tb.newModCmd(),\n\t)\n\n\treturn b\n}\n\nfunc (b *commandsBuilder) build() *hugoCmd {\n\t// æ·»åŠ ä¸» hugo å‘½ä»¤\n\th := b.newHugoCmd()\n\t// å°†å‘½ä»¤æ•°ç»„æ·»åŠ è¿› cobra çš„ Root Command ä¸­, ä½œä¸ºå­å‘½ä»¤\n\taddCommands(h.getCommand(), b.commands...)\n\treturn h\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2.2. æ¸²æŸ“åˆå§‹åŒ–\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eæ‰§è¡Œ Hugo å‘½ä»¤æ—¶è¿›è¡Œçš„åˆå§‹åŒ–åŠ è½½\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// åˆ›å»º hugoCmd å°è£…å—\nfunc (b *commandsBuilder) newHugoCmd() *hugoCmd {\n\tcc := \u0026#x26;hugoCmd{}\n\n\tcc.baseBuilderCmd = b.newBuilderCmd(\u0026#x26;cobra.Command{\n\t\tUse:   \"hugo\",\n\t\tShort: \"hugo builds your site\",\n\t\tLong: `hugo is the main command, used to build your Hugo site.\n\nHugo is a Fast and Flexible Static Site Generator\nbuilt with love by spf13 and friends in Go.\n\nComplete documentation is available at http://gohugo.io/.`,\n\n\t\t// æ‰§è¡Œæ¸²æŸ“æ“ä½œ\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t// è®°å½•å…¨å±€æ“ä½œè€—æ—¶\n\t\t\tdefer cc.timeTrack(time.Now(), \"Total\")\n\t\t\tcfgInit := func(c *commandeer) error {\n\t\t\t\tif cc.buildWatch {\n\t\t\t\t\t// å¦‚æœå¼€å¯äº† watch æ¨¡å¼åˆ™å…³é—­åŠ¨æ€é‡è½½\n\t\t\t\t\tc.Set(\"disableLiveReload\", true)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// åˆå§‹åŒ–é…ç½®\n\t\t\tc, err := initializeConfig(true, cc.buildWatch, \u0026#x26;cc.hugoBuilderCommon, cc, cfgInit)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcc.c = c\n\n\t\t\t// ç¼–è¯‘æ“ä½œ\n\t\t\treturn c.build()\n\t\t},\n\t})\n\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.2.1. é…ç½®æ–‡ä»¶åŠ è½½\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// hugolib/config.go\n\n\tfor _, configDir := range configDirs {\n\t\terr := afero.Walk(sourceFs, configDir, func(path string, fi os.FileInfo, err error) error {\n\t\t\tif fi == nil || err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif fi.IsDir() {\n\t\t\t\tdirnames = append(dirnames, path)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// æ£€æŸ¥æ–‡ä»¶åç¼€æ˜¯å¦æ˜¯æ”¯æŒçš„æ ¼å¼\n\t\t\tif !config.IsValidConfigFilename(path) {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// æ–‡ä»¶å, ç§»é™¤æ–‡ä»¶åç¼€\n\t\t\tname := helpers.Filename(filepath.Base(path))\n\n\t\t\t// åŠ è½½æ–‡ä»¶å†…å®¹åˆ° map\n\t\t\titem, err := metadecoders.Default.UnmarshalFileToMap(sourceFs, path)\n\t\t\tif err != nil {\n\t\t\t\treturn l.wrapFileError(err, path)\n\t\t\t}\n\n\t\t\tvar keyPath []string\n\n\t\t\t// å¦‚æœä¸æ˜¯ hugo çš„ config æ–‡ä»¶\n\t\t\tif name != \"config\" {\n\t\t\t\t// Can be params.jp, menus.en etc.\n\t\t\t\t// å¦‚æœæ–‡ä»¶è¿˜æœ‰åç¼€, å¯èƒ½æ˜¯è¯­è¨€åç¼€\n\t\t\t\tname, lang := helpers.FileAndExtNoDelimiter(name)\n\n\t\t\t\tkeyPath = []string{name}\n\n\t\t\t\t// å¦‚æœè¯­è¨€åç¼€å­˜åœ¨\n\t\t\t\tif lang != \"\" {\n\t\t\t\t\t// å¡«å……è¯­è¨€æ–‡ä»¶å¤¹è·¯å¾„\n\t\t\t\t\tkeyPath = []string{\"languages\", lang}\n\t\t\t\t\tswitch name {\n\t\t\t\t\tcase \"menu\", \"menus\":\n\t\t\t\t\t\tkeyPath = append(keyPath, \"menus\")\n\t\t\t\t\tcase \"params\":\n\t\t\t\t\t\tkeyPath = append(keyPath, \"params\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\troot := item\n\t\t\tif len(keyPath) \u003e 0 {\n\t\t\t\troot = make(map[string]interface{})\n\t\t\t\tm := root\n\n\t\t\t\t// éå†å½¢æˆå±‚çº§å…³ç³»\n\n\t\t\t\t// éå†è¯­è¨€æ–‡ä»¶å¤¹çš„è·¯å¾„\n\t\t\t\t// i ä» 0 å¼€å§‹\n\t\t\t\tfor i, key := range keyPath {\n\t\t\t\t\t// å¦‚æœ i \u003e= æœ€åä¸€ä¸ªå…ƒç´ çš„ index\n\t\t\t\t\tif i \u003e= len(keyPath)-1 {\n\t\t\t\t\t\t// å°†æ–‡ä»¶å†…å®¹å¡«å……åˆ° key ä¸‹é¢\n\t\t\t\t\t\tm[key] = item\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnm := make(map[string]interface{})\n\t\t\t\t\t\tm[key] = nm\n\t\t\t\t\t\tm = nm\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Migrate menu =\u003e menus etc.\n\t\t\tconfig.RenameKeys(root)\n\n\t\t\t// åˆå¹¶é…ç½®æ–‡ä»¶\n\t\t\tif err := v.MergeConfigMap(root); err != nil {\n\t\t\t\treturn l.wrapFileError(err, path)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eéå†é…ç½®æ–‡ä»¶å¤¹ã€ä»¥åŠåŠ è½½é…ç½®æ–‡ä»¶ï¼ˆyaml/toml/json åç¼€ï¼‰åˆ° Map ä¸­ï¼Œä½¿ç”¨ Viper çš„ \u003ccode\u003eMergeConfigMap\u003c/code\u003e è½½å…¥é…ç½®ï¼ŒåŒ…å«è¯­è¨€ã€èœå•é…ç½®ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// hugolib/hugo_sites.go\n// åˆ›å»º sites çš„é…ç½®\nfunc createSitesFromConfig(cfg deps.DepsCfg) ([]*Site, error) {\n\tvar sites []*Site\n\n\t// è·å–å¤šè¯­è¨€é…ç½®\n\tlanguages := getLanguages(cfg.Cfg)\n\n\tfor _, lang := range languages {\n\t\tif lang.Disabled {\n\t\t\tcontinue\n\t\t}\n\t\tvar s *Site\n\t\tvar err error\n\t\tcfg.Language = lang\n\t\t// ä¸ºæ¯ä¸ªè¯­è¨€åˆ›å»ºä¸€ä¸ª site\n\t\ts, err = newSite(cfg)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsites = append(sites, s)\n\t}\n\n\treturn sites, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eä¸ºæ¯ä¸ªè¯­è¨€ç”Ÿæˆä¸€ä¸ª Siteã€‚\u003c/p\u003e\n\u003ch4\u003e2.2.2. å†…å®¹åŠ è½½\u003c/h4\u003e\n\u003cp\u003eæ³¨å†Œå›è°ƒå‡½æ•°:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// hugolib/site.go\n// åˆå§‹åŒ–\nfunc (s *Site) prepareInits() {\n\ts.init = \u0026#x26;siteInit{}\n\n\tvar init lazy.Init\n\n\t// å›è°ƒå‡½æ•°\n\ts.init.prevNext = init.Branch(func() (interface{}, error) {\n\t\t// è·å– pages\n\t\tregularPages := s.RegularPages()\n\t\tfor i, p := range regularPages {\n\t\t\tnp, ok := p.(nextPrevProvider)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpos := np.getNextPrev()\n\t\t\tif pos == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpos.nextPage = nil\n\t\t\tpos.prevPage = nil\n\n\t\t\tif i \u003e 0 {\n\t\t\t\tpos.nextPage = regularPages[i-1]\n\t\t\t}\n\n\t\t\tif i \u0026#x3C; len(regularPages)-1 {\n\t\t\t\tpos.prevPage = regularPages[i+1]\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t})\n\n\ts.init.prevNextInSection = init.Branch(func() (interface{}, error) {\n\t\tvar sections page.Pages\n\t\ts.home.treeRef.m.collectSectionsRecursiveIncludingSelf(pageMapQuery{Prefix: s.home.treeRef.key}, func(n *contentNode) {\n\t\t\tsections = append(sections, n.p)\n\t\t})\n\n\t\tsetNextPrev := func(pas page.Pages) {\n\t\t\tfor i, p := range pas {\n\t\t\t\tnp, ok := p.(nextPrevInSectionProvider)\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tpos := np.getNextPrevInSection()\n\t\t\t\tif pos == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tpos.nextPage = nil\n\t\t\t\tpos.prevPage = nil\n\n\t\t\t\tif i \u003e 0 {\n\t\t\t\t\tpos.nextPage = pas[i-1]\n\t\t\t\t}\n\n\t\t\t\tif i \u0026#x3C; len(pas)-1 {\n\t\t\t\t\tpos.prevPage = pas[i+1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor _, sect := range sections {\n\t\t\ttreeRef := sect.(treeRefProvider).getTreeRef()\n\n\t\t\tvar pas page.Pages\n\t\t\ttreeRef.m.collectPages(pageMapQuery{Prefix: treeRef.key + cmBranchSeparator}, func(c *contentNode) {\n\t\t\t\tpas = append(pas, c.p)\n\t\t\t})\n\t\t\tpage.SortByDefault(pas)\n\n\t\t\tsetNextPrev(pas)\n\t\t}\n\n\t\t// The root section only goes one level down.\n\t\ttreeRef := s.home.getTreeRef()\n\n\t\tvar pas page.Pages\n\t\ttreeRef.m.collectPages(pageMapQuery{Prefix: treeRef.key + cmBranchSeparator}, func(c *contentNode) {\n\t\t\tpas = append(pas, c.p)\n\t\t})\n\t\tpage.SortByDefault(pas)\n\n\t\tsetNextPrev(pas)\n\n\t\treturn nil, nil\n\t})\n\n\ts.init.menus = init.Branch(func() (interface{}, error) {\n\t\ts.assembleMenus()\n\t\treturn nil, nil\n\t})\n\n\ts.init.taxonomies = init.Branch(func() (interface{}, error) {\n\t\terr := s.pageMap.assembleTaxonomies()\n\t\treturn nil, err\n\t})\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3. æ€§èƒ½ä¼˜åŒ–ç»†èŠ‚\u003c/h2\u003e\n\u003ch3\u003e3.1. interface å®ç°çº¦æŸ\u003c/h3\u003e\n\u003cp\u003eä»£ç ä¸­æœ‰å¤šå¤„ä½¿ç”¨å¦‚ä¸‹æ–¹å¼åœ¨ç¼–è¯‘æ—¶çº¦æŸ interface è¢«å®ç°ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003evar _ cmder = (*newCmd)(nil)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå…¶ä»–å¼€æºé¡¹ç›®ä¸­æœ‰ä¹Ÿæœ‰è¿™ç§å†™æ³•çš„ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003evar _ cmder = \u0026#x26;newCmd{}\nvar _ cmder = newCmd{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.2. é˜²æŠ–\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage debounce\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\n// New returns a debounced function that takes another functions as its argument.\n// This function will be called when the debounced function stops being called\n// for the given duration.\n// The debounced function can be invoked with different functions, if needed,\n// the last one will win.\nfunc New(after time.Duration) func(f func()) {\n\td := \u0026#x26;debouncer{after: after}\n\n\treturn func(f func()) {\n\t\td.add(f)\n\t}\n}\n\ntype debouncer struct {\n\tmu    sync.Mutex\n\tafter time.Duration\n\ttimer *time.Timer\n}\n\nfunc (d *debouncer) add(f func()) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n    // å¦‚æœæ­£åœ¨å»¶æ—¶ä¸­ï¼Œå–æ¶ˆå½“å‰å»¶æ—¶ï¼Œæ·»åŠ æ–°çš„å»¶æ—¶\n\tif d.timer != nil {\n\t\td.timer.Stop()\n\t}\n\td.timer = time.AfterFunc(d.after, f)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eé˜²æŠ–å‡½æ•°çš„ä½¿ç”¨ç±»ä¼¼ React Hooksã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ef := func()\nrun := debounce.New(f)\nrun()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eåœ¨ Istio æºç ä¸­ï¼Œå¤„ç† XDS æ¨æµæ—¶ä¹Ÿä¼šè¿›è¡Œé˜²æŠ–å¤„ç†ã€‚\u003c/p\u003e\n\u003ch3\u003e3.2. LIFO é˜Ÿåˆ—\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// LIFO é˜Ÿåˆ—ï¼Œæº¢å‡ºçš„å…ƒç´ ä¼šä»é¡¶éƒ¨ç§»é™¤\n// æ²¡æœ‰ä¸»åŠ¨åˆ é™¤å…ƒç´ çš„æ–¹æ³•\n// EvictingStringQueue is a queue which automatically evicts elements from the head of\n// the queue when attempting to add new elements onto the queue and it is full.\n// This queue orders elements LIFO (last-in-first-out). It throws away duplicates.\n// Note: This queue currently does not contain any remove (poll etc.) methods.\ntype EvictingStringQueue struct {\n\tsize int\n\tvals []string // å‚¨å­˜çœŸå®çš„æ•°æ®\n\tset  map[string]bool // è¡¨ç¤ºæ˜¯å¦å·²ç»å­˜åœ¨\n\tmu   sync.Mutex\n}\n\n// NewEvictingStringQueue creates a new queue with the given size.\nfunc NewEvictingStringQueue(size int) *EvictingStringQueue {\n\treturn \u0026#x26;EvictingStringQueue{size: size, set: make(map[string]bool)}\n}\n\n// Add adds a new string to the tail of the queue if it's not already there.\nfunc (q *EvictingStringQueue) Add(v string) {\n\tq.mu.Lock()\n\t// å·²ç»å­˜åœ¨\n\tif q.set[v] {\n\t\tq.mu.Unlock()\n\t\treturn\n\t}\n\n\t// æ•°é‡è¾¾åˆ°æœ€å¤§é™åˆ¶\n\tif len(q.set) == q.size {\n\t\t// Full\n\t\t// ç§»é™¤äº† 0 å·å…ƒç´ çš„å ä½ç¬¦\n\t\tdelete(q.set, q.vals[0])\n\t\t// :0 å–ç©ºæ•°ç»„ï¼Œ1:å–ä¸åŒ…å«ç¬¬ä¸€ä¸ªå…ƒç´ çš„å…¶ä½™å…ƒç´ \n\t\t// ç§»é™¤äº†æ•°ç»„ 0 å·å…ƒç´ \n\t\tq.vals = append(q.vals[:0], q.vals[1:]...)\n\t}\n\t// è¡¨ç¤ºå­˜åœ¨\n\tq.set[v] = true\n\t// æœ€æ–°æ’å…¥çš„å€¼åœ¨æ•°ç»„æœ€å\n\t// æ˜¯é˜Ÿåˆ—ç»“æ„\n\tq.vals = append(q.vals, v)\n\tq.mu.Unlock()\n}\n\n// Contains returns whether the queue contains v.\nfunc (q *EvictingStringQueue) Contains(v string) bool {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\treturn q.set[v]\n}\n\n// Peek looks at the last element added to the queue.\nfunc (q *EvictingStringQueue) Peek() string {\n\tq.mu.Lock()\n\tl := len(q.vals)\n\t// å¤„ç†è¾¹ç•Œæ¡ä»¶\n\tif l == 0 {\n\t\tq.mu.Unlock()\n\t\treturn \"\"\n\t}\n\t// å–æœ€åä¸€ä¸ªå…ƒç´ \n\telem := q.vals[l-1]\n\tq.mu.Unlock()\n\treturn elem\n}\n\n// PeekAll looks at all the elements in the queue, with the newest first.\nfunc (q *EvictingStringQueue) PeekAll() []string {\n\tq.mu.Lock()\n\tvals := make([]string, len(q.vals))\n\tcopy(vals, q.vals)\n\tq.mu.Unlock()\n\t// i ä»å¤´å¼€å§‹å¾ªç¯ j ä»å°¾å¾ªç¯\n\t// äº¤æ¢ i j å…ƒç´ ä½ç½®\n\t// æ•°ç»„ reverse\n\t// æœ€åæ’å…¥çš„åœ¨æœ€å‰é¢\n\tfor i, j := 0, len(vals)-1; i \u0026#x3C; j; i, j = i+1, j-1 {\n\t\tvals[i], vals[j] = vals[j], vals[i]\n\t}\n\treturn vals\n}\n\n// PeekAllSet returns PeekAll as a set.\nfunc (q *EvictingStringQueue) PeekAllSet() map[string]bool {\n\tall := q.PeekAll()\n\tset := make(map[string]bool)\n\tfor _, v := range all {\n\t\tset[v] = true\n\t}\n\n\treturn set\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.3. åŒæ­¥ä¿¡å·é‡\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egolang.org/x/sync/semaphore\u003c/code\u003e æ‰©å±•åŒæ­¥åŸè¯­ã€‚\u003c/p\u003e\n\u003ch3\u003e3.4. Command\u003c/h3\u003e\n\u003ch4\u003e3.4.1. CLI è‡ªåŠ¨è¡¥å…¨\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/2020-12-01-01.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eHugo çš„ä½¿ç”¨æ–¹å¼æœ‰ä¸¤ç§ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// \"-config\" flag è‡ªåŠ¨è¡¥å…¨æŒ‡å®šåç¼€æ–‡ä»¶å\n_ = cc.cmd.PersistentFlags().SetAnnotation(\"config\", cobra.BashCompFilenameExt, config.ValidConfigFileExtensions)\n\n// \"-source\" flag è‡ªåŠ¨è¡¥å…¨å­æ–‡ä»¶å¤¹å\ncmd.PersistentFlags().SetAnnotation(\"source\", cobra.BashCompSubdirsInDir, []string{})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.5. å¹¶å‘æ§åˆ¶\u003c/h3\u003e\n\u003ch4\u003e3.5.1. ç¼“å†²é€šé“æ§åˆ¶å¹¶å‘\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// common/para/para.go\n// Package para implements parallel execution helpers.\npackage para\n\nimport (\n\t\"context\"\n\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// Workers configures a task executor with the most number of tasks to be executed in parallel.\ntype Workers struct {\n\tsem chan struct{}\n}\n\n// Runner wraps the lifecycle methods of a new task set.\n//\n// Run wil block until a worker is available or the context is cancelled,\n// and then run the given func in a new goroutine.\n// Wait will wait for all the running goroutines to finish.\ntype Runner interface {\n\tRun(func() error)\n\tWait() error\n}\n\ntype errGroupRunner struct {\n\t*errgroup.Group\n\tw   *Workers\n\tctx context.Context\n}\n\nfunc (g *errGroupRunner) Run(fn func() error) {\n\tselect {\n\t// åˆ†é…ä¸€ä¸ªä¿¡å·, å¦‚æœ chan è¢«å…³é—­åˆ™é€€å‡º\n\tcase g.w.sem \u0026#x3C;- struct{}{}:\n\tcase \u0026#x3C;-g.ctx.Done():\n\t\treturn\n\t}\n\n\tg.Go(func() error {\n\t\terr := fn()\n\t\t// æ‰§è¡Œå®Œåæ¶ˆè´¹ä¿¡å·é‡, é€šè¿‡ç¼“å­˜é€šé“ä¿è¯å¹¶å‘æ‰§è¡Œçš„åç¨‹æ•°é‡\n\t\t\u0026#x3C;-g.w.sem\n\t\treturn err\n\t})\n}\n\n// New creates a new Workers with the given number of workers.\nfunc New(numWorkers int) *Workers {\n\treturn \u0026#x26;Workers{\n\t\t// ç¼“å†²é€šé“, å¹¶å‘å†™å…¥\n\t\tsem: make(chan struct{}, numWorkers),\n\t}\n}\n\n// Start starts a new Runner.\nfunc (w *Workers) Start(ctx context.Context) (Runner, context.Context) {\n\tg, ctx := errgroup.WithContext(ctx)\n\treturn \u0026#x26;errGroupRunner{\n\t\tGroup: g,\n\t\tctx:   ctx,\n\t\tw:     w,\n\t}, ctx\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlayground æµ‹è¯•ç¤ºä¾‹: \u003ca href=\"https://play.golang.org/p/4AJtyVnlSOd\"\u003ehttps://play.golang.org/p/4AJtyVnlSOd\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc main() {\n\tw := para.New(10)\n\trunner, _ := w.Start(context.TODO())\n\trunner.Run(func() error {\n\t\tfmt.Println(\"fucking\")\n\t\treturn nil\n\t})\n\ttime.Sleep(2 * time.Second)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.6. æ‡’åŠ è½½\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLazy åŒ…\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4\u003e3.6.1. onceMore\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage lazy\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\n// onceMore is similar to sync.Once.\n//\n// Additional features are:\n// * it can be reset, so the action can be repeated if needed\n// * it has methods to check if it's done or in progress\n//\ntype onceMore struct {\n\tmu   sync.Mutex\n\tlock uint32\n\tdone uint32\n}\n\nfunc (t *onceMore) Do(f func()) {\n\tif atomic.LoadUint32(\u0026#x26;t.done) == 1 {\n\t\treturn\n\t}\n\n\t// f may call this Do and we would get a deadlock.\n\tlocked := atomic.CompareAndSwapUint32(\u0026#x26;t.lock, 0, 1)\n\tif !locked {\n\t\t// æ²¡æœ‰æŠ¢åˆ°åŸå­æ“ä½œ\n\t\treturn\n\t}\n\t// é‡Šæ”¾åŸå­é”\n\t// defer æ˜¯ FILO, è¯¥åŸå­é”ä¼šæœ€åæ‰é‡Šæ”¾\n\tdefer atomic.StoreUint32(\u0026#x26;t.lock, 0)\n\n\t// å¹¶å‘é”, ä¿è¯ t.done å€¼çš„è¯»å–ä¸ä¼šäº§ç”Ÿç«äº‰\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\t// Double check\n\tif t.done == 1 {\n\t\treturn\n\t}\n\tdefer atomic.StoreUint32(\u0026#x26;t.done, 1)\n\tf()\n}\n\nfunc (t *onceMore) InProgress() bool {\n\treturn atomic.LoadUint32(\u0026#x26;t.lock) == 1\n}\n\nfunc (t *onceMore) Done() bool {\n\treturn atomic.LoadUint32(\u0026#x26;t.done) == 1\n}\n\nfunc (t *onceMore) ResetWithLock() *sync.Mutex {\n\tt.mu.Lock()\n\tdefer atomic.StoreUint32(\u0026#x26;t.done, 0)\n\treturn \u0026#x26;t.mu\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e3.6.2. init\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage lazy\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// New creates a new empty Init.\nfunc New() *Init {\n\treturn \u0026#x26;Init{}\n}\n\n// Init holds a graph of lazily initialized dependencies.\ntype Init struct {\n\tmu sync.Mutex // å¹¶å‘ä¿®æ”¹å›¾çš„é”\n\n\tprev     *Init\n\tchildren []*Init\n\n\tinit onceMore // ä¿è¯åªæ‰§è¡Œä¸€æ¬¡çš„é”\n\tout  interface{} // æ‰§è¡Œç»“æœ\n\terr  error // æ‰§è¡Œé”™è¯¯\n\tf    func() (interface{}, error) // å›è°ƒå‡½æ•°\n}\n\n// Add adds a func as a new child dependency.\nfunc (ini *Init) Add(initFn func() (interface{}, error)) *Init {\n\tif ini == nil {\n\t\tini = New()\n\t}\n\treturn ini.add(false, initFn)\n}\n\n// AddWithTimeout is same as Add, but with a timeout that aborts initialization.\nfunc (ini *Init) AddWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init {\n\treturn ini.Add(func() (interface{}, error) {\n\t\treturn ini.withTimeout(timeout, f)\n\t})\n}\n\n// Branch creates a new dependency branch based on an existing and adds\n// the given dependency as a child.\nfunc (ini *Init) Branch(initFn func() (interface{}, error)) *Init {\n\tif ini == nil {\n\t\tini = New()\n\t}\n\treturn ini.add(true, initFn)\n}\n\n// BranchdWithTimeout is same as Branch, but with a timeout.\nfunc (ini *Init) BranchWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init {\n\treturn ini.Branch(func() (interface{}, error) {\n\t\treturn ini.withTimeout(timeout, f)\n\t})\n}\n\n// Do initializes the entire dependency graph.\nfunc (ini *Init) Do() (interface{}, error) {\n\tif ini == nil {\n\t\tpanic(\"init is nil\")\n\t}\n\n\t// è°ƒç”¨ onceMore åº“ä¿è¯åªæ‰§è¡Œä¸€æ¬¡\n\tini.init.Do(func() {\n\t\t// è·å–çˆ¶èŠ‚ç‚¹\n\t\tprev := ini.prev\n\t\tif prev != nil {\n\t\t\t// A branch. Initialize the ancestors.\n\t\t\t// è‹¥çˆ¶èŠ‚ç‚¹è¿˜æ²¡æœ‰å®Œæˆåˆå§‹åŒ–, å¹¶ä¸”æ²¡æœ‰æ­£åœ¨æ‰§è¡Œçš„å›è°ƒå‡½æ•°, æ‰§è¡Œ\n\t\t\tif prev.shouldInitialize() {\n\t\t\t\t_, err := prev.Do()\n\t\t\t\tif err != nil {\n\t\t\t\t\tini.err = err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if prev.inProgress() {\n\t\t\t\t// Concurrent initialization. The following init func\n\t\t\t\t// may depend on earlier state, so wait.\n\t\t\t\t// ç­‰å¾…ä¸€å®šæ—¶é—´, è‹¥æ²¡æœ‰æ‰§è¡Œå®Œ, panic\n\t\t\t\tprev.wait()\n\t\t\t}\n\t\t}\n\n\t\t// æ‰§è¡Œå›è°ƒå‡½æ•°\n\t\tif ini.f != nil {\n\t\t\tini.out, ini.err = ini.f()\n\t\t}\n\n\t\t// å¾ªç¯æ‰§è¡Œå­èŠ‚ç‚¹çš„å›è°ƒå‡½æ•°\n\t\t// ä¸ºä»€ä¹ˆä¸å¹¶å‘æ‰§è¡Œ ?\n\t\tfor _, child := range ini.children {\n\t\t\tif child.shouldInitialize() {\n\t\t\t\t_, err := child.Do()\n\t\t\t\tif err != nil {\n\t\t\t\t\tini.err = err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tini.wait()\n\n\treturn ini.out, ini.err\n}\n\n// TODO(bep) investigate if we can use sync.Cond for this.\nfunc (ini *Init) wait() {\n\tvar counter time.Duration\n\tfor !ini.init.Done() {\n\t\tcounter += 10\n\t\tif counter \u003e 600000000 {\n\t\t\tpanic(\"BUG: timed out in lazy init\")\n\t\t}\n\t\ttime.Sleep(counter * time.Microsecond)\n\t}\n}\n\nfunc (ini *Init) inProgress() bool {\n\treturn ini != nil \u0026#x26;\u0026#x26; ini.init.InProgress()\n}\n\n// è‹¥ æ²¡æœ‰æ³¨å†Œäº†å›è°ƒå‡½æ•° | å·²ç»å®Œæˆ | æ­£åœ¨æ‰§è¡Œ, ä¸è¿›è¡Œåˆå§‹åŒ–\nfunc (ini *Init) shouldInitialize() bool {\n\treturn !(ini == nil || ini.init.Done() || ini.init.InProgress())\n}\n\n// Reset resets the current and all its dependencies.\nfunc (ini *Init) Reset() {\n\tmu := ini.init.ResetWithLock()\n\tdefer mu.Unlock()\n\tfor _, d := range ini.children {\n\t\td.Reset()\n\t}\n}\n\n// æ·»åŠ å›¾çš„èŠ‚ç‚¹\nfunc (ini *Init) add(branch bool, initFn func() (interface{}, error)) *Init {\n\tini.mu.Lock()\n\tdefer ini.mu.Unlock()\n\n\t// å¦‚æœæ˜¯æ–°å»ºåˆ†æ”¯\n\tif branch {\n\t\treturn \u0026#x26;Init{\n\t\t\tf:    initFn,\n\t\t\tprev: ini, // çˆ¶èŠ‚ç‚¹\n\t\t}\n\t}\n\n\t// å¦‚æœæ˜¯æ·»åŠ å­èŠ‚ç‚¹\n\t// å¦‚æœå·²ç»è¢«æ‰§è¡Œ, panic\n\tini.checkDone()\n\t// æ·»åŠ å­èŠ‚ç‚¹\n\tini.children = append(ini.children, \u0026#x26;Init{\n\t\tf: initFn,\n\t})\n\n\t// é‡Šæ”¾é”\n\treturn ini\n}\n\nfunc (ini *Init) checkDone() {\n\tif ini.init.Done() {\n\t\tpanic(\"init cannot be added to after it has run\")\n\t}\n}\n\n// callback å‡½æ•°, æœ‰è¶…æ—¶æ—¶é—´\nfunc (ini *Init) withTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) (interface{}, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\t// ç¼“å­˜é€šé“, é˜²æ­¢é˜»å¡\n\tc := make(chan verr, 1)\n\n\tgo func() {\n\t\tv, err := f(ctx)\n\t\tselect {\n\t\tcase \u0026#x3C;-ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\tc \u0026#x3C;- verr{v: v, err: err}\n\t\t}\n\t}()\n\n\tselect {\n\tcase \u0026#x3C;-ctx.Done():\n\t\treturn nil, errors.New(\"timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file.\")\n\tcase ve := \u0026#x3C;-c:\n\t\treturn ve.v, ve.err\n\t}\n}\n\ntype verr struct {\n\tv   interface{}\n\terr error\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003csection data-footnotes class=\"footnotes\"\u003e\u003ch2 class=\"sr-only\" id=\"footnote-label\"\u003eFootnotes\u003c/h2\u003e\n\u003col\u003e\n\u003cli id=\"user-content-fn-1\"\u003e\n\u003cp\u003e\u003ca href=\"https://imroc.io/posts/kubernetes/analysis-exitcode/\"\u003eKubernetes é—®é¢˜å®šä½æŠ€å·§ï¼šåˆ†æ ExitCode - imroc.io|rocçš„åšå®¢|Cloud Native|Kubernetes|Go|Golang\u003c/a\u003e \u003ca href=\"#user-content-fnref-1\" data-footnote-backref=\"\" aria-label=\"Back to reference 1\" class=\"data-footnote-backref\"\u003eâ†©\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e"])</script><script>self.__next_f.push([1,"4:[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]\n"])</script></body></html>